{"meta":{"title":"Title","subtitle":"","description":"","author":"just coding","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"面试题/解决修改css或js文件后，浏览器缓存未更新问题","slug":"面试题/解决修改css或js文件后，浏览器缓存未更新问题","date":"2020-04-21T09:12:19.528Z","updated":"2020-04-21T09:32:29.290Z","comments":true,"path":"2020/04/21/面试题/解决修改css或js文件后，浏览器缓存未更新问题/","link":"","permalink":"http://yoursite.com/2020/04/21/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%A7%A3%E5%86%B3%E4%BF%AE%E6%94%B9css%E6%88%96js%E6%96%87%E4%BB%B6%E5%90%8E%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%AA%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题描述：最近在上线新版本项目的时候，发现有新的用户的操作还是调用的老版本JS里面的内容，这样就造成原来新的JS里面加上的限制不能限制用户的操作，从而导致用户可以重复操作。 问题产生原因：如果用户之前已经访问过系统，那么浏览器会缓存该系统的CSS\\JS,这些CSS、JS缓存未过期之前，浏览器只会从缓存中读取CSS和JS，如果服务器上修改了css和js,那么这些修改在用户的浏览器中是不会有变化的。 解决方式一：用户按ctrl+F5强制刷新页面或者手动清空了浏览器的缓存。此时浏览器会重新向服务器获取CSS和JS文件，新的文件便会生效。 解决方式二：但是用户量过大的时候总不能让每个用户一一清理缓存吧，于是便从代码角度着手解决这个问题。在js后面添加版本号，让浏览器把这个JS文件当做新的文件重新向服务器获取资源。在资源后面加版本号。 问题延伸：但是JS文件或CSS过多的情况下需要一个一个的去修改版本号，会花费大量的时间，此时就需要版本号是动态获取的了。更换为从messages.properties中读取：&lt;script type=&quot;text/javascript&quot; th:src=“@{/js/test/index.js(v=#{js.version})}&gt;&lt;/script&gt;Messages.properties内容如下：js.version=2.0注意：如果要读到配置文件内容，配置文件名必须是messages.properties。否则会出现错误 ajax存在一个问题就在于回调地狱，fetch很好解决了回调地狱的问题：cookie的传递：fetch发送请求时，不想XHR，因为它默认不带上cookie的，可能会导致未经认证的请求，所以我们需要手动的把cookie带上，只需加上credentials: ‘include’promise: Promise 对象有一下两个特点：1，对象的状态不受外界影响。promise 对象代表一个异步操作，有三种状态：pending： 初始状态，不是成功或失败状态。fulfilled： 意味着成功操作完成。rejected: 意味着操作失败。2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 promise的优缺点：有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promise.all方法，promise.race方法：Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 对象的实例。（Promise.all 方法的参数不一定是数组，但是必须具有 iterator 接口，且返回的每个成员都是 Promise 实例。） 浏览器是怎么对HTML5的离线储存资源进行管理和加载呢？ 在线情况下，浏览器发现html头部有mainfest属性，它会请求mainfest文件，如果是第一次访问app，那么浏览器就会根据mainfest文件内容下载响应的资源并进行离线存储。如果已经访问过app并且资源离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的mainfest文件与旧的mainfest文件，如果文件没有发生变化，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小：cookie数据大小不能超过4ksessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间：localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据sessionStorage 数据在当前浏览器窗口关闭后自动删除cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 什么是 Cookie HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。Cookie 主要用于以下三个方面：会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）个性化设置（如用户自定义设置、主题等）浏览器行为跟踪（如跟踪分析用户行为等） 什么是 Session Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。 Cookie 和 Session 有什么不同？ 作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。 为什么需要 Cookie 和 Session，他们有什么关联？ 说起来为什么需要 Cookie ，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的(HTTP 协议无状态)，这意味着浏览器并不知道是张三还是李四在和服务端打交道。这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合。那么 Cookie 和 Session 是如何配合的呢？我画了一张图大家可以先了解下。用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。 既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。 第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 xxx?SessionID=123456…。第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。","categories":[],"tags":[],"keywords":[]},{"title":"redux/final-words","slug":"redux/final-words","date":"2020-03-24T14:58:07.108Z","updated":"2020-03-24T14:58:29.756Z","comments":true,"path":"2020/03/24/redux/final-words/","link":"","permalink":"http://yoursite.com/2020/03/24/redux/final-words/","excerpt":"","text":"章节 12 - final-words.js 除了本教程，其实 Redux 和 react-redux 还有很多可以学习的。比如: 考虑到 Redux 的安全性，你可能会对 bindActionCreators 感兴趣（创建一个已绑定到 dispatch 的 action creators hash 对象 -http:rackt.org/redux/docs/api/bindActionCreators.html)。 希望我们已经给了你一些秘诀去更好的理解 Flux ，以及 Flux 不同实现之间的区别 –当然包括 Redux 是如何脱颖而出的 ;)。 接下去呢? Redux 的官方文档真的非常出色和详尽，所以从现在开始不要再犹豫要不要看它了： http:rackt.org/redux/index.html 祝你和 React、Redux 玩的开心2333!","categories":[],"tags":[],"keywords":[]},{"title":"redux/Provider-and-connect","slug":"redux/Provider-and-connect","date":"2020-03-24T14:57:15.797Z","updated":"2020-03-24T14:58:29.750Z","comments":true,"path":"2020/03/24/redux/Provider-and-connect/","link":"","permalink":"http://yoursite.com/2020/03/24/redux/Provider-and-connect/","excerpt":"","text":"章节 11 - Provider-and-connect.js 这其实是教程的最后一章，一起聊聊如何把 Redux 和 React 绑定在一起。 要运行下面的示例，你需要一个浏览器。 本示例中的代码和注释都在 ./11_src/src/ 目录下。 当你读到下面这段话的时间，请运行 11_src/src/server.js。 开发一个 React 应用和服务器来让浏览器可以访问，我们会用到： 用 node HTTP(https:nodejs.org/api/http.html) 创建一个非常简单的服务器 用 Webpack 去打包我们的应用， 神奇的 Webpack Dev Server (http:webpack.github.io/docs/webpack-dev-server.html)作为一个专门的 node 服务器，并监听 JS 改变自动编译 超棒的 React Hot Loader http:gaearon.github.io/react-hot-loader/ (Dan Abramov开发的另一个很棒的项目，没错，他就是 Redux 的作者) ，提供非常棒的DX (开发体验) ，当我们在编辑器中修改代码时，在浏览器中可以热加载来显示效果。 提醒一下正在使用 React 的开发者：本应用是基于 React 0.14 构建的 我不想在这里详细地解释如何设置 Webpack Dev Server 和 React Hot Loader，因为在 React Hot Loader 的文档中已经说的很好了。import webpackDevServer from &#39;./11_src/src/webpack-dev-server&#39;我们应用启动的主要服务器请求都是来自这个文件。import server from &#39;./11_src/src/server&#39; 如果 5050 端口号已经被占用了，那么就修改下面的端口号。如果端口号是 X，那么我们可以用 X 作为服务器的端口号，用 X+1 作为 webpack-dev-server 的端口号const port = 5050 启动 webpack dev server…webpackDevServer.listen(port)… 还有主应用服务器。server.listen(port) console.log(Server is listening on http:127.0.0.1:${port}) 转到 11_src/src/server.js… 下一章节：12_final-words.js","categories":[],"tags":[],"keywords":[]},{"title":"redux/state-subscriber","slug":"redux/state-subscriber","date":"2020-03-24T14:56:16.914Z","updated":"2020-03-24T14:58:29.758Z","comments":true,"path":"2020/03/24/redux/state-subscriber/","link":"","permalink":"http://yoursite.com/2020/03/24/redux/state-subscriber/","excerpt":"","text":"章节 10 - state-subscriber.js 我们接近完成一个完整的 Flux 闭环了，现在只差一个至关重要的环节： | | | Change | | React | | Store |—-▶ events |—–▶ Views | |_____| |_____| |___| 没有它，在 store 改变时我们就不能更新我们的视图。 幸运的是，监视 Redux store 更新有一个很简单的办法： /* store.subscribe(function() { retrieve latest store state here Ex: console.log(store.getState()); })*/ 是的，简单到我们都开始重新相信圣诞老人了(译者注：2333，对不起这个比喻太幽默了） 试一下这段代码: 123456789101112131415161718192021222324252627282930313233343536import &#123; createStore, combineReducers &#125; from 'redux'var itemsReducer = function (state = [], action) &#123; console.log('itemsReducer was called with state', state, 'and action', action) switch (action.type) &#123; case 'ADD_ITEM': return [ ...state, action.item ] default: return state; &#125;&#125;var reducer = combineReducers(&#123; items: itemsReducer &#125;)var store_0 = createStore(reducer)store_0.subscribe(function() &#123; console.log('store_0 has been updated. Latest store state:', store_0.getState()); 在这里更新你的视图&#125;)var addItemActionCreator = function (item) &#123; return &#123; type: 'ADD_ITEM', item: item &#125;&#125;store_0.dispatch(addItemActionCreator(&#123; id: 1234, description: 'anything' &#125;)) 输出: ... store_0 has been updated. Latest store state: &#123; items: [ &#123; id: 1234, description: 'anything' &#125; ] &#125; 我们的订阅回调成功的调用了，同时 store 现在包含了我们新增的条目。 理论上，到这就可以停止了。我们的 Flux loop 已经闭合，我们理解了构造 Flux 的全部概念， 实际上它也没那么神秘。但是老实说，还有很多要讲的， 为了让最后一个概念保持简单， 我们有意的在例子中去掉了一些东西： 我们的订阅回调没有把 state 作为参数，为什么？ 既然我们没有接受新的 state， 我们就被限定到了只能开发这个已经完成的 store (store_0) 所以这个办法在 含有多个模块的应用下不可行。 我们究竟是怎么更新视图的？ 怎么取消订阅？ 更通俗的讲，我们怎么把 Redux 和 React 结合到一起？ 我们现在进入了一个“将 Redux 加入到 React” 的领域。 理解 Redux 可以无条件绑定到 React 上是很重要的。Redux 是一个“为 Javascript 应用而生的可预测的状态容器”，你有很多方式去使用它，而 React 应用只不过是其中一个。 从这个角度看，如果没有 react-redux (https:github.com/reactjs/react-redux)，我们将失去很多。在 Redux 1.0.0 之前它是包含在 Redux 中的，这个库节省了我们很多时间，它包含了在 React 中使用 Redux 时所有的绑定。 回到订阅这件事，为什么我们这个订阅函数看上去非常简单而且没有提供很多特性？ 这就是 Redux 精彩之处了！ 它所有 API 都很抽象（包括订阅），支持高度扩展，允许开发者造出一些疯狂的轮子比如 Redux DevTools (https:github.com/gaearon/redux-devtools). 但是最后我们还是需要一个更好的接口订阅我们的 store 变化。这也就是 react-redux 给带给我们的：一个完美填补原生 Redux 订阅机制和开发者的期待之间的空缺的 API ，这样我们不再需要直接使用订阅。而只是使用 “provide” 和 “connect” 绑定，不必再关心隐含在内的订阅方法。 所以，订阅方法依然会被我们使用，只不过它通过高度整合的接口替我们处理 redux state 的连接。 现在我们隐藏了那些绑定，并且展示了连接你的组件和 Redux 的 state 是很轻松的一件事。 继续下一个教程: 11_Provider-and-connect.js","categories":[],"tags":[],"keywords":[]},{"title":"redux/middleware","slug":"redux/middleware","date":"2020-03-24T14:54:11.761Z","updated":"2020-03-24T14:58:29.753Z","comments":true,"path":"2020/03/24/redux/middleware/","link":"","permalink":"http://yoursite.com/2020/03/24/redux/middleware/","excerpt":"","text":"章节 9 - middleware.js 在 dispatch-async-action-2.js 章节中我们抛出了“中间件”的概念。中间件似乎 可以帮助我们处理异步 action。但中间件到底是什么呢？ 通常来说中间件是在某个应用中 A 和 B 部分中间的那一块， 中间件可以把 A 发送数据到 B 的形式从 A -----&gt; B 变成:A ---&gt; middleware 1 ---&gt; middleware 2 ---&gt; middleware 3 --&gt; ... ---&gt; B 那么中间件在 Redux 中是如何工作的？ 看上去 Redux 并不能自动处理 action creator 中返回的异步函数。 但如果在 action creator 和 reducer 之间增加一个中间件，就可以把这个函数转成 适合 Redux 处理的内容： action ---&gt; dispatcher ---&gt; middleware 1 ---&gt; middleware 2 ---&gt; reducers 每当一个 action（或者其他诸如异步 action creator 中的某个函数）被分发时， 我们的中间件就会被调用 并且在需要的时候协助 action creator 分发真正的 action（或者什么都不做， 有时我们需要这么做） 在 Redux 中，中间件是纯粹的函数， 有明确的使用方法并且严格的遵循以下格式：/* var anyMiddleware = function ({ dispatch, getState }) { return function(next) { return function (action) { 你的中间件业务相关代码 } } }*/ 如上所述，中间件由三个嵌套的函数构成（会依次调用）： 1) 第一层向其余两层提供分发函数和 getState 函数 （因为你的中间件或 action creator 可能需要从 state 中读取数据） 2) 第二层提供 next 函数，它允许你显式的将处理过的输入传递给下一个中间件或 Redux （这样 Redux 才能调用所有 reducer)。 3) 第三层提供从上一个中间件或从 dispatch 传递来的 action， 这个 action 可以调用下一个中间件（让 action 继续流动) 或者 以想要的方式处理 action。 学习过函数式编程的人可能会意识到给上述代码提供了一个机会来使用 柯里化（如果你不理解也没关系，跳过接下去的 10 行，不会影响你对 redux 的理解）。 使用柯里化，你可以简化上述函数：/* “curry” may come any functional programming library (lodash, ramda, etc.) var thunkMiddleware = curry( ({dispatch, getState}, next, action) =&gt; ( 你的中间件业务相关代码 ) );*/ 我们为异步 action creator 提供的中间件叫 thunk middleware 它的代码在：https:github.com/gaearon/redux-thunk. 它看上去是这样 (为了可读性使用 ES5 语法书写该函数）: 123456789101112var thunkMiddleware = function (&#123; dispatch, getState &#125;) &#123; console.log('Enter thunkMiddleware'); return function(next) &#123; console.log('Function \"next\" provided:', next); return function (action) &#123; console.log('Handling action:', action); return typeof action === 'function' ? action(dispatch, getState) : next(action) &#125; &#125;&#125; 为了让 Redux 知道我们有一个或多个中间件，我们使用 Redux 的 辅助函数：applyMiddleware. applyMiddleware 接收所有中间件作为参数，返回一个供 Redux createStore 调用的函数。 当最后这个函数被调用时，它会产生一个 Store 增强器，用来将所有中间件应用到 Store 的 dispatch 上。 (来自 https:github.com/rackt/redux/blob/v1.0.0-rc/src/utils/applyMiddleware.js) 下面就是如何将一个中间件应用到 Redux store： 1234567891011121314151617181920212223242526import &#123; createStore, combineReducers, applyMiddleware &#125; from 'redux'const finalCreateStore = applyMiddleware(thunkMiddleware)(createStore) 针对多个中间件， 使用：applyMiddleware(middleware1, middleware2, ...)(createStore)var reducer = combineReducers(&#123; speaker: function (state = &#123;&#125;, action) &#123; console.log('speaker was called with state', state, 'and action', action) switch (action.type) &#123; case 'SAY': return &#123; ...state, message: action.message &#125; default: return state &#125; &#125;&#125;)const store_0 = finalCreateStore(reducer) 输出: speaker was called with state &#123;&#125; and action &#123; type: '@@redux/INIT' &#125; speaker was called with state &#123;&#125; and action &#123; type: '@@redux/PROBE_UNKNOWN_ACTION_s.b.4.z.a.x.a.j.o.r' &#125; speaker was called with state &#123;&#125; and action &#123; type: '@@redux/INIT' &#125; 现在 store 的 middleware 已经准备好了，再来尝试分发我们的异步 action： 12345678910111213141516171819var asyncSayActionCreator_1 = function (message) &#123; return function (dispatch) &#123; setTimeout(function () &#123; console.log(new Date(), 'Dispatch action now:') dispatch(&#123; type: 'SAY', message &#125;) &#125;, 2000) &#125;&#125;console.log(\"\\n\", new Date(), 'Running our async action creator:', \"\\n\")store_0.dispatch(asyncSayActionCreator_1('Hi')) 输出: Mon Aug 03 2015 00:01:20 GMT+0200 (CEST) Running our async action creator: Mon Aug 03 2015 00:01:22 GMT+0200 (CEST) 'Dispatch action now:' speaker was called with state &#123;&#125; and action &#123; type: 'SAY', message: 'Hi' &#125; 当我们调用异步 action creator 两秒之后，action 成功被分发出去。 你可能会好奇，一个中间件如何 log 出所有已分发的 action ， 是这样： 12345678function logMiddleware (&#123; dispatch, getState &#125;) &#123; return function(next) &#123; return function (action) &#123; console.log('logMiddleware action received:', action) return next(action) &#125; &#125;&#125; 同样的，下面是一个中间件，它会丢弃所有经过的 action（不是很实用， 但是如果加一些判断就能实现丢弃一些 action，放到一些 action 给下一个中间件）： 1234567function discardMiddleware (&#123; dispatch, getState &#125;) &#123; return function(next) &#123; return function (action) &#123; console.log('discardMiddleware action received:', action) &#125; &#125;&#125; 通过使用 logMiddleware 或 discardMiddleware 试着修改上述的 finalCreateStore 调用 看看会发生什么… 比如，这样用: const finalCreateStore = applyMiddleware(discardMiddleware, thunkMiddleware)(createStore) 会让你的 action 永远无法到达 thunkMiddleware 和 reducer。 查看 http:rackt.org/redux/docs/introduction/Ecosystem.html 的中间件部分可以了解其他例子。 总结一下到目前为止我们所学的： 1) 我们知道怎样写 action 和 action creator 2) 我们知道怎样分发 action 3) 我们知道怎样使用中间件处理自定义 action，比如异步 action 对于 Flux 体系的完整闭环，我们还剩下唯一的一块就是如何订阅 state 的更新 并响应这些更新（比如重新渲染我们的组件) 所以我们怎么订阅 Redux store 的更新呢？ 继续下一个教程: 10_state-subscriber.js","categories":[],"tags":[],"keywords":[]},{"title":"redux/dispatch-async-action-2","slug":"redux/dispatch-async-action-2","date":"2020-03-24T14:53:02.285Z","updated":"2020-03-24T14:53:56.308Z","comments":true,"path":"2020/03/24/redux/dispatch-async-action-2/","link":"","permalink":"http://yoursite.com/2020/03/24/redux/dispatch-async-action-2/","excerpt":"","text":"章节 8 - dispatch-async-action-2.js 运行之前我们在 dispatch-async-action-1.js 中实现的第一个异步 action creator： 12345678910111213141516171819202122232425262728293031323334353637383940import &#123; createStore, combineReducers &#125; from 'redux'var reducer = combineReducers(&#123; speaker: function (state = &#123;&#125;, action) &#123; console.log('speaker was called with state', state, 'and action', action) switch (action.type) &#123; case 'SAY': return &#123; ...state, message: action.message &#125; default: return state; &#125; &#125;&#125;)var store_0 = createStore(reducer)var asyncSayActionCreator_1 = function (message) &#123; return function (dispatch) &#123; setTimeout(function () &#123; dispatch(&#123; type: 'SAY', message &#125;) &#125;, 2000) &#125;&#125;console.log(\"\\n\", 'Running our async action creator:', \"\\n\")store_0.dispatch(asyncSayActionCreator_1('Hi'))// 输出： ... /Users/classtar/Codes/redux-tutorial/node_modules/redux/node_modules/invariant/invariant.js:51 throw error; ^ Error: Invariant Violation: Actions must be plain objects. Use custom middleware for async actions. ... 我们所设计的 function 似乎没有进入 reducer 函数。但是 Redux 给出了温馨提示：使用自定义中间件（middleware）来支持异步 action。 看来我们的方向是正确的，可中间件（middleware）又是什么呢？ 我向你保证 action creator asyncSayActionCreator_1 不仅没有问题，而且只要我们搞清楚 middleware 的概念并掌握它的使用方法， 这个异步 action creator 就会按照我们所设想的结果执行。 开始下节教程：09_middleware.js","categories":[],"tags":[],"keywords":[]},{"title":"redux/dispatch-async-action","slug":"redux/dispatch-async-action","date":"2020-03-24T14:51:23.461Z","updated":"2020-03-24T14:53:56.311Z","comments":true,"path":"2020/03/24/redux/dispatch-async-action/","link":"","permalink":"http://yoursite.com/2020/03/24/redux/dispatch-async-action/","excerpt":"","text":"章节 7 - dispatch-async-action-1.js 在上节教程中我们知道了如何分发 action 以及这些 action 如何通过 reducer 函数修改应用状态。 但是，到目前为止，我们只考虑了一种情况，同步场景下的 action，准确地说是同步 action creator，它创建同步的 action， 也就是当 action creator 被调用时，action 会被立即返回。 我们来设想一个简单的异步场景： 1）用户点击“Say Hi in 2 seconds”按钮 2）当用户点击按钮 A，我们希望经过两秒，视图显示一条消息 Hi 3）两秒过去之后，更新视图，显示消息 Hi 当然这条消息是应用的状态之一，所以我们必然将其存储于 Redux store。 但是我们希望的结果是，在调用 action creator 的两秒之后才把消息存入 store（因为如果立即更新状态， 那么就会立即触发所有监听状态变更的订阅者 —— 例如视图，导致消息早于两秒显示）。 如果我们按照目前调用 action creator 的方式… 123456789101112131415161718192021222324252627282930313233343536373839import &#123; createStore, combineReducers &#125; from 'redux'var reducer = combineReducers(&#123; speaker: function (state = &#123;&#125;, action) &#123; console.log('speaker was called with state', state, 'and action', action) switch (action.type) &#123; case 'SAY': return &#123; ...state, message: action.message &#125; default: return state; &#125; &#125;&#125;)var store_0 = createStore(reducer)var sayActionCreator = function (message) &#123; return &#123; type: 'SAY', message &#125;&#125;console.log(\"\\n\", 'Running our normal action creator:', \"\\n\")console.log(new Date());store_0.dispatch(sayActionCreator('Hi'))console.log(new Date());console.log('store_0 state after action SAY:', store_0.getState()) 输出（忽略初始输出）： Sun Aug 02 2015 01:03:05 GMT+0200 (CEST) speaker was called with state &#123;&#125; and action &#123; type: 'SAY', message: 'Hi' &#125; Sun Aug 02 2015 01:03:05 GMT+0200 (CEST) store_0 state after action SAY: &#123; speaker: &#123; message: 'Hi' &#125; &#125; … 结果 store 被立即更新了。 我们希望看到的结果应该类似于下面这样的代码： 12345678var asyncSayActionCreator_0 = function (message) &#123; setTimeout(function () &#123; return &#123; type: 'SAY', message &#125; &#125;, 2000)&#125; 但是这样 action creator 返回的不是 action 而是 undefined。所以这并不是我们所期望的解决方法。 这里有个诀窍：不返回 action，而是返回 function。这个 function 会在合适的时机 dispatch action。但是如果我们希望 这个 function 能够 dispatch action，那么就需要向它传入 dispatch 函数。于是代码类似如下： 12345678910var asyncSayActionCreator_1 = function (message) &#123; return function (dispatch) &#123; setTimeout(function () &#123; dispatch(&#123; type: 'SAY', message &#125;) &#125;, 2000) &#125;&#125; 你可能再次注意到 action creator 返回的不是 action 而是 function。 所以 reducer 函数很可能不知道如何处理这样的返回值，而你也并不清楚是否可行，那么让我们一起再做尝试，一探究竟。 开始下节教程：08_dispatch-async-action-2.js","categories":[],"tags":[],"keywords":[]},{"title":"redux/dispatch-action","slug":"redux/dispatch-action","date":"2020-03-24T14:47:07.508Z","updated":"2020-03-24T14:49:10.910Z","comments":true,"path":"2020/03/24/redux/dispatch-action/","link":"","permalink":"http://yoursite.com/2020/03/24/redux/dispatch-action/","excerpt":"","text":"章节 6 - dispatch-action.js 迄今为止我们的关注点都是绑定我们的 reducer，但我们还未 dispatch 任何一个 action。 我们将会用到上一章的 reducer ，并用它们处理一些 action： 12345678910111213141516171819202122232425262728293031323334353637383940var userReducer = function (state = &#123;&#125;, action) &#123; console.log('userReducer was called with state', state, 'and action', action) switch (action.type) &#123; case 'SET_NAME': return &#123; ...state, name: action.name &#125; default: return state; &#125;&#125;var itemsReducer = function (state = [], action) &#123; console.log('itemsReducer was called with state', state, 'and action', action) switch (action.type) &#123; case 'ADD_ITEM': return [ ...state, action.item ] default: return state; &#125;&#125;import &#123;combineReducers, createStore&#125; from 'redux'var reducer = combineReducers(&#123; user: userReducer, items: itemsReducer&#125;)var store_0 = createStore(reducer)console.log(\"\\n\", '### It starts here')console.log('store_0 state after initialization:', store_0.getState())// 输出： store_0 state after initialization: &#123; user: &#123;&#125;, items: [] &#125; 让我们来 dispatch 我们的第一个 action… 记住在 ‘simple-action-creator.js’ 中所提到的： “为了 dispatch 一个 action，我们需要一个 dispatch 函数。” 我们所看到的 dispatch 函数，是 Redux 提供的，并且它会将 action 传递 给任何一个 reducer！dispatch 函数本质上是 Redux 的实例的属性 “dispatch” dispatch 一个 action： 123456store_0.dispatch(&#123; type: 'AN_ACTION'&#125;) 输出： userReducer was called with state &#123;&#125; and action &#123; type: 'AN_ACTION' &#125; itemsReducer was called with state [] and action &#123; type: 'AN_ACTION' &#125; 每一个 reducer 都被调用了，但是没有一个 action type 是 reducer 需要的， 因此 state 是不会发生变化的： 12console.log('store_0 state after action AN_ACTION:', store_0.getState())// 输出：store_0 state after action AN_ACTION: &#123; user: &#123;&#125;, items: [] &#125; 但是，等一下！我们是不是可以用一个 action creator 去发送一个 action？我们确实可以 用一个 actionCreator，但由于它只是返回一个 action，那么就意味着它不会携带任何东西 到这个例子中。但为了面对未来遇到的困难，我们还是以正确的方式， 即以 flux 理论去做吧。让我们使用这个 action creator 发送一个我们想要的 action： 123456789101112131415var setNameActionCreator = function (name) &#123; return &#123; type: 'SET_NAME', name: name &#125;&#125;store_0.dispatch(setNameActionCreator('bob')) 输出： userReducer was called with state &#123;&#125; and action &#123; type: 'SET_NAME', name: 'bob' &#125; itemsReducer was called with state [] and action &#123; type: 'SET_NAME', name: 'bob' &#125;console.log('store_0 state after action SET_NAME:', store_0.getState()) 输出： store_0 state after action SET_NAME: &#123; user: &#123; name: 'bob' &#125;, items: [] &#125; 我们刚刚处理了一个 action，并且它改变了应用的 state！ 但是这似乎太简单了，并且还不足以充当一个真实的用例。例如， 如果我们要在 dispatch action 之前做一些异步的操作，那应该怎么做呢？ 我们将在下一章节 “dispatch-async-action.js” 中讨论这个问题 至止，我们接触的应用流程是这样的： ActionCreator -&gt; Action -&gt; dispatcher -&gt; reducer 下一章节：07_dispatch-async-action-1.js","categories":[],"tags":[],"keywords":[]},{"title":"redux/combine-reducers","slug":"redux/combine-reducers","date":"2020-03-24T14:43:40.254Z","updated":"2020-03-24T14:49:10.920Z","comments":true,"path":"2020/03/24/redux/combine-reducers/","link":"","permalink":"http://yoursite.com/2020/03/24/redux/combine-reducers/","excerpt":"","text":"章节 5 - combine-reducers.js 我们现在来看一下什么是 reducer 12345678910111213var reducer_0 = function (state = &#123;&#125;, action) &#123; console.log('reducer_0 was called with state', state, 'and action', action) switch (action.type) &#123; case 'SAY_SOMETHING': return &#123; ...state, message: action.value &#125; default: return state; &#125;&#125; 在继续之前，我们先来想象一下拥有很多 action 的 reducer 长什么样子 12345678910111213141516171819202122var reducer_1 = function (state = &#123;&#125;, action) &#123; console.log('reducer_1 was called with state', state, 'and action', action) switch (action.type) &#123; case 'SAY_SOMETHING': return &#123; ...state, message: action.value &#125; case 'DO_SOMETHING': ... case 'LEARN_SOMETHING': ... case 'HEAR_SOMETHING': ... case 'GO_SOMEWHERE': ... etc. default: return state; &#125;&#125; 很显然，只有一个 reducer 是 hold 不住我们整个应用中所有 action 操作的（好吧，事实上它能 hold 得住， 但这会变得很难维护。） 幸运的是，Redux 不关心我们到底是只有一个 reducer ，还是有一打（12个）reducer 。 如果我们有多个 reducer ，Redux 能帮我们合并成一个。 让我们来定义 2 个 reducer 123456789101112131415161718var userReducer = function (state = &#123;&#125;, action) &#123; console.log('userReducer was called with state', state, 'and action', action) switch (action.type) &#123; etc. default: return state; &#125;&#125;var itemsReducer = function (state = [], action) &#123; console.log('itemsReducer was called with state', state, 'and action', action) switch (action.type) &#123; etc. default: return state; &#125;&#125; 我希望你特别留意赋给每个 reducer 的初始 state ： 1. 赋给 userReducer 的初始 state 是一个空对象，即 {} 2. 赋给 itemsReducer 的初始 state 是一个空数组，即 [] 赋予不同类型的值是为了说明 reducer 是可以处理任何类型的数据结构的。你完全可以选择那些符合你的需求的 数据结构作为 state 的值。（例如，字面量对象、数组、布尔值、字符串或其它不可变结构） 在这种多个 reducer 的模式下，我们可以让每个 reducer 只处理整个应用的部分 state 。 但我们需要知道，createStore 只接收一个 reducer 函数。 那么，我们怎么合并所有的 reducer？ 我们又该如何告诉 Redux 每个 reducer 只处理一部分 state 呢？ 其实这很简单。我们使用 combineReducers 辅助函数。 combineReducers 接收一个对象并返回一个函数，当 combineReducers 被调用时，它会去调用每个 reducer，并把返回的每一块 state 重新组合成一个大 state 对象（也就是 Redux 中的 Store）。 长话短说，下面演示一下如何使用多个 reducer 创建一个 Redux 实例： 123456789101112131415import &#123; createStore, combineReducers &#125; from 'redux'var reducer = combineReducers(&#123; user: userReducer, items: itemsReducer&#125;)// 输出： userReducer was called with state &#123;&#125; and action &#123; type: '@@redux/INIT' &#125; userReducer was called with state &#123;&#125; and action &#123; type: '@@redux/PROBE_UNKNOWN_ACTION_9.r.k.r.i.c.n.m.i' &#125; itemsReducer was called with state [] and action &#123; type: '@@redux/INIT' &#125; itemsReducer was called with state [] and action &#123; type: '@@redux/PROBE_UNKNOWN_ACTION_4.f.i.z.l.3.7.s.y.v.i' &#125;var store_0 = createStore(reducer)// 输出： userReducer was called with state &#123;&#125; and action &#123; type: '@@redux/INIT' &#125; itemsReducer was called with state [] and action &#123; type: '@@redux/INIT' &#125; 正如你从输出中看到的，每个 reducer 都被正确地调用了（但接收了个 init action @@redux/INIT ）。 这个 action 是什么鬼？这是 combineReducers 实施的一次安全检查，用以确保 reducer 永远不会返回 undefined。请注意，在 combineReducers 中第一次调用 init action 时，其实是随机 action 来的， 但它们有个共同的目的 (即是做一个安全检查)。 12345678910console.log('store_0 state after initialization:', store_0.getState()) 输出： store_0 state after initialization: &#123; user: &#123;&#125;, items: [] &#125; 有趣的是，我们发现 Redux 正确处理了 state 的各个部分。最终的 state 完全是一个简单的对象，由 userReducer 和 itemsReducer 返回的部分 state 共同组成。 &#123; user: &#123;&#125;, &#123;&#125; is the slice returned by our userReducer items: [] [] is the slice returned by our itemsReducer &#125; 由于我们为每个 reducer 初始化了一个特殊的值（userReducer 的是空对象 {} ，itemsReducer 的是空数 组 [] ）,所以在最终 Redux 的 state 中找到那些值并不是巧合。 现在，关于 reducer 如何工作我们已经有了清楚的理解。是时候去看看当 action 被分发（dispatch）时会对 Redux 的 state 有什么影响。 继续下一个教程: 06_dispatch-action.js","categories":[],"tags":[],"keywords":[]},{"title":"redux/get-state","slug":"redux/get-state","date":"2020-03-24T14:40:45.389Z","updated":"2020-03-24T14:49:10.918Z","comments":true,"path":"2020/03/24/redux/get-state/","link":"","permalink":"http://yoursite.com/2020/03/24/redux/get-state/","excerpt":"","text":"章节 4 - get-state.js如何从 Redux 实例中读取 state ？ 12345678import &#123; createStore &#125; from 'redux'var reducer_0 = function (state, action) &#123; console.log('reducer_0 was called with state', state, 'and action', action)&#125;var store_0 = createStore(reducer_0)// 输出: reducer_0 was called with state undefined and action &#123; type: '@@redux/INIT' &#125; 为了读取 Redux 保存的 state，你可以调用 getState 12console.log('store_0 state after initialization:', store_0.getState())// 输出: store_0 state after initialization: undefined 都已经初始化过了，难道程序的 state 还是 undefined 的？没错，正是如此， 到目前为止，我们的 reducer 还什么事都没做过…… 你是否还有印象，我们在 “about-state-and-meet-redux” 那一章里是怎么描述一个 reducer 的预期行为的？ “一个 reducer 只是一个函数，它能收到程序当前的 state 与 action， 然后返回一个 modify（又或者学别人一样称之为 reduce ）过的新 state ” 我们的 reducer 目前什么都不返回，所以程序的 state 当然只能是 reducer() 返回的那个叫 “undefined” 的东西。 接下来，我们试着在 reducer 收到 undefined 的 state 时，给程序发一个初始状态： 1234567891011121314var reducer_1 = function (state, action) &#123; console.log('reducer_1 was called with state', state, 'and action', action) if (typeof state === 'undefined') &#123; return &#123;&#125; &#125; return state;&#125;var store_1 = createStore(reducer_1)// 输出：reducer_1 was called with state undefined and action &#123; type: '@@redux/INIT' &#125;console.log('store_1 state after initialization:', store_1.getState())// 输出：store_1 state after initialization: &#123;&#125; 如我们所愿，现在 Redux 初始化以后返回的 state 变成 {} 了 感谢ES6，这个模式现在实现起来很清晰： 1234567891011var reducer_2 = function (state = &#123;&#125;, action) &#123; console.log('reducer_2 was called with state', state, 'and action', action) return state;&#125;var store_2 = createStore(reducer_2)// 输出: reducer_2 was called with state &#123;&#125; and action &#123; type: '@@redux/INIT' &#125;console.log('store_2 state after initialization:', store_2.getState())// 输出: store_2 state after initialization: &#123;&#125; 估计你已经发现了，我们给 reducer_2 的 state 参数传了默认值之后， reducer 就不会再取到 undefined 的 state 了。 小结一下：调用 reducer ，只是为了响应一个派发来的 action 。 接下来，我们在 response 里模拟一个 state 修改，其响应的 action 类型是 ‘SAY_SOMETIHG’ 12345678910111213141516171819var reducer_3 = function (state = &#123;&#125;, action) &#123; console.log('reducer_3 was called with state', state, 'and action', action) switch (action.type) &#123; case 'SAY_SOMETHING': return &#123; ...state, message: action.value &#125; default: return state; &#125;&#125;var store_3 = createStore(reducer_3)// 输出: reducer_3 was called with state &#123;&#125; and action &#123; type: '@@redux/INIT' &#125;console.log('store_3 state after initialization:', store_3.getState())// 输出: store_3 state after initialization: &#123;&#125; 到目前为止，我们都还没有得到一个新 state， 因为我们还没有真的派发过任何 action 。 不过在最后一个例子里，有几个点值得注意： 0) 我假设了 action 里一定包含了一个 type 跟一个 value 。type 基本上是 flux action 已经约定俗成的， 而 value 属性可以是任何类型的。 1) 这里有个常见模式：在 reducer 里用 switch 来响应对应的 action 。 2) 用 switch 的时候， **永远** 不要忘记放个 “default” 来返回 “state”，否则， 你的 reducer 可能会返回 “undefined” （等于你的 state 就丢了） 3) 注意 { message: action.value } 是怎么被合并到当前 state 来形成新 state 的， 这全要感谢牛逼的 ES7 notation (Object Spread): { ...state, message: action.value } 4) 还要注意：之所以这个例子能用ES7 Object Spread notation ，是因为它只对 state 里的 { message: action.value} 做了浅拷贝（也就是说， state 第一个层级的属性直接被 { message: action.value } 覆盖掉了 —— 与之相对，其实也有优雅的合并方式 ） 但是如果数据结构更复杂或者是嵌套的，那处理state更新的时候，很可能还需要考虑一些完全不同的做法： - 可以考虑： Immutable.js (https:facebook.github.io/immutable-js/) - 可以考虑： Object.assign (https:developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) - 可以考虑： 手工合并 - 又或者考虑用其它任何能满足需要且适合 state 结构的方法，Redux 对此是全无预设的方式的（要记得 Redux 只是个状态的容器）。 现在开始，我们要在 reducer 里处理 action 了，我们将会有多个 reducer 并会组合它们。 前往下一个章节: 05_combine-reducers.js","categories":[],"tags":[],"keywords":[]},{"title":"redux/simple-reducer","slug":"redux/simple-reducer","date":"2020-03-24T14:38:57.365Z","updated":"2020-03-24T14:49:10.915Z","comments":true,"path":"2020/03/24/redux/simple-reducer/","link":"","permalink":"http://yoursite.com/2020/03/24/redux/simple-reducer/","excerpt":"","text":"章节 3 - simple-reducer.js 现在，我们知道如何去创建一个 Redux 实例，并让它管理应用中的 state 下面讲一下这些 reducer 函数是如何转换 state 的。 Reducer 与 Store 区别： 你可能已经注意到，在简介章节中的 Flux 图表中，有 Store，但没有 Redux 中的 Reducer。那么，Store 与 Reducer 到底有哪些区别呢？ 实际的区别比你想象的简单：Store 可以保存你的 data，而 Reducer 不能。 因此在传统的 Flux 中，Store 本身可以保存 state，但在 Redux 中，每次调用 reducer 时，都会传入待更新的 state。这样的话，Redux 的 store 就变成了 “无状态的 store” 并且改了个名字叫 Reducer。 如上所述，在创建一个 Redux 实例前，需要给它一个 reducer 函数… 123import &#123; createStore &#125; from 'redux'var store_0 = createStore(() =&gt; &#123;&#125;) …所以每当一个 action 发生时，Redux 都能调用这个函数。 往 createStore 传 Reducer 的过程就是给 Redux 绑定 action 处理函数（也就是 Reducer）的过程。 action 处理函数在 01_simple-action-creator.js 章节中有讨论过。 在 Reducer 中打印一些 log 1234567var reducer = function (...args) &#123; console.log('Reducer was called with args', args)&#125;var store_1 = createStore(reducer)// 输出：Reducer was called with args [ undefined, &#123; type: '@@redux/INIT' &#125; ] 看出来了吗？我们的 reducer 被调用了，但我们并没有 dispatch 任何 action… 这是因为在初始化应用 state 的时候， Redux dispatch 了一个初始化的 action ({ type: &#39;@@redux/INIT&#39; }) 在被调用时，一个 reducer 会得到这些参数：(state, action) 在应用初始化时，state 还没被初始化，因此它的值是 “undefined”， 这是非常符合逻辑的 在处理 “init” action 之后，我们应用中的 state 又会是怎么样的呢？ 下一章节：04_get-state.js","categories":[],"tags":[],"keywords":[]},{"title":"redux/about-state-and-meet-redux","slug":"redux/about-state-and-meet-redux","date":"2020-03-24T14:37:26.500Z","updated":"2020-03-24T14:49:10.913Z","comments":true,"path":"2020/03/24/redux/about-state-and-meet-redux/","link":"","permalink":"http://yoursite.com/2020/03/24/redux/about-state-and-meet-redux/","excerpt":"","text":"章节 2 - about-state-and-meet-redux.js 在实际应用中，我们不仅需要 action 告诉我们发生了什么，还要告诉我们需要随之更新数据。 这就让我们的应用变的棘手： 如何在应用程序的整个生命周期内维持所有数据？ 如何修改这些数据？ 如何把数据变更传播到整个应用程序？ 于是 Redux 登场。 Redux (https:github.com/reactjs/redux) 是一个“可预测化状态的 JavaScript 容器”。 我们先回顾上述提出的问题并用 Redux 的词汇表给出以下解答（部分词汇也来源于 Flux）： 如何在应用程序的整个生命周期内维持所有数据？ 以你想要的方式维持这些数据，例如 JavaScript 对象、数组、不可变数据，等等。 我们把应用程序的数据称为状态。这是有道理的，因为我们所说的数据会随着时间的推移发生变化，这其实就是应用的状态。 但是我们把这些状态信息转交给了 Redux（还记得么？Redux 就是一个“容纳状态的容器”）。 如何修改这些数据？ 我们使用 reducer 函数修改数据（在传统的 Flux 中我们称之为 store）。 Reducer 函数是 action 的订阅者。 Reducer 函数只是一个纯函数，它接收应用程序的当前状态以及发生的 action，然后返回修改后的新状态（或者有人称之为归并后的状态）。 如何把数据变更传播到整个应用程序？ 使用订阅者来监听状态的变更情况。 Redux 帮你把这些连接起来。 总之 Redux 提供了： 1）存放应用程序状态的容器 2）一种把 action 分发到状态修改器的机制，也就是 reducer 函数 3）监听状态变化的机制 我们把 Redux 实例称为 store 并用以下方式创建： 12import &#123; createStore &#125; from 'redux'var store = createStore() 但是当你运行上述代码，你会发现以下异常消息： Error: Invariant Violation: Expected the reducer to be a function. 这是因为 createStore 函数必须接收一个能够修改应用状态的函数。 我们再试一下 123import &#123; createStore &#125; from 'redux'var store = createStore(() =&gt; &#123;&#125;) 看上去没有问题了… 继续下一个教程：03_simple-reducer.js","categories":[],"tags":[],"keywords":[]},{"title":"redux/simple-action-creator","slug":"redux/simple-action-creator","date":"2020-03-24T14:35:08.100Z","updated":"2020-03-24T14:49:10.917Z","comments":true,"path":"2020/03/24/redux/simple-action-creator/","link":"","permalink":"http://yoursite.com/2020/03/24/redux/simple-action-creator/","excerpt":"","text":"章节 1 - simple-action-creator.js 我们在前言中已经简单提到过 action，但具体什么是 action creator，它们又是如何关联到 action 的呢？ 其实，通过几行简单的代码就可以解释清楚了！ action creator 就是函数而已… 123456var actionCreator = function() &#123; // 负责构建一个 action （是的，action creator 这个名字已经很明显了）并返回它 return &#123; type: 'AN_ACTION' &#125;&#125; 这就完了？是的，仅此而已。 然而，有一件事情需要注意，那就是 action 的格式。flux 一般约定 action 是一个拥有 type 属性的对象。 然后按 type 决定如何处理 action。当然，action 依旧可以拥有其他属性，你可以任意存放想要的数据。 在后面的章节中，我们会发现 action creator 实际上可以返回 action 以外的其他东西，比如一个函数。 这在处理异步时很有用（更多的内容可以查阅 dispatch-async-action.js）。 我们可以直接调用 action creator，如同预期的一样，我们会得到一个 action： 12console.log(actionCreator()) // 输出： &#123; type: 'AN_ACTION' &#125; 好了，以上代码没有任何问题，却也毫无用处… 在实际的场景中，我们需要的是将 action 发送到某个地方，让关心它的人知道发生了什么，并且做出相应的处理。 我们将这个过程称之为“分发 action（Dispatching an action）”。 为了分发 action，我们需要…一个分发函数（=￣ω￣=）。 并且，为了让任何对它感兴趣的人都能感知到 action 发起，我们还需要一个注册“处理器（handlers）”的机制。 这些 action 的“处理器”在传统的 flux 应用中被称为 store，在下个章节中，我们会介绍它们在 Redux 中叫什么。 至止，我们的应用中包含了以下流程： ActionCreator -&gt; Action 可以在以下链接中了解更多关于 action 和 action creator 的内容： http:rackt.org/redux/docs/recipes/ReducingBoilerplate.html 下一章节： 02_about-state-and-meet-redux.js","categories":[],"tags":[],"keywords":[]},{"title":"webpack","slug":"webpack","date":"2020-02-25T14:18:25.412Z","updated":"2020-02-25T14:18:42.811Z","comments":true,"path":"2020/02/25/webpack/","link":"","permalink":"http://yoursite.com/2020/02/25/webpack/","excerpt":"","text":"1. webpack与grunt、gulp的不同？三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。 grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。 webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。 所以总结一下： 从构建思路来说gulp和grunt需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工对于知识背景来说gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路2. 与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？同样是基于入口的打包工具还有以下几个主流的： webpackrollupparcel从应用场景上来看： webpack适用于大型复杂的前端站点构建rollup适用于基础库的打包，如vue、reactparcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel3.有哪些常见的Loader？他们是解决什么问题的？file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去source-map-loader：加载额外的 Source Map 文件，以方便断点调试image-loader：加载并且压缩图片文件babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。eslint-loader：通过 ESLint 检查 JavaScript 代码4.有哪些常见的Plugin？他们是解决什么问题的？define-plugin：定义环境变量commons-chunk-plugin：提取公共代码uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码5.Loader和Plugin的不同？不同的作用 Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。不同的用法 Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。6.webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；确定入口：根据配置中的 entry 找出所有的入口文件；编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 7.是否写过Loader和Plugin？描述一下编写loader或plugin的思路？Loader像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。 编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。 相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 8.webpack的热更新是如何做到的？说明其原理？webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。原理：首先要知道server端和client端都做了处理工作 第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。9.如何利用webpack来优化前端性能？（提高性能和体验）用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现提取公共代码。10.如何提高webpack的构建速度？多入口情况下，使用CommonsChunkPlugin来提取公共代码通过externals配置来提取常用库利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。使用Happypack 实现多线程加速编译使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度使用Tree-shaking和Scope Hoisting来剔除多余代码11.怎么配置单页应用？怎么配置多页应用？单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述 多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是： 每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置12.npm打包时需要注意哪些？如何利用webpack来更好的构建？Npm是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者，但是有些情况你也会去选择上传自己开发的模块。 关于NPM模块上传的方法可以去官网上进行学习，这里只讲解如何利用webpack来构建。 NPM模块需要注意以下问题： 要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。Npm包大小应该是尽量小（有些仓库会限制包大小）发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。 基于以上需要注意的问题，我们可以对于webpack配置做以下扩展和优化： CommonJS模块化规范的解决方案： 设置output.libraryTarget=’commonjs2’使输出的代码符合CommonJS2 模块化规范，以供给其它模块导入使用输出ES5代码的解决方案：使用babel-loader把 ES6 代码转换成 ES5 的代码。再通过开启devtool: ‘source-map’输出SourceMap以发布调试。Npm包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改.babelrc文件，为其加入transform-runtime插件不能将依赖模块打包到NPM模块中的解决方案：使用externals配置项来告诉webpack哪些模块不需要打包。对于依赖的资源文件打包的解决方案：通过css-loader和extract-text-webpack-plugin来实现，配置如下： 13.如何在vue项目中实现按需加载？Vue UI组件库的按需加载 为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。 不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。 1234567891011 &quot;presets&quot;: [[&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]], &quot;plugins&quot;: [ [ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] ]&#125; 单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。 通过import()语句来控制加载时机，webpack内置了对于import()的解析，会将import()中引入的模块作为一个新的入口在生成一个chunk。 当代码执行到import()语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill https://zhuanlan.zhihu.com/p/44438844","categories":[],"tags":[],"keywords":[]},{"title":"javascript/Dom","slug":"javascript/Dom","date":"2020-02-24T11:09:02.158Z","updated":"2020-02-24T11:48:06.199Z","comments":true,"path":"2020/02/24/javascript/Dom/","link":"","permalink":"http://yoursite.com/2020/02/24/javascript/Dom/","excerpt":"","text":"可以直接修改节点的文本，方法有两种：","categories":[],"tags":[],"keywords":[]},{"title":"javascript/window","slug":"javascript/window","date":"2020-02-24T10:43:56.829Z","updated":"2020-02-26T18:21:49.418Z","comments":true,"path":"2020/02/24/javascript/window/","link":"","permalink":"http://yoursite.com/2020/02/24/javascript/window/","excerpt":"","text":"windowwindow对象不但充当全局作用域，而且表示浏览器窗口。window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。对应的，还有一个outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。 navigatornavigator对象表示浏览器的信息，最常用的属性包括： navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 请注意，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用if判断浏览器版本。但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算。screen screen对象表示屏幕的信息，常用的属性有： screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。 locationlocation对象表示当前页面的URL信息。例如，一个完整的URL：location.href获取。要获得URL各个部分的值，可以这么写： location.protocol; // ‘http’ location.host; // ‘www.example.com&#39; location.port; // ‘8080’ location.pathname; // ‘/path/index.html’ location.search; // ‘?a=1&amp;b=2’ location.hash; // ‘TOP’要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法非常方便。 documentdocument对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。document的title属性是从HTML文档中的xxx读取的，但是可以动态改变：document对象还有一个cookie属性，可以获取当前页面的Cookie。 Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)…，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持。 为了确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly。 historyhistory对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。任何情况，你都不应该使用history这个对象了。 cookie创建cookie:document.cookie=&quot;username=John Doe&quot;;读取cookie:document.cookie 将以字符串的方式返回所有的 cookie。修改cookie:修改 cookie 类似于创建 cookie，如下所示：document.cookie=&quot;username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;删除 Cookie: 删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可，如下所示，设置为 Thu, 01 Jan 1970 00:00:00 GMT:document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;;注意，当您删除时不必指定 cookie 的值","categories":[],"tags":[],"keywords":[]},{"title":"es6/async","slug":"es6/async","date":"2020-02-24T10:12:11.452Z","updated":"2020-02-24T10:15:36.486Z","comments":true,"path":"2020/02/24/es6/async/","link":"","permalink":"http://yoursite.com/2020/02/24/es6/async/","excerpt":"","text":"asyncasync function name([param[, param[, ... param]]]) { statements }name: 函数名称。param: 要传递给函数的参数的名称。statements: 函数体语句。 async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。 await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。 awaitawait 操作符用于等待一个 Promise 对象, 它只能在异步函数 async function 内部使用。[return_value] = await expression;: expression: 一个 Promise 对象或者任何要等待的值。返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。 正常情况下，await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数。await针对所跟不同表达式的处理方式： Promise 对象：await 会暂停执行，等待 Promise 对象 resolve，然后恢复 async 函数的执行并返回解析值。 非 Promise 对象：直接返回对应的值。","categories":[],"tags":[],"keywords":[]},{"title":"es6/geneator","slug":"es6/geneator","date":"2020-02-24T10:10:58.132Z","updated":"2020-02-24T10:11:04.894Z","comments":true,"path":"2020/02/24/es6/geneator/","link":"","permalink":"http://yoursite.com/2020/02/24/es6/geneator/","excerpt":"","text":"Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法 Generator 有两个区分于普通函数的部分： 一是在 function 后面，函数名之前有个 * ； 函数内部有 yield 表达式。其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。 执行机制调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。","categories":[],"tags":[],"keywords":[]},{"title":"es6/Promise","slug":"es6/Promise","date":"2020-02-23T17:38:24.211Z","updated":"2020-02-23T17:48:35.130Z","comments":true,"path":"2020/02/24/es6/Promise/","link":"","permalink":"http://yoursite.com/2020/02/24/es6/Promise/","excerpt":"","text":"概述是异步编程的一种解决方案。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 状态Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。状态的缺点无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。当处于 pending 状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成)。then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。then 方法的特点在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。通过 .then 形式添加的回调函数，不论什么时候，都会被调用。then 方法将返回一个 resolved 或 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。then 方法注意点简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise。注意总是返回或终止 Promise 链。","categories":[],"tags":[],"keywords":[]},{"title":"es6/class","slug":"es6/class","date":"2020-02-23T17:34:59.363Z","updated":"2020-02-23T17:35:10.369Z","comments":true,"path":"2020/02/24/es6/class/","link":"","permalink":"http://yoursite.com/2020/02/24/es6/class/","excerpt":"","text":"注意要点类定义不会被提升，这意味着，必须在访问前对类进行定义，否则就会报错。类中方法不需要 function 关键字。方法间不能加分号。属性prototype 仍旧存在，虽然可以直接自类中定义方法，但是其实方法还是定义在 prototype 上的。 覆盖方法 / 初始化时添加方法。class 本身的属性，即直接定义在类内部的属性（ Class.propname ），不需要实例化。 ES6 中规定，Class 内部只有静态方法，没有静态属性。公共属性实例属性：定义在实例对象（ this ）上的属性。name 属性：返回跟在 class 后的类名(存在时)。方法constructor 方法是类的默认方法，创建类的实例化对象时被调用。类的实例化new：class 的实例化必须通过 new 关键字。类的实例化对象共享原型对象decorator 是一个函数，用来修改类的行为，在代码编译时产生作用。类修饰第一个参数 target，指向类本身。多个参数——嵌套实现。实例属性：上面两个例子添加的是静态属性，若要添加实例属性，在类的 prototype 上操作即可。","categories":[],"tags":[],"keywords":[]},{"title":"es6/iterator","slug":"es6/iterator","date":"2020-02-23T17:19:32.645Z","updated":"2020-02-23T17:22:02.547Z","comments":true,"path":"2020/02/24/es6/iterator/","link":"","permalink":"http://yoursite.com/2020/02/24/es6/iterator/","excerpt":"","text":"Iterator 是 ES6 引入的一种新的遍历机制，迭代器有两个核心概念： 迭代器是一个统一的接口，它的作用是使各种数据结构可被便捷的访问，它是通过一个键为Symbol.iterator 的方法来实现。迭代器是用于遍历数据结构元素的指针（如数据库中的游标)。迭代的过程如下： 通过 Symbol.iterator 创建一个迭代器，指向当前数据结构的起始位置 随后通过 next 方法进行向下迭代指向下一个位置， next 方法会返回当前位置的对象，对象包含了 value 和 done 两个属性， value 是当前属性的值， done 用于判断是否遍历结束 当 done 为 true 时则遍历结束 我们将使用 for…of 循环（参见下文的 for…of 循环）对数据结构进行迭代。Array:数组 ( Array ) 和类型数组 ( TypedArray ) 他们是可迭代的。String:字符串是可迭代的，单他们遍历的是 Unicode 码，每个码可能包含一个到两个的 Javascript 字符。Map 主要是迭代它们的 entries ，每个 entry 都会被编码为 [key, value] 的项， entries 是以确定的形势进行迭代，其顺序是与添加的顺序相同。arguments 目前在 ES6 中使用越来越少，但也是可遍历的普通对象是由 object 创建的，不可迭。for…of 是 ES6 新引入的循环，用于替代 for..in 和 forEach() ，并且支持新的迭代协议。它可用于迭代常规的数据类型，如 Array 、 String 、 Map 和 Set 等等。of 操作数必须是可迭代，这意味着如果是普通对象则无法进行迭代。如果数据结构类似于数组的形式，则可以借助 Array.from() 方法进行转换迭代。let 、const 和 var 用于 for..of如果使用 let 和 const ，每次迭代将会创建一个新的存储空间，这可以保证作用域在迭代的内部。因为 var 会作用于全局，迭代将不会每次都创建一个新的存储空间。","categories":[],"tags":[],"keywords":[]},{"title":"es6/function","slug":"es6/function","date":"2020-02-23T17:04:35.490Z","updated":"2020-02-23T17:04:48.458Z","comments":true,"path":"2020/02/24/es6/function/","link":"","permalink":"http://yoursite.com/2020/02/24/es6/function/","excerpt":"","text":"注意点：使用函数默认参数时，不允许有同名参数。只有在未传递参数，或者参数为 undefined 时，才会使用默认参数，null 值被认为是有效的值传递。函数参数默认值存在暂时性死区，在函数参数默认值表达式中，还未初始化赋值的参数值无法作为其他参数的默认值。 不定参数用来表示不确定参数个数，形如，…变量名，由…加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。 箭头函数：当箭头函数函数体有多行语句，用 {} 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 {} , 结果会自动返回。当箭头函数要返回对象的时候，为了区分于代码块，要用 () 将对象包裹起来。注意点：没有 this、super、arguments 和 new.target 绑定。箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象。不可以作为构造函数，也就是不能使用 new 命令，否则会报错。适合使用的场景ES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，那么有了箭头函数，就不需要这样做了，直接使用 this 就行。所以，当我们需要维护一个 this 上下文的时候，就可以使用箭头函数。不适合使用的场景定义函数的方法，且该方法中包含 this。需要动态 this 的时候， 1234var button = document.getElementById('userClick');button.addEventListener('click', () =&gt; &#123; this.classList.toggle('on');&#125;); button 的监听函数是箭头函数，所以监听函数里面的 this 指向的是定义的时候外层的 this 对象，即 Window，导致无法操作到被点击的按钮对象。","categories":[],"tags":[],"keywords":[]},{"title":"es6/array","slug":"es6/array","date":"2020-02-22T17:32:32.840Z","updated":"2020-02-23T15:05:15.938Z","comments":true,"path":"2020/02/23/es6/array/","link":"","permalink":"http://yoursite.com/2020/02/23/es6/array/","excerpt":"","text":"数组创建：Array.of()：将参数中所有值作为元素形成数组。(1。参数值可为不同类型。 2.参数为空时返回空数组)Array.from()： 将类数组对象或可迭代对象转化为数组。(1.参数为数组,返回与原数组一样的数组。) Array.from(arrayLike[, mapFn[, thisArg]])arrayLike: 想要转换的类数组对象或可迭代对象。mapFn: 可选，map 函数，用于对每个元素进行处理，放入数组的是处理后的元素。thisArg: 可选，用于指定 map 函数执行时的 this 对象。 类数组对象一个类数组对象必须含有 length 属性，且元素属性名必须是数值或者可转换为数值的字符。(1.没有 length 属性,则返回空数组。2.元素属性名不为数值且无法转换为数值，返回长度为 length 元素值为 undefined 的数组。) 转换可迭代对象转换 map转换 set转换字符串 查找find(): 查找数组中符合条件的元素,若有多个符合条件的元素，则返回第一个元素。(数组空位处理为 undefined) 。findIndex()：查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。 填充fill(): 将一定范围索引的数组元素内容填充为单个指定的值。 用来填充的值. 被填充的起始索引。 (可选)：被填充的结束索引，默认为数组末尾。copyWithin()： 将一定范围索引的数组元素修改为此数组另一指定范围索引的元素。 被修改的起始索引。 被用来覆盖的数据的起始索引。 (可选)：被用来覆盖的数据的结束索引，默认为数组末尾。遍历entries()：遍历键值对。keys()：遍历键名。values()：遍历键值。包含includes()：数组包含指定值。(1.包含的指定值。2.可选，搜索的起始索引，默认为0。3.NaN 的包含判断。)注意：与 Set 和 Map 的 has 方法区分；Set 的 has 方法用于查找值；Map 的 has 方法用于查找键名。嵌套数组转一维数组flat()： 指定转换的嵌套层数。例如flat(2)。 2.不管嵌套多少层flat(Infinity)。3.自动跳过空位。flatMap()：先对数组中每个元素进行了的处理，再对数组执行 flat() 方法。 遍历函数，该遍历函数可接受3个参数：当前元素、当前元素索引、原数组。 指定遍历函数中 this 的指向。 复制数组 let arr2 = [1, , 3], arr3 = […arr2]; console.log(arr3); [1, undefined, 3]合并数组: […[1, 2],…[3, 4]]。","categories":[],"tags":[],"keywords":[]},{"title":"es6/object","slug":"es6/object","date":"2020-02-22T17:29:36.455Z","updated":"2020-02-22T17:29:46.084Z","comments":true,"path":"2020/02/23/es6/object/","link":"","permalink":"http://yoursite.com/2020/02/23/es6/object/","excerpt":"","text":"对象的拓展运算符拓展运算符（…）用于取出参数对象所有可遍历属性然后拷贝到当前对象。注意点（自定义的属性和拓展运算符对象里面属性的相同的时候：自定义的属性在拓展运算符后面，则拓展运算符对象内部同名的属性将被覆盖掉。） 对象的新方法Object.assign(target, source_1, ···): 用于将源对象的所有可枚举属性复制到目标对象中。 如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。 如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。 因为 null 和 undefined 不能转化为对象，所以会报错 注意点assign 的属性拷贝是浅拷贝。Object.is(value1, value2):用来比较两个值是否严格相等，与（===）基本类似。","categories":[],"tags":[],"keywords":[]},{"title":"es6/math","slug":"es6/math","date":"2020-02-22T17:11:14.331Z","updated":"2020-02-22T17:12:43.597Z","comments":true,"path":"2020/02/23/es6/math/","link":"","permalink":"http://yoursite.com/2020/02/23/es6/math/","excerpt":"","text":"1. 如何判断一个值是否为NaN？运行环境内建的方法isNaN()有坑第一种，根据上面的实验，我们可以先判断输入参数的类型是否为number，再调用isNaN方法，这样就避免了对于非数字类型的判断错误。代码如下： 12345678910if(!Number.isNaN)&#123; Number.isNaN = function(n)&#123; return ( typeof n === 'number' &amp;&amp; window.isNaN(n) ) &#125;&#125;Number.isNaN(5*'abc'); //trueNumber.isNaN('what?'); //false 第二种，利用NaN的一个特性，它是JS语言中唯一一个不等于他本身的值，所以我们也可以这么写。 12345678if(!Number.isNaN)&#123; Number.isNaN = function(n)&#123; return n !== n; &#125;&#125;Number.isNaN(5*'abc'); //trueNumber.isNaN('what?'); //false 还有一种，可以利用ES6中提供的Object.is()方法来进行验证 12Object.is(5*'abc', NaN); //trueObject.is('what?', NaN); //false 2. 如何判断两个浮点数相等？如fn(0.1+0.2 , 0.3) =&gt; { /返回true/}Number.EPSILON 属性表示 1 与大于 1 的最小浮点数之间的差。es6之前的版本： 123if(!Number.EPSILON)&#123; Number.EPSILON = Math.pow(2, -52);&#125; 也可以使用Number.EPSILON来比较连个值是否相等（在指定的误差范围内）： 1Math.abs(0.1 - 0.3 + 0.2) &lt; Number.EPSILON 3. 如何检测一个值是否整数？要检测一个值是否为整数，可以使用Es6的Number.isInterge(…)方法 123Number.isInterger(1.000); //trueNumber.isInterger(1); //trueNumber.isInterger('1'); //false 如果不允许使用ES6的话，可以自行写一个pollyFill方法。 12345if(!Number.isInterger)&#123; Number.isInterger &#x3D; function(num)&#123; return (typeof num &#x3D;&#x3D;&#x3D; &#39;number&#39;) &amp;&amp; num%1 &#x3D;&#x3D;&#x3D; 0; &#125;&#125; 4. 对于一个数字进行取整，你能说出多少种方法？8.84|0; //8~~8.84; //88.84&gt;&gt;0; //8这三种方法都是可以的，分别说一下： 8.84|0或者 写成0 | 8.84 都是一样的，从语法上看，他是让0与指定值进行按位“或”运算，在JavaScript中，它先对指定值执行了ToInt32的转换，在按位进行或运算，所以最终结果就是把指定值转换为32位的整数。 而~~8.84也是对变量进行ToInt32的转换；再进行一步按位“取非”运算，即对每个字节进行反转；然后，再对结果再次“取非”。 那么8.84&gt;&gt;0的操作就同理可证了…… 但是，上面的三种方法也是有其局限性的，因为他们是遵循ToInt32的转化规范，所以他们也只能对于32位的数字进行转换，所以再加上一个符号位，那么他们所能处理的数字范围在2的正负31次幂之间，即-2147483648 ≤ x ≤ 2147483647。5. 当一个变量显式类型转换时（利用Number()方法），遵循的规则是什么？ES5规范中规定了这个抽象操作ToNumber。 对于布尔型：true的结果为1，false的结果为0； 对于undefined： 结果为NaN 对于null：结果为0 对于字符串类型：遵循数字常量的相关规则和语法。处理失败时会返回NaN。 对于复杂类型：会先调用该值得valueOf()方法，如果有并且返回基本类型之，就是用该值进行强制类型转换。如果没有就是使用toString()的返回来进行强制类型转换。 123456789101112131415var test1 = &#123; valueOf: function()&#123; return 10; //valueOf方法的将被调用； &#125;, toString: function()&#123; return 666; &#125;&#125;Number(test1) ; //102*test1; //20Number(test2); //666Number(test2)/2; //3336. Number([])和Number([1,2,3])的值分别是什么？说明其原理？先调用valueOf()，再调用toString()方法，那么空数组和[1,2,3]有什么区别呢？ 因为数字的valueOf()方法返回的是数组本身，不是一个基本类型，所以还会调用toString()方法；而数组的toString()方法返回的是数组各项通过逗号拼接一起的字符串（可以理解调用了Array.prototype.join(“,”)方法），所以空数组返回空字符串，转换为数组自然就是0；而数组[1,2,3]则只能转换为NaN了. 那么，大家觉得下面的代码应该输出什么呢？为什么？Number([100]); //???7. 讲一讲parseInt()方法遵循的运算规则？parseInt(&#39;52px&#39;); //52parseInt(string, radix);方法的接受两个参数： string：要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。 radix：一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。比如参数”10”表示使用我们通常使用的十进制数值系统。始终指定此参数可以消除阅读该代码时的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常将值默认为10。 返回值： 返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。 如果 parseInt 遇到了不属于radix参数所指定的基数中的字符那么该字符和其后的字符都将被忽略。接着返回已经解析的整数部分。 所以，这里就明白为什么字符串’52px’会被parseInt()解析为52，因为没有传递第二个参数radix，所以默认按照10进制进行解析，而字符’p’不在10进制内，所以字符’p’和后面的字符全部被忽略，直接返回数字52. 如果不亲自一试，你绝不会相信上面代码的输出是18。parseInt(1/0, 19); //18这里需要知道的是，1/0运算结果是“无穷”，在JavaScript中为Infinity，而这个Infinity转换为字符串则为’Infinity’，第一个字符是’I’，在以19为基数时他的值为18。第二个字符‘n’不是一个有效的数字字符，所以除第一个字符外，后面的字符全部被忽略，所以最后就返回了18。","categories":[],"tags":[],"keywords":[]},{"title":"es6/string","slug":"es6/string","date":"2020-02-22T13:27:35.548Z","updated":"2020-02-22T13:27:44.411Z","comments":true,"path":"2020/02/22/es6/string/","link":"","permalink":"http://yoursite.com/2020/02/22/es6/string/","excerpt":"","text":"ES6 之前判断字符串是否包含子串，用 indexOf 方法，ES6 新增了子串的识别方法。 includes()：返回布尔值，判断是否找到参数字符串。 startsWith()：返回布尔值，判断参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，判断参数字符串是否在原字符串的尾部。以上三个方法都可以接受两个参数，需要搜索的字符串，和可选的搜索起始位置索引。let string = &quot;apple,banana,orange&quot;;string.includes(&quot;banana&quot;); 注意点： 这三个方法只返回布尔值，如果需要知道子串的位置，还是得用 indexOf 和 lastIndexOf 。 这三个方法如果传入了正则表达式而不是字符串，会抛出错误。而 indexOf 和 lastIndexOf 这两个方法，它们会将正则表达式转换为字符串并搜索它。 repeat()：返回新的字符串，表示将字符串重复指定次数返回。 如果参数是小数，向下取整 如果参数是 0 至 -1 之间的小数，会进行取整运算，0 至 -1 之间的小数取整得到 -0 ，等同于 repeat 零次 如果参数是 NaN，等同于 repeat 零次 如果参数是负数或者 Infinity ，会报错 字符串补全： padStart：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。 padEnd：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。 以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。","categories":[],"tags":[],"keywords":[]},{"title":"es6/map_set","slug":"es6/map_set","date":"2020-02-22T08:11:17.099Z","updated":"2020-02-22T12:55:56.577Z","comments":true,"path":"2020/02/22/es6/map_set/","link":"","permalink":"http://yoursite.com/2020/02/22/es6/map_set/","excerpt":"","text":"Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。Maps 和 Objects 的区别 一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。 Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。 Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。 Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。 Map 中的 keykey 是字符串key 是对象key 是函数key 是 NaN(虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的) Map 的迭代for…offorEach() Map 对象的操作Map 与 Array的转换 Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组 Map 的克隆:(Map 对象构造函数生成实例，迭代出新的对象。) Map 的合并:(合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的) Set 对象Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 Set 中的特殊值 Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待： +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复； undefined 与 undefined 是恒等的，所以不重复； NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。 类型转换 Array Array 转 Set 用…操作符，将Set转Array String转set(set中toString方法不能讲Set转换成String)Set 对象作用 数组去重(先new Set(),再讲Set转换为Array)并集(new Set([...a, ...b]);)交集(new Set([...a].filter(x =&gt; b.has(x))))差集(new Set([...a].filter(x =&gt; !b.has(x))))","categories":[],"tags":[],"keywords":[]},{"title":"es6/symbol","slug":"es6/symbol","date":"2020-02-21T18:18:06.760Z","updated":"2020-02-21T19:34:43.788Z","comments":true,"path":"2020/02/22/es6/symbol/","link":"","permalink":"http://yoursite.com/2020/02/22/es6/symbol/","excerpt":"","text":"ES6 Symbol 概述： 原始数据类型 Symbol，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。 ES6 数据类型除了 Number 、 String 、 Boolean 、 Objec t、 null 和 undefined ，还新增了 Symbol 。 基本用法 Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分。 使用场景 用法: 由于每一个 Symbol 的值都是不相等的，所以 Symbol 作为对象的属性名，可以保证属性不重名。 123456789101112131415let sy = Symbol(\"key1\");// 写法一let syObject = &#123;&#125;;syObject[sy] = \"kk\";console.log(syObject); // &#123;Symbol(key1): \"kk\"&#125;let syObject = &#123; [sy]: \"kk\"&#125;;console.log(syObject); // &#123;Symbol(key1): \"kk\"&#125;// 写法3let syObject = &#123;&#125;;Object.defineProperty(syObject, sy, &#123;value: \"kk\"&#125;);console.log(syObject); // &#123;Symbol(key1): \"kk\"&#125; Symbol 作为对象属性名时不能用.运算符，要用方括号。因为.运算符后面是字符串，所以取到的是字符串 sy 属性，而不是 Symbol 值 sy 属性。 注意点:Symbol 值作为属性名时，该属性是公有属性不是私有属性，可以在类的外部访问。但是不会出现在 for…in 、 for…of 的循环中，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 返回。如果要读取到一个对象的 Symbol 属性，可以通过 Object.getOwnPropertySymbols() 和 Reflect.ownKeys() 取到。 定义常量 但是使用 Symbol 定义常量，这样就可以保证这一组常量的值都不相等。用 Symbol 来修改上面的例子。 Symbol.for()Symbol.for() 类似单例模式，首先会在全局搜索被登记的 Symbol 中是否有该字符串参数作为名称的 Symbol 值，如果有即返回该 Symbol 值，若没有则新建并返回一个以该字符串参数为名称的 Symbol 值，并登记在全局环境中供搜索。 Symbol.keyFor()Symbol.keyFor() 返回一个已登记的 Symbol 类型值的 key ，用来检测该字符串参数作为名称的 Symbol 值是否已被登记。","categories":[],"tags":[],"keywords":[]},{"title":"es6/rest","slug":"es6/rest","date":"2020-02-21T18:15:55.039Z","updated":"2020-02-21T18:17:32.842Z","comments":true,"path":"2020/02/22/es6/rest/","link":"","permalink":"http://yoursite.com/2020/02/22/es6/rest/","excerpt":"","text":"解构赋值概述： 解构赋值是对赋值运算符的扩展。 他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。 在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。 数组模型的解构 基本：`let [a, b, c] = [1, 2, 3];` 可嵌套：`let [a, [[b], c]] = [1, [[2], 3]];` 可忽略： `let [a, , b] = [1, 2, 3];` 不完全解构: `let [a = 1, b] = [];` 剩余运算符: `let [a, ...b] = [1, 2, 3];` 字符串等: 在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。`let [a, b, c, d, e] = &apos;hello&apos;;` 解构默认值: 当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。对象模型的解构（Object） 基本： let { foo, bar } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; }; let { baz : foo } = { baz : &#39;ddd&#39; }; 可嵌套可忽略： 1234567let obj = &#123;p: ['hello', &#123;y: 'world'&#125;] &#125;;let &#123;p: [x, &#123; y &#125;] &#125; = obj;// x = 'hello'// y = 'world'let obj = &#123;p: ['hello', &#123;y: 'world'&#125;] &#125;;let &#123;p: [x, &#123; &#125;] &#125; = obj;// x = 'hello' 不完全解构： 剩余运算符：`let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40};` 解构默认值: 12345let &#123;a = 10, b = 5&#125; = &#123;a: 3&#125;; // a = 3; b = 5;let &#123;a: aa = 10, b: bb = 5&#125; = &#123;a: 3&#125;;// aa = 3; bb = 5;","categories":[],"tags":[],"keywords":[]},{"title":"es6/let_const","slug":"es6/let_const","date":"2020-02-21T10:28:23.930Z","updated":"2020-02-21T10:31:29.840Z","comments":true,"path":"2020/02/21/es6/let_const/","link":"","permalink":"http://yoursite.com/2020/02/21/es6/let_const/","excerpt":"","text":"let 和 const: let生命的变量只在let命令所在的代码块内有效。 const 声明一个只读变量，一旦声明，常量的值就不能改变。let 命令： 1.代码块内有效 2.不能重复声明(for循环很适用let)： 变量 i 是用 var 声明的，在全局范围内有效，所以全局中只有一个变量 i, 每次循环时，setTimeout 定时器里面的 i 指的是全局变量 i ，而循环里的十个 setTimeout 是在循环结束后才执行，所以此时的 i 都是 10。 变量 j 是用 let 声明的，当前的 j 只在本轮循环中有效，每次循环的 j 其实都是一个新的变量，所以 setTimeout 定时器里面的 j 其实是不同的变量，即最后输出 12345。（若每次循环的变量 j 都是重新声明的，如何知道前一个循环的值？这是因为 JavaScript 引擎内部会记住前一个循环的值）3.不存在变量提升 (变量 b 用 var 声明存在变量提升，所以当脚本开始运行的时候，b 已经存在了，但是还没有赋值，所以会输出 undefined。变量 a 用 let 声明不存在变量提升，在声明变量 a 之前，a 不存在，所以会报错。) const 命令: const 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。 暂时性死区:ES6 明确规定，代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。代码块内，在声明变量 PI 之前使用它会报错。*注意要点: * const 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。此时，你可能已经想到，简单类型和复合类型保存值的方式是不同的。是的，对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 const 声明复杂类型对象时要慎重。","categories":[],"tags":[],"keywords":[]},{"title":"npm/npm公开包","slug":"npm/npm公开包","date":"2020-02-06T09:22:50.920Z","updated":"2020-02-06T10:51:55.913Z","comments":true,"path":"2020/02/06/npm/npm公开包/","link":"","permalink":"http://yoursite.com/2020/02/06/npm/npm%E5%85%AC%E5%BC%80%E5%8C%85/","excerpt":"","text":"403 Forbidden - PUT https://registry.npm.taobao.org/myproject - [no_perms] Private mode enable, only admin can publish this module 提示镜像源错误： npm config set registry http://www.npmjs.org https://juejin.im/post/5c5012926fb9a049d37f81e1 创建项目mkdir my-test-project git init git remote add origin git@github.com:usename//my-test-project.git git push -u origin master 4.在项目根目录下即my-test-project目录下执行，npm init 发布npm adduser // or npm login Username: npm-user-name Password: Email: your-email 执行npm publish 关于测试更新已发布的包修改版本号 npm publish 撤销发布npm unpublish","categories":[],"tags":[],"keywords":[]},{"title":"npm/npm_link","slug":"npm/npm_link","date":"2020-02-06T08:07:40.294Z","updated":"2020-02-06T08:18:58.445Z","comments":true,"path":"2020/02/06/npm/npm_link/","link":"","permalink":"http://yoursite.com/2020/02/06/npm/npm_link/","excerpt":"","text":"https://blog.csdn.net/u014291497/article/details/75194456 如果我们想自己开发一个依赖包，在多个项目中使用它，如果直接发布到官网上固然可以，但如果修改则会非常麻烦，而且不利于在多个项目中使用。 npm link命令可以帮助我们实现这个事情 npm link 命令，这个命令的作用就是在全局环境下，生成一个符号链接文件，该文件的名字就是package.json文件中指定的模块名。同时我们对此模块的修改会实时反馈在全局目录下。 将自定义的模块与此项目连接起来。执行npm link allenModule95。 如此，我们可以在任何目录下使用该模块，并且一处修改，处处改变，节省了同步依赖包的步骤。 如果想解除项目与模块的依赖则可以在项目目录下执行npm unlink allenModule95即可。 如果想要从全局环境移除allenModule95模块链接，则可以在该模块目录下执行npm unlink allenModule95即可。","categories":[],"tags":[],"keywords":[]},{"title":"seesion/ReadME","slug":"seesion/ReadME","date":"2020-02-05T12:28:34.955Z","updated":"2020-02-05T14:02:54.484Z","comments":true,"path":"2020/02/05/seesion/ReadME/","link":"","permalink":"http://yoursite.com/2020/02/05/seesion/ReadME/","excerpt":"","text":"一、单系统登录机制 http无状态协议 web应用采用browser/server架构，http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联。这个过程用下图说明，三次请求/响应对之间没有任何联系： 但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求：要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。 会话机制， 浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联 服务器在内存中保存会话对象，浏览器怎么保存会话id呢？你可能会想到两种方式 1.请求参数 2.cookie 讲会话id作为每一个请求的参数，服务器接收请求自然能解析参数获得会话id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话id吧，每次发送http请求自动发送会话id,cookie机制正好来做这件事。cookie是浏览器用来存储少量数据的一种机制，数据以”key/value”形式存储，浏览器发送http请求时自动附带cookie信息。 tomcat会话机制当然也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为“JSESSIONID”的cookie，这就是tomcat会话机制维护的会话id,使用了cookie的请求响应过程如下图： 登录状态 有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下： 12HttpSession session = request.getSession();session.setAttribute(\"isLogin\", true); 用户再次访问时，tomcat在会话对象中查看登录状态 12HttpSession session = request.getSession();session.getAttribute(\"isLogin\"); 实现了登录状态的浏览器请求服务器模型如下图描述： 每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。 二、 多系统的复杂性web系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样 web系统有单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。 虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？ 单系统登录解决方案是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie。 既然这样，为什么不将cookie应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。 然而，可行并不代表好。共享cookie的方式存在很多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法跨语言技术水平登陆的，比如java、php、.net系统之间；第三，cookie本身不安全。 因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录 三、单点登录什么是单点登录？单点登录全称Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分 登录 相比于当系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名和密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，既得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明： 下面对上图简要描述 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数 sso认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌 sso认证中心带着令牌跳转会最初的请求地址（系统1） 系统1拿到令牌，去sso认证中心校验令牌是否有效 sso认证中心校验令牌，返回有效，注册系统1 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源 用户访问系统2的受保护资源 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数 sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌 系统2拿到令牌，去sso认证中心校验令牌是否有效 sso认证中心校验令牌，返回有效，注册系统2 系统2使用该令牌创建与用户的局部会话，返回受保护资源 用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系 局部会话存在，全局会话一定存在全局会话存在，局部会话不一定存在全局会话销毁，局部会话必须销毁 你可以通过博客园、百度、csdn、淘宝等网站的登录过程加深对单点登录的理解，注意观察登录过程中的跳转url与参数 注销 单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明： sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作， 下面对上图简要说明 用户向系统1发起注销请求 系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求 sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址 sso认证中心向所有注册系统发起注销请求 各注册系统接收sso认证中心的注销请求，销毁局部会话 sso认证中心引导用户至登录页面 四、部署图单点登录涉及sso认证中心与众子系统，子系统与sso认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成sso的客户端，sso认证中心则是sso服务端，整个单点登录过程实质是sso客户端与服务端通信的过程，用下图描述 sso认证中心与sso客户端通信方式有多种，这里以简单好用的httpClient为例，web service、rpc、restful api都可以 https://www.cnblogs.com/ywlaker/p/6113927.html","categories":[],"tags":[],"keywords":[]},{"title":"gitError","slug":"gitError","date":"2020-01-26T14:06:31.001Z","updated":"2020-02-06T10:53:56.744Z","comments":true,"path":"2020/01/26/gitError/","link":"","permalink":"http://yoursite.com/2020/01/26/gitError/","excerpt":"","text":"error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54 解决方法： 查看镜像 nrm ls npm install -g cnpm --registry=https://registry.npm.taobao.org","categories":[],"tags":[],"keywords":[]},{"title":"docker/mysqlError","slug":"docker/mysqlError","date":"2020-01-21T06:03:45.848Z","updated":"2020-01-21T06:06:31.293Z","comments":true,"path":"2020/01/21/docker/mysqlError/","link":"","permalink":"http://yoursite.com/2020/01/21/docker/mysqlError/","excerpt":"","text":"Client does not support authentication protocol requested by server; consider upgrading MySQL client 解决方法： mysql -u root -p ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;Ll123456&#39; flush privileges; 相关连接：https://medium.com/@nickhuang_1199/client-does-not-support-authentication-protocol-requested-by-server-consider-upgrading-mysql-98540705553f","categories":[],"tags":[],"keywords":[]},{"title":"NodeJS/MySQL","slug":"NodeJS/MySQL","date":"2020-01-20T12:39:09.144Z","updated":"2020-01-20T14:04:54.149Z","comments":true,"path":"2020/01/20/NodeJS/MySQL/","link":"","permalink":"http://yoursite.com/2020/01/20/NodeJS/MySQL/","excerpt":"","text":"安装MySQL驱动程序npm install mysql 建立连接123456789101112var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\");&#125;); 查询数据库12345678con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"Result: \" + result); &#125;);&#125;); 创建数据库要在MySQL中创建数据库，请使用CREATE DATABASE语句： 创建一个名为“ mydb”的数据库： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); con.query(\"CREATE DATABASE mydb\", function (err, result) &#123; if (err) throw err; console.log(\"Database created\"); &#125;);&#125;); 创建表格要在MySQL中创建表，请使用CREATE TABLE语句。确保在创建连接时定义数据库的名称。 创建一个名为“ customers”的表： 123456789101112131415161718var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); var sql = \"CREATE TABLE customers (name VARCHAR(255), address VARCHAR(255))\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"Table created\"); &#125;);&#125;); primary key创建表时，还应为每个记录创建一个具有唯一键的列。 这可以通过将列定义为INT AUTO_INCREMENT PRIMARY KEY来完成，该列将为每个记录插入一个唯一编号。从1开始，每条记录增加1。 创建表时创建主键： 123456789101112131415161718var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); var sql = \"CREATE TABLE customers (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), address VARCHAR(255))\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"Table created\"); &#125;);&#125;); 如果该表已经存在，请使用ALTER TABLE关键字： 在现有表上创建主键： 123456789101112131415161718var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); var sql = \"ALTER TABLE customers ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"Table altered\"); &#125;);&#125;); 插入表格在“customers”表中插入一条记录： 123456789101112131415161718var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); var sql = \"INSERT INTO customers (name, address) VALUES ('Company Inc', 'Highway 37')\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"1 record inserted\"); &#125;);&#125;); 插入多条记录要插入多个记录，请创建一个包含值的数组，然后在sql中插入问号，该问号将被值数组替换：INSERT INTO customers (name, address) VALUES ? 用数据填充“客户”表： 12345678910111213141516171819202122232425262728293031323334var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); var sql = \"INSERT INTO customers (name, address) VALUES ?\"; var values = [ ['John', 'Highway 71'], ['Peter', 'Lowstreet 4'], ['Amy', 'Apple st 652'], ['Hannah', 'Mountain 21'], ['Michael', 'Valley 345'], ['Sandy', 'Ocean blvd 2'], ['Betty', 'Green Grass 1'], ['Richard', 'Sky st 331'], ['Susan', 'One way 98'], ['Vicky', 'Yellow Garden 2'], ['Ben', 'Park Lane 38'], ['William', 'Central st 954'], ['Chuck', 'Main Road 989'], ['Viola', 'Sideway 1633'] ]; con.query(sql, [values], function (err, result) &#123; if (err) throw err; console.log(\"Number of records inserted: \" + result.affectedRows); &#125;);&#125;); 结果对象执行查询时，将返回结果对象。 结果对象包含有关查询如何影响表的信息。 从上面的示例返回的结果对象如下所示： 12345678910&#123; fieldCount: 0, affectedRows: 14, insertId: 0, serverStatus: 2, warningCount: 0, message: '\\'Records:14 Duplicated: 0 Warnings: 0', protocol41: true, changedRows: 0&#125; 属性值可以这样显示 返回受影响的行数: 1console.log(result.affectedRows) 获取插入的ID对于具有自动递增ID字段的表，可以通过询问结果对象来获取刚插入的行的ID。 注意：为了能够获得插入的ID，只能插入一行。 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"INSERT INTO customers (name, address) VALUES ('Michelle', 'Blue Village 1')\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"1 record inserted, ID: \" + result.insertId); &#125;);&#125;); 查询表（select from table）1.要从MySQL中的表中选择数据，请使用“ SELECT”语句。 从“customers”表中选择所有记录，并显示结果对象： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT * FROM customers\", function (err, result, fields) &#123; if (err) throw err; console.log(result); &#125;);&#125;); SELECT 将返回所有列 2.要仅选择表中的某些列，请使用“ SELECT”语句，后跟列名 从“customers”表中选择名称和地址，并显示返回对象： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT name, address FROM customers\", function (err, result, fields) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 结果 12345678910111213141516[ &#123; name: 'John', address: 'Highway 71'&#125;, &#123; name: 'Peter', address: 'Lowstreet 4'&#125;, &#123; name: 'Amy', address: 'Apple st 652'&#125;, &#123; name: 'Hannah', address: 'Mountain 21'&#125;, &#123; name: 'Michael', address: 'Valley 345'&#125;, &#123; name: 'Sandy', address: 'Ocean blvd 2'&#125;, &#123; name: 'Betty', address: 'Green Grass 1'&#125;, &#123; name: 'Richard', address: 'Sky st 331'&#125;, &#123; name: 'Susan', address: 'One way 98'&#125;, &#123; name: 'Vicky', address: 'Yellow Garden 2'&#125;, &#123; name: 'Ben', address: 'Park Lane 38'&#125;, &#123; name: 'William', address: 'Central st 954'&#125;, &#123; name: 'Chuck', address: 'Main Road 989'&#125;, &#123; name: 'Viola', address: 'Sideway 1633'&#125;] 结果对象从上面示例的结果中可以看到，结果对象是一个包含每一行作为对象的数组。 要返回例如第三条记录的地址，只需参考第三条数组对象的address属性： 返回第三条记录的地址： 1console.log(result[2].address); 字段对象回调函数的第三个参数是一个数组，其中包含有关结果中每个字段的信息。 从“customers”表中选择所有记录，然后显示字段对象： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT name, address FROM customers\", function (err, result, fields) &#123; if (err) throw err; console.log(fields); &#125;);&#125;); 结果 12345678910111213141516171819202122232425262728293031323334[ &#123; catalog: 'def', db: 'mydb', table: 'customers', orgTable: 'customers', name: 'name', orgName: 'address', charsetNr: 33, length: 765, type: 253, flags: 0, decimals: 0, default: undefined, zeroFill: false, protocol41: true &#125;, &#123; catalog: 'def', db: 'mydb', table: 'customers', orgTable: 'customers', name: 'address', orgName: 'address', charsetNr: 33, length: 765, type: 253, flags: 0, decimals: 0, default: undefined, zeroFill: false, protocol41: true &#123;] where选择带过滤器从表中选择记录时，可以使用“ WHERE”语句过滤选择： 选择地址为“ Park Lane 38”的记录： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT * FROM customers WHERE address = 'Park Lane 38'\", function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 通配符您也可以选择以给定字母或短语开头，包含或结尾的记录。 使用’％’通配符表示零个，一个或多个字符： 选择地址以字母“ S”开头的记录： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT * FROM customers WHERE address LIKE 'S%'\", function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 转义查询值当查询值是用户提供的变量时，应转义这些值。 这是为了防止SQL注入，这是破坏或滥用数据库的常见Web黑客技术。 MySQL模块具有以下方法来转义查询值： 使用以下mysql.escape() 方法转义查询值： 123456var adr = 'Mountain 21';var sql = 'SELECT * FROM customers WHERE address = ' + mysql.escape(adr);con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result);&#125;); 通过使用占位符? 方法转义查询值： 123456var adr = 'Mountain 21';var sql = 'SELECT * FROM customers WHERE address = ?';con.query(sql, [adr], function (err, result) &#123; if (err) throw err; console.log(result);&#125;); 如果您有多个占位符，则数组按该顺序包含多个值： 1234567var name = 'Amy';var adr = 'Mountain 21';var sql = 'SELECT * FROM customers WHERE name = ? OR address = ?';con.query(sql, [name, adr], function (err, result) &#123; if (err) throw err; console.log(result);&#125;); sort result使用ORDER BY语句对结果进行升序或降序排序。 缺省情况下，ORDER BY关键字对结果进行升序排序。要按降序对结果进行排序，请使用DESC关键字。 按名称的字母顺序对结果进行排序： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT * FROM customers ORDER BY name\", function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 结果 12345678910111213141516[ &#123; id: 3, name: 'Amy', address: 'Apple st 652'&#125;, &#123; id: 11, name: 'Ben', address: 'Park Lane 38'&#125;, &#123; id: 7, name: 'Betty', address: 'Green Grass 1'&#125;, &#123; id: 13, name: 'Chuck', address: 'Main Road 989'&#125;, &#123; id: 4, name: 'Hannah', address: 'Mountain 21'&#125;, &#123; id: 1, name: 'John', address: 'Higheay 71'&#125;, &#123; id: 5, name: 'Michael', address: 'Valley 345'&#125;, &#123; id: 2, name: 'Peter', address: 'Lowstreet 4'&#125;, &#123; id: 8, name: 'Richard', address: 'Sky st 331'&#125;, &#123; id: 6, name: 'Sandy', address: 'Ocean blvd 2'&#125;, &#123; id: 9, name: 'Susan', address: 'One way 98'&#125;, &#123; id: 10, name: 'Vicky', address: 'Yellow Garden 2'&#125;, &#123; id: 14, name: 'Viola', address: 'Sideway 1633'&#125;, &#123; id: 12, name: 'William', address: 'Central st 954'&#125;] 按订单排序使用DESC关键字以降序对结果进行排序。 按name的字母顺序对结果进行反向排序： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT * FROM customers ORDER BY name DESC\", function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 结果 12345678910111213141516[ &#123; id: 12, name: 'William', address: 'Central st 954'&#125;, &#123; id: 14, name: 'Viola', address: 'Sideway 1633'&#125;, &#123; id: 10, name: 'Vicky', address: 'Yellow Garden 2'&#125;, &#123; id: 9, name: 'Susan', address: 'One way 98'&#125;, &#123; id: 6, name: 'Sandy', address: 'Ocean blvd 2'&#125;, &#123; id: 8, name: 'Richard', address: 'Sky st 331'&#125;, &#123; id: 2, name: 'Peter', address: 'Lowstreet 4'&#125;, &#123; id: 5, name: 'Michael', address: 'Valley 345'&#125;, &#123; id: 1, name: 'John', address: 'Higheay 71'&#125;, &#123; id: 4, name: 'Hannah', address: 'Mountain 21'&#125;, &#123; id: 13, name: 'Chuck', address: 'Main Road 989'&#125;, &#123; id: 7, name: 'Betty', address: 'Green Grass 1'&#125;, &#123; id: 11, name: 'Ben', address: 'Park Lane 38'&#125;, &#123; id: 3, name: 'Amy', address: 'Apple st 652'&#125;] delete删除记录您可以使用“ DELETE FROM”语句从现有表中删除记录：删除地址为“ Mountain 21”的所有记录： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"DELETE FROM customers WHERE address = 'Mountain 21'\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"Number of records deleted: \" + result.affectedRows); &#125;);&#125;); 请注意DELETE语法中的WHERE子句： WHERE子句指定应删除的记录。如果省略WHERE子句，则将删除所有记录！ 结果对象执行查询时，将返回结果对象。 结果对象包含有关查询如何影响表的信息。 从上面的示例返回的结果对象如下所示： 12345678910&#123; fieldCount: 0, affectedRows: 1, insertId: 0, serverStatus: 34, warningCount: 0, message: '', protocol41: true, changedRows: 0&#125; 属性值可以这样显示console.log(result.affectedRows) Drop Table删除表格您可以使用“ DROP TABLE”语句删除现有表： 删除表“ customers”： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"DROP TABLE customers\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"Table deleted\"); &#125;);&#125;); 仅在存在时drop如果您要删除的表已被删除，或者由于任何其他原因不存在，则可以使用IF EXISTS关键字来避免出现错误。删除表“ customers”（如果存在）： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"DROP TABLE IF EXISTS customers\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 如果该表存在，则结果对象将如下所示： 12345678910&#123; fieldCount: 0, affectedRows: 0, insertId: 0, serverstatus: 2, warningCount: 0, message: '', protocol41: true, changedRows: 0&#125; 如果该表不存在，则结果对象将如下所示： 12345678910&#123; fieldCount: 0, affectedRows: 0, insertId: 0, serverstatus: 2, warningCount: 1, message: '', protocol41: true, changedRows: 0&#125; 如您所见，唯一的区别是如果表不存在，则warningCount属性设置为1。 updateupdate表您可以使用“ UPDATE”语句来更新表中的现有记录： 将地址列从“ Valley 345”覆盖为“ Canyon 123”： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"UPDATE customers SET address = 'Canyon 123' WHERE address = 'Valley 345'\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result.affectedRows + \" record(s) updated\"); &#125;);&#125;); 请注意UPDATE语法中的WHERE子句： WHERE子句指定应更新的记录。如果省略WHERE子句，所有记录将被更新！ 结果对象执行查询时，将返回结果对象。 结果对象包含有关查询如何影响表的信息。 从上面的示例返回的结果对象如下所示 12345678910&#123; fieldCount: 0, affectedRows: 1, insertId: 0, serverStatus: 34, warningCount: 0, message: '(Rows matched: 1 Changed: 1 Warnings: 0', protocol41: true, changedRows: 1&#125; limit限制结果1.您可以使用“ LIMIT”语句来限制查询返回的记录数： 在“customers”表中选择前5条记录： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"SELECT * FROM customers LIMIT 5\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 从另一个位置开始2.如果要从第三条记录开始返回五条记录，则可以使用“ OFFSET”关键字： 从位置3开始，并返回接下来的5条记录： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"SELECT * FROM customers LIMIT 5 OFFSET 2\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 注意： “offset 2”表示从第三个位置开始，而不是第二个位置！ 较短的语法3.您还可以使用像这样的“ LIMIT 2、5”这样编写SQL语句，该语句返回与上面的偏移量示例相同的结果： 从位置3开始，并返回接下来的5条记录： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"SELECT * FROM customers LIMIT 2, 5\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 注意：数字是相反的：“ LIMIT 2、5”与“ LIMIT 5 OFFSET 2”相同 JOIN联接两个或更多表您可以使用JOIN语句基于两个或多个表之间的相关列来合并行。 考虑您有一个“customers”表和一个“production”表： 使用者 1234567[ &#123; id: 1, name: 'John', favorite_product: 154&#125;, &#123; id: 2, name: 'Peter', favorite_product: 154&#125;, &#123; id: 3, name: 'Amy', favorite_product: 155&#125;, &#123; id: 4, name: 'Hannah', favorite_product:&#125;, &#123; id: 5, name: 'Michael', favorite_product:&#125;] 产品展示 12345[ &#123; id: 154, name: 'Chocolate Heaven' &#125;, &#123; id: 155, name: 'Tasty Lemons' &#125;, &#123; id: 156, name: 'Vanilla Dreams' &#125;] 可以通过使用用户favorite_product字段和产品 id字段来组合这两个表。 选择两个表中都匹配的记录： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"SELECT users.name AS user, products.name AS favorite FROM users JOIN products ON users.favorite_product = products.id\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 注意：您可以使用INNER JOIN代替JOIN。他们都会给你相同的结果。 left JOIN如果要返回所有用户，无论他们是否拥有喜欢的产品，请使用LEFT JOIN语句： 选择所有用户及其喜爱的产品： 1234SELECT users.name AS user,products.name AS favoriteFROM usersLEFT JOIN products ON users.favorite_product = products.id right JOIN如果您想退回所有产品，并且将其作为收藏的用户，即使没有用户将其作为收藏，请使用RIGHT JOIN语句： 选择所有产品以及将其作为收藏的用户： 1234SELECT users.name AS user,products.name AS favoriteFROM usersRIGHT JOIN products ON users.favorite_product = products.id 结果 123456[ &#123; user: 'John', favorite: 'Chocolate Heaven' &#125;, &#123; user: 'Peter', favorite: 'Chocolate Heaven' &#125;, &#123; user: 'Amy', favorite: 'Tasty Lemons' &#125;, &#123; user: null, favorite: 'Vanilla Dreams' &#125;] 注意：没有喜欢的产品的汉娜（Hannah）和迈克尔（Michael）不包括在结果中。","categories":[],"tags":[],"keywords":[]},{"title":"面试题/javascript面试题","slug":"面试题/javascript面试题","date":"2020-01-20T12:35:56.130Z","updated":"2020-02-26T18:37:22.617Z","comments":true,"path":"2020/01/20/面试题/javascript面试题/","link":"","permalink":"http://yoursite.com/2020/01/20/%E9%9D%A2%E8%AF%95%E9%A2%98/javascript%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1 介绍JavaScript的基本数据类型 Number、String 、Boolean 、Null、UndefinedObject 是 JavaScript 中所有对象的父对象数据封装类对象：Object、Array、Boolean、Number 和 String其他对象：Function、Arguments、Math、Date、RegExp、Error新类型：Symbol 2 说说写JavaScript的基本规范？ 1) 不要在同一行声明多个变量2) 使用 ===或!==来比较true/false或者数值3) switch必须带有default分支4) 函数应该有返回值5) for if else 必须使用大括号6) 语句结束加分号7) 命名要有意义，使用驼峰命名法 3 jQuery使用建议 1) 尽量减少对dom元素的访问和操作2) 尽量避免给dom元素绑定多个相同类型的事件处理函数，可以将多个相同类型事件处理函数合并到一个处理函数，通过数据状态来处理分支3) 尽量避免使用toggle事件 4 Ajax使用全称 ： Asynchronous Javascript And XML所谓异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。创建Ajax的过程： 1) 创建XMLHttpRequest对象（异步调用对象） var xhr = new XMLHttpRequest();2) 创建新的Http请求（方法、URL、是否异步） xhr.open(‘get’,’example.php’,false);3) 设置响应HTTP请求状态变化的函数。onreadystatechange事件中readyState属性等于4。响应的HTTP状态为200(OK)或者304(Not Modified)。4) 发送http请求 xhr.send(data);5) 获取异步调用返回的数据注意： 1) 页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。2) 同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax。3) 尽量减少ajax请求次数4) ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理。 5 JavaScript有几种类型的值？你能画一下他们的内存图吗？基本数据类型存储在栈中，引用数据类型（对象）存储在堆中，指针放在栈中。两种类型的区别是：存储位置不同；原始数据类型直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 6 栈和堆的区别？栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等；堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。 7 Javascript实现继承的几种方式可以参考我的另一篇文章JavaScript实现类与继承的方法（全面整理） 8 Javascript创建对象的几种方式？可以参考我的另一篇文章JavaScript实现类与继承的方法（全面整理） 9 Javascript作用链域作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。注意：JS没有块级作用域，若要形成块级作用域，可通过（function（）｛｝）（）；立即执行的形式实现。 10 谈谈this的理解 1) this总是指向函数的直接调用者（而非间接调用者）2) 如果有new关键字，this指向new出来的那个对象3) 在事件中，this指向目标元素，特殊的是IE的attachEvent中的this总是指向全局对象window。 11 eval是做什么的？它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 12 什么是window对象? 什么是document对象?window对象代表浏览器中打开的一个窗口。document对象代表整个html文档。实际上，document对象是window对象的一个属性。 13 null，undefined的区别？null表示一个对象被定义了，但存放了空指针，转换为数值时为0。undefined表示声明的变量未初始化，转换为数值时为NAN。typeof(null) – object;typeof(undefined) – undefined 14 写一个通用的事件侦听器函数(机试题) 15 [“1”, “2”, “3”].map(parseInt) 答案是多少？[1,NaN,NaN] 解析：Array.prototype.map()array.map(callback[, thisArg])callback函数的执行规则参数：自动传入三个参数currentValue（当前被传递的元素）；index（当前被传递的元素的索引）；array（调用map方法的数组） parseInt方法接收两个参数第三个参数[“1”, “2”, “3”]将被忽略。parseInt方法将会通过以下方式被调用parseInt(“1”, 0)parseInt(“2”, 1)parseInt(“3”, 2) parseInt的第二个参数radix为0时，ECMAScript5将string作为十进制数字的字符串解析；parseInt的第二个参数radix为1时，解析结果为NaN；parseInt的第二个参数radix在2—36之间时，如果string参数的第一个字符（除空白以外），不属于radix指定进制下的字符，解析结果为NaN。parseInt(“3”, 2)执行时，由于”3”不属于二进制字符，解析结果为NaN。 16 关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？IE为事件冒泡，Firefox同时支持事件捕获和事件冒泡。但并非所有浏览器都支持事件捕获。jQuery中使用event.stopPropagation()方法可阻止冒泡;（旧IE的方法 ev.cancelBubble = true;） 17 什么是闭包（closure），为什么要用它？闭包指的是一个函数可以访问另一个函数作用域中变量。常见的构造方法，是在一个函数内部定义另外一个函数。内部函数可以引用外层的变量；外层变量不会被垃圾回收机制回收。注意，闭包的原理是作用域链，所以闭包访问的上级作用域中的变量是个对象，其值为其运算结束后的最后一个值。优点：避免全局变量污染。缺点：容易造成内存泄漏。例子： function makeFunc() { var name = “Mozilla”; function displayName() { console.log(name); } return displayName;}var myFunc = makeFunc();myFunc(); //输出MozillamyFunc 变成一个 闭包。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc 是一个闭包，由 displayName 函数和闭包创建时存在的 “Mozilla” 字符串形成。 18 javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？除了正常模式运行外，ECMAscript添加了第二种运行模式：“严格模式”。作用： 1) 消除js不合理，不严谨地方，减少怪异行为2) 消除代码运行的不安全之处，3) 提高编译器的效率，增加运行速度4) 为未来的js新版本做铺垫。 19 如何判断一个对象是否属于某个类？使用instanceof 即if(a instanceof Person){alert(‘yes’);} 20 new操作符具体干了什么呢? 1) 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2) 属性和方法被加入到 this 引用的对象中。3) 新创建的对象由 this 所引用，并且最后隐式的返回 this 。 21 Javascript中，执行时对象查找时，永远不会去查找原型的函数？Object.hasOwnProperty(proName)：是用来判断一个对象是否有你给出名称的属性。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。 22 对JSON的了解？全称：JavaScript Object NotationJSON中对象通过“{}”来标识，一个“{}”代表一个对象，如{“AreaId”:”123”}，对象的值是键值对的形式（key：value）。JSON是JS的一个严格的子集，一种轻量级的数据交换格式，类似于xml。数据格式简单，易于读写，占用带宽小。两个函数：JSON.parse(str)解析JSON字符串 把JSON字符串变成JavaScript值或对象JSON.stringify(obj)将一个JavaScript值(对象或者数组)转换为一个 JSON字符串eval(‘(‘＋json＋’)’)用eval方法注意加括号 而且这种方式更容易被攻击 23 JS延迟加载的方式有哪些？JS的延迟加载有助与提高页面的加载速度。defer和async、动态创建DOM方式（用得最多）、按需异步载入JSdefer：延迟脚本。立即下载，但延迟执行（延迟到整个页面都解析完毕后再运行），按照脚本出现的先后顺序执行。async：异步脚本。下载完立即执行，但不保证按照脚本出现的先后顺序执行。 24 同步和异步的区别?同步的概念在操作系统中：不同进程协同完成某项工作而先后次序调整（通过阻塞、唤醒等方式），同步强调的是顺序性，谁先谁后。异步不存在顺序性。同步：浏览器访问服务器，用户看到页面刷新，重新发请求，等请求完，页面刷新，新内容出现，用户看到新内容之后进行下一步操作。异步：浏览器访问服务器请求，用户正常操作，浏览器在后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。 25 什么是跨域问题 ，如何解决跨域问题?可以参考我的另一篇文章什么是跨域以及几种简单解决方案 26 页面编码和被请求的资源编码如果不一致如何处理？若请求的资源编码，如外引js文件编码与页面编码不同。可根据外引资源编码方式定义为 charset=”utf-8”或”gbk”。比如：http://www.yyy.com/a.html 中嵌入了一个http://www.xxx.com/test.jsa.html 的编码是gbk或gb2312的。 而引入的js编码为utf-8的 ，那就需要在引入的时候","categories":[],"tags":[],"keywords":[]},{"title":"面试题/nodejs与javascript的区别","slug":"面试题/nodejs与javascript的区别","date":"2020-01-19T12:48:16.979Z","updated":"2020-01-20T12:36:38.114Z","comments":true,"path":"2020/01/19/面试题/nodejs与javascript的区别/","link":"","permalink":"http://yoursite.com/2020/01/19/%E9%9D%A2%E8%AF%95%E9%A2%98/nodejs%E4%B8%8Ejavascript%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"javascript使用了 ECMAScript 语法规范，外加Web API, 缺一不可 （web API w3c规范） DOM操作BOM操作事件绑定Ajax 请求等两者结合，即可完成浏览器端的任何操作 nodejs使用了语法规范，外加nodejs API，缺一不可处理http, 处理文件，具体参考 http://nodejs.cn/api两者结合，即可完成server端的任何操作 ECMAScript是语法规范node = ECMAScript + nodejs APIjavascript = ECMAScript + webAPI","categories":[],"tags":[],"keywords":[]},{"title":"eggjs/service","slug":"eggjs/service","date":"2020-01-16T11:38:11.668Z","updated":"2020-01-17T13:18:10.051Z","comments":true,"path":"2020/01/16/eggjs/service/","link":"","permalink":"http://yoursite.com/2020/01/16/eggjs/service/","excerpt":"","text":"npm install mysql //下载并安装mysql数据库驱动程序","categories":[],"tags":[],"keywords":[]},{"title":"NodeJS/MongoDB","slug":"NodeJS/MongoDB","date":"2020-01-14T06:48:28.400Z","updated":"2020-01-14T08:50:15.042Z","comments":true,"path":"2020/01/14/NodeJS/MongoDB/","link":"","permalink":"http://yoursite.com/2020/01/14/NodeJS/MongoDB/","excerpt":"","text":"cnpm install mongodb 创建数据库 要在MongoDB中创建数据库，请先创建一个MongoClient对象，然后使用正确的IP地址和要创建的数据库名称指定连接URL。 如果数据库不存在，MongoDB将创建该数据库并建立连接。 创建mydb数据库: 12345678var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/mydb\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; console.log(\"Database created!\"); db.close();&#125;); 重要提示：在MongoDB中，直到获得内容才创建数据库 在实际创建数据库（和集合）之前，MongoDB会等到您创建了一个集合（表）（至少包含一个文档（记录））后，再进行创建。 创建集合MongoDB中的集合与MySQL中的表相同 要在MongoDB中创建集合，请使用createCollection()方法： 创建一个名为“客户”的集合： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.createCollection(\"customers\", function(err, res) &#123; if (err) throw err; console.log(\"Collection created!\"); db.close(); &#125;);&#125;); 重要提示：在MongoDB中，只有在获得内容后才创建集合！ MongoDB等到您插入文档后才真正创建集合。 数据库操作 insert 插入集合要将记录或在MongoDB中调用的文档插入集合，我们使用insertOne（）方法。 MongoDB中的文档与MySQL中的记录相同insertOne（）方法的第一个参数是一个对象，其中包含您要插入的文档中每个字段的名称和值。它还带有一个回调函数，您可以在其中处理任何错误或插入结果：例 将文档插入“customs”集合中： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myobj = &#123; name: \"Company Inc\", address: \"Highway 37\" &#125;; dbo.collection(\"customers\").insertOne(myobj, function(err, res) &#123; if (err) throw err; console.log(\"1 document inserted\"); db.close(); &#125;);&#125;); 注意：如果您尝试在不存在的集合中插入文档，MongoDB将自动创建集合。 插入多个文档 要将多个文档插入MongoDB的集合中，我们使用insertMany()方法。 insertMany()方法的第一个参数是一个对象数组，其中包含要插入的数据。 它还带有一个回调函数，您可以在其中处理任何错误或插入结果： 在”customrs”集合插入多个文档 12345678910111213141516171819202122232425262728var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myobj = [ &#123; name: 'John', address: 'Highway 71'&#125;, &#123; name: 'Peter', address: 'Lowstreet 4'&#125;, &#123; name: 'Amy', address: 'Apple st 652'&#125;, &#123; name: 'Hannah', address: 'Mountain 21'&#125;, &#123; name: 'Michael', address: 'Valley 345'&#125;, &#123; name: 'Sandy', address: 'Ocean blvd 2'&#125;, &#123; name: 'Betty', address: 'Green Grass 1'&#125;, &#123; name: 'Richard', address: 'Sky st 331'&#125;, &#123; name: 'Susan', address: 'One way 98'&#125;, &#123; name: 'Vicky', address: 'Yellow Garden 2'&#125;, &#123; name: 'Ben', address: 'Park Lane 38'&#125;, &#123; name: 'William', address: 'Central st 954'&#125;, &#123; name: 'Chuck', address: 'Main Road 989'&#125;, &#123; name: 'Viola', address: 'Sideway 1633'&#125; ]; dbo.collection(\"customers\").insertMany(myobj, function(err, res) &#123; if (err) throw err; console.log(\"Number of documents inserted: \" + res.insertedCount); db.close(); &#125;);&#125;); 结果对象 执行insertMany（）方法时，将返回结果对象。 结果对象包含有关插入如何影响数据库的信息 从上面的示例返回的对象如下所示： 12345678910111213141516171819202122232425262728293031323334&#123; result: &#123; ok: 1, n: 14 &#125;, ops: [ &#123; name: 'John', address: 'Highway 71', _id: 58fdbf5c0ef8a50b4cdd9a84 &#125;, &#123; name: 'Peter', address: 'Lowstreet 4', _id: 58fdbf5c0ef8a50b4cdd9a85 &#125;, &#123; name: 'Amy', address: 'Apple st 652', _id: 58fdbf5c0ef8a50b4cdd9a86 &#125;, &#123; name: 'Hannah', address: 'Mountain 21', _id: 58fdbf5c0ef8a50b4cdd9a87 &#125;, &#123; name: 'Michael', address: 'Valley 345', _id: 58fdbf5c0ef8a50b4cdd9a88 &#125;, &#123; name: 'Sandy', address: 'Ocean blvd 2', _id: 58fdbf5c0ef8a50b4cdd9a89 &#125;, &#123; name: 'Betty', address: 'Green Grass 1', _id: 58fdbf5c0ef8a50b4cdd9a8a &#125;, &#123; name: 'Richard', address: 'Sky st 331', _id: 58fdbf5c0ef8a50b4cdd9a8b &#125;, &#123; name: 'Susan', address: 'One way 98', _id: 58fdbf5c0ef8a50b4cdd9a8c &#125;, &#123; name: 'Vicky', address: 'Yellow Garden 2', _id: 58fdbf5c0ef8a50b4cdd9a8d &#125;, &#123; name: 'Ben', address: 'Park Lane 38', _id: 58fdbf5c0ef8a50b4cdd9a8e &#125;, &#123; name: 'William', address: 'Central st 954', _id: 58fdbf5c0ef8a50b4cdd9a8f &#125;, &#123; name: 'Chuck', address: 'Main Road 989', _id: 58fdbf5c0ef8a50b4cdd9a90 &#125;, &#123; name: 'Viola', address: 'Sideway 1633', _id: 58fdbf5c0ef8a50b4cdd9a91 &#125; ], insertedCount: 14, insertedIds: [ 58fdbf5c0ef8a50b4cdd9a84, 58fdbf5c0ef8a50b4cdd9a85, 58fdbf5c0ef8a50b4cdd9a86, 58fdbf5c0ef8a50b4cdd9a87, 58fdbf5c0ef8a50b4cdd9a88, 58fdbf5c0ef8a50b4cdd9a89, 58fdbf5c0ef8a50b4cdd9a8a, 58fdbf5c0ef8a50b4cdd9a8b, 58fdbf5c0ef8a50b4cdd9a8c, 58fdbf5c0ef8a50b4cdd9a8d, 58fdbf5c0ef8a50b4cdd9a8e, 58fdbf5c0ef8a50b4cdd9a8f 58fdbf5c0ef8a50b4cdd9a90, 58fdbf5c0ef8a50b4cdd9a91 ]&#125;属性值可以这样显示： 返回插入的文档数： 1console.log(res.insertedCount) _id字段 如果您未指定_id字段，则MongoDB将为您添加一个，并为每个文档分配唯一的ID。 在上面的示例中，没有指定_id字段，从结果对象可以看到，MongoDB为每个文档分配了唯一的_id。 如果确实指定_id字段，则每个文档的值必须唯一： 在带有指定_id字段的“products”表中插入三个记录： 1234567891011121314151617var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myobj = [ &#123; _id: 154, name: 'Chocolate Heaven'&#125;, &#123; _id: 155, name: 'Tasty Lemon'&#125;, &#123; _id: 156, name: 'Vanilla Dream'&#125; ]; dbo.collection(\"products\").insertMany(myobj, function(err, res) &#123; if (err) throw err; console.log(res); db.close(); &#125;);&#125;); Find 在MongoDB中，我们使用find和findOne方法在集合中查找数据。就像SELECT语句用于在MySQL数据库的表中查找数据一样。 Find One 要从MongoDB中的集合中选择数据，我们可以使用findOne（）方法。 findOne（）方法返回选择中的第一个匹配项。 findOne（）方法的第一个参数是查询对象。在此示例中，我们使用一个空的查询对象，该对象选择集合中的所有文档（但仅返回第一个文档）。 在客户集合中找到第一个文档： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").findOne(&#123;&#125;, function(err, result) &#123; if (err) throw err; console.log(result.name); db.close(); &#125;);&#125;); Find All 要从MongoDB中的表中选择数据，我们还可以使用find（）方法。 find（）方法返回选择中的所有匹配项。 find（）方法的第一个参数是查询对象。在此示例中，我们使用一个空的查询对象，该对象选择集合中的所有文档。 查找customs集合中的所有文档： 1234567891011var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").find(&#123;&#125;).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;); Find Some find（）方法的第二个参数是投影对象，它描述要在结果中包括哪些字段。 此参数是可选的，如果省略，则所有字段都将包含在结果中。 返回客户集合中所有文档的“名称”和“地址”字段： 1234567891011var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").find(&#123;&#125;, &#123; projection: &#123; _id: 0, name: 1, address: 1 &#125; &#125;).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 您不允许在同一对象中同时指定0和1值（除非其中一个字段是_id字段）。如果您指定值为0的字段，则所有其他字段的值为1，反之亦然： 此示例将从结果中排除“地址”： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").find(&#123;&#125;, &#123; projection: &#123; address: 0 &#125; &#125;).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;);要排除_id字段，必须将其值设置为0： 如果在同一对象中同时指定0和1值，则会出现错误（除非其中一个字段是_id字段）： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").find(&#123;&#125;, &#123; projection: &#123; name: 1, address: 0 &#125; &#125;).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 结果对象从上面示例的结果可以看出，可以将结果转换为包含每个文档作为对象的数组。要返回例如第三个文档的地址，只需引用第三个数组对象的address属性： 返回第三个文档的地址： 1console.log(result[2].address); queryFilter 结果在集合中查找文档时，可以使用查询对象过滤结果。 find（）方法的第一个参数是查询对象，用于限制搜索。 查找address“ Park Lane 38”的文档： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var query = &#123; address: \"Park Lane 38\" &#125;; dbo.collection(\"customers\").find(query).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 用正则表达式过滤您可以编写正则表达式以准确查找要搜索的内容。 正则表达式只能用于查询字符串。 要仅查找“address”字段以字母“ S”开头的文档，请使用正则表达式/ ^ S /： 查找地址以字母“ S”开头的文档： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var query = &#123; address: /^S/ &#125;; dbo.collection(\"customers\").find(query).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 排序结果使用sort（）方法对结果进行升序或降序排序。 sort（）方法采用一个参数，这是一个定义排序顺序的对象。 按名称的字母顺序对结果进行排序： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var mysort = &#123; name: 1 &#125;; dbo.collection(\"customers\").find().sort(mysort).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 降序排列在排序对象中使用值-1进行降序排序。 12&#123; name: 1 &#125; // ascending&#123; name: -1 &#125; // descending 按名称的字母顺序对结果进行反向排序： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var mysort = &#123; name: -1 &#125;; dbo.collection(\"customers\").find().sort(mysort).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); delete删除文件要删除在MongoDB中调用的记录或文档，我们使用deleteOne（）方法。 deleteOne（）方法的第一个参数是一个查询对象，用于定义要删除的文档 注意：如果查询找到多个文档，则仅删除第一次出现的文档。 删除address “Mountain 21” 的文档： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myquery = &#123; address: 'Mountain 21' &#125;; dbo.collection(\"customers\").deleteOne(myquery, function(err, obj) &#123; if (err) throw err; console.log(\"1 document deleted\"); db.close(); &#125;);&#125;); 删除许多要删除多个文档，请使用deleteMany（）方法。 deleteMany（）方法的第一个参数是一个查询对象，用于定义要删除的文档。 删除地址以字母“ O”开头的所有文档： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myquery = &#123; address: /^O/ &#125;; dbo.collection(\"customers\").deleteMany(myquery, function(err, obj) &#123; if (err) throw err; console.log(obj.result.n + \" document(s) deleted\"); db.close(); &#125;);&#125;); 结果对象deleteMany（）方法返回一个对象，该对象包含有关执行如何影响数据库的信息。 大多数信息不是很重要，但该对象内部的一个对象称为“结果”，它告诉我们执行是否正常以及有多少文档受到影响 结果对象如下所示： 1&#123; n: 2, ok: 1 &#125; 您可以使用此对象返回已删除文档的数量： 返回已删除文档的数量： 1console.log(obj.result.n); drop集合您可以使用drop（）方法删除表或在MongoDB中调用的集合。 drop（）方法采用一个回调函数，该函数包含错误对象和result参数，如果成功删除了集合，则返回true，否则返回false。 删除”customs”表： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").drop(function(err, delOK) &#123; if (err) throw err; if (delOK) console.log(\"Collection deleted\"); db.close(); &#125;);&#125;); db.dropCollection您也可以使用dropCollection（）方法删除表（集合）。 dropCollection（）方法采用两个参数：集合的名称和回调函数。 使用dropCollection（）删除“customs”集合： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.dropCollection(\"customers\", function(err, delOK) &#123; if (err) throw err; if (delOK) console.log(\"Collection deleted\"); db.close(); &#125;);&#125;); 更新文件您可以使用updateOne（）方法更新记录或在MongoDB中调用的文档。 updateOne（）方法的第一个参数是一个查询对象，用于定义要更新的文档。 注意：如果查询找到多个记录，则仅更新第一个记录。 第二个参数是定义文档新值的对象。 使用address=”Valley 345”将文档更新为name =”Mickey”和address =”Canyon 123”： 1234567891011121314var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://127.0.0.1:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myquery = &#123; address: \"Valley 345\" &#125;; var newvalues = &#123; $set: &#123;name: \"Mickey\", address: \"Canyon 123\" &#125; &#125;; dbo.collection(\"customers\").updateOne(myquery, newvalues, function(err, res) &#123; if (err) throw err; console.log(\"1 document updated\"); db.close(); &#125;);&#125;); 仅更新特定字段使用$set运算符时，仅更新指定的字段： 将address =”Valley 345”更新为”Canyon 123”： 123var myquery = &#123; address: \"Valley 345\" &#125;; var newvalues = &#123; $set: &#123; address: \"Canyon 123\" &#125; &#125;; dbo.collection(\"customers\").updateOne(myquery, newvalues, function(err, res) &#123; 更新许多文件要更新所有符合查询条件的文档，请使用updateMany（）方法。 更新名称以字母“ S”开头的所有文档： 1234567891011121314var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://127.0.0.1:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myquery = &#123; address: /^S/ &#125;; var newvalues = &#123;$set: &#123;name: \"Minnie\"&#125; &#125;; dbo.collection(\"customers\").updateMany(myquery, newvalues, function(err, res) &#123; if (err) throw err; console.log(res.result.nModified + \" document(s) updated\"); db.close(); &#125;);&#125;); 结果对象updateOne（）和updateMany（）方法返回一个对象，该对象包含有关执行如何影响数据库的信息。 大多数信息并不是很重要，但对象内部的一个对象称为“结果”，它告诉我们执行是否正常以及受影响的文档数量。 结果对象如下所示： 1&#123; n: 1, nModified: 2, ok: 1 &#125; 您可以使用此对象返回更新的文档数： 返回更新的文档数： 1console.log(res.result.nModified); limit限制结果为了限制MongoDB中的结果，我们使用limit（）方法。 limit（）方法采用一个参数，一个数字定义要返回的文档数。 考虑您有一个”customs”集合： 将结果限制为仅返回5个文档： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").find().limit(5).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); joinjoin集合MongoDB不是关联数据库，但是您可以使用$lookup阶段执行左外部联接。 通过$lookup阶段，您可以指定要与当前集合一起加入的集合以及应该匹配的字段。 考虑您有一个”orders”集合和一个”products”集合： orders [ { _id: 1, product_id: 154, status: 1 } ] products [ { _id: 154, name: &apos;Chocolate Heaven&apos; }, { _id: 155, name: &apos;Tasty Lemons&apos; }, { _id: 156, name: &apos;Vanilla Dreams&apos; } ]将匹配的“products”文档加入“orders”集合： 1234567891011121314151617181920var url = \"mongodb://127.0.0.1:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection('orders').aggregate([ &#123; $lookup: &#123; from: 'products', localField: 'product_id', foreignField: '_id', as: 'orderdetails' &#125; &#125; ]).toArray(function(err, res) &#123; if (err) throw err; console.log(JSON.stringify(res)); db.close(); &#125;);&#125;); 从上面的结果可以看到，产品集合中的匹配文档以数组的形式包含在订单集合中。","categories":[],"tags":[],"keywords":[]},{"title":"docker/mongoDBError","slug":"docker/mongoDBError","date":"2020-01-14T06:32:36.186Z","updated":"2020-01-21T06:07:21.488Z","comments":true,"path":"2020/01/14/docker/mongoDBError/","link":"","permalink":"http://yoursite.com/2020/01/14/docker/mongoDBError/","excerpt":"","text":"[root@test3] # docker run -itd –name mongo -p 27017:27017 mongo –auth Error response from daemon: Conflict. The container name &quot;/mysql-server&quot; is already in use by container bdc8d8c475cb86695c466d23fd7102221f2c040898c2d576f94cd06c93ca811b. You have to remove (or rename) that container to be able to reuse that name..See &apos;/usr/bin/docker-current run --help&apos;. 1.docker ps 2.docker ps -l 3.docker rm bdc8d8c475cbhttps://blog.csdn.net/972301/article/details/80915127https://thispointer.com/docker-how-to-stop-remove-a-running-container-by-id-or-name/","categories":[],"tags":[],"keywords":[]},{"title":"docker/error","slug":"docker/error","date":"2020-01-14T06:32:36.000Z","updated":"2020-01-14T09:46:45.000Z","comments":true,"path":"2020/01/14/docker/error/","link":"","permalink":"http://yoursite.com/2020/01/14/docker/error/","excerpt":"","text":"[root@test3] # docker run -itd –name mongo -p 27017:27017 mongo –auth Error response from daemon: Conflict. The container name &quot;/mysql-server&quot; is already in use by container bdc8d8c475cb86695c466d23fd7102221f2c040898c2d576f94cd06c93ca811b. You have to remove (or rename) that container to be able to reuse that name..See &apos;/usr/bin/docker-current run --help&apos;. 1.docker ps 2.docker ps -l 3.docker rm bdc8d8c475cbhttps://blog.csdn.net/972301/article/details/80915127https://thispointer.com/docker-how-to-stop-remove-a-running-container-by-id-or-name/","categories":[],"tags":[],"keywords":[]},{"title":"面试题/react_面试题","slug":"面试题/react_面试题","date":"2020-01-14T03:22:51.671Z","updated":"2020-01-14T04:06:52.668Z","comments":true,"path":"2020/01/14/面试题/react_面试题/","link":"","permalink":"http://yoursite.com/2020/01/14/%E9%9D%A2%E8%AF%95%E9%A2%98/react_%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"this.setState 同步和异步特性： setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。 setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。 setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。 https://juejin.im/post/5bf1444cf265da614a3a1660 写一个闭包： 12345678910111213function foo() &#123; let a = 2; function bar() &#123; console.log( a ); &#125; return bar;&#125;let baz = foo();baz(); 防抖和节流： 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。 结合应用场景 debouncesearch搜索联想，用户在不断输入值时，用防抖来节约请求资源。window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 throttle鼠标不断点击触发，mousedown(单位时间内只触发一次)监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断 https://juejin.im/post/5b8de829f265da43623c4261 什么事真实dom?什么是虚拟dom? localStorage 和 sessionStorage 的区别？ es6 的新特性： React怎么判断重新渲染该组件： js的同源策略？ 手写一个冒泡排序算法： jsde的执行顺序：","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Preventing_Transition","slug":"react_router/examples/Preventing_Transition","date":"2020-01-13T11:18:55.488Z","updated":"2020-01-13T11:25:49.919Z","comments":true,"path":"2020/01/13/react_router/examples/Preventing_Transition/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Preventing_Transition/","excerpt":"","text":"harmony123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import React, &#123; useState &#125; from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, Prompt&#125; from \"react-router-dom\";/*有时您想阻止用户 离开页面导航。 最常见的 用例是当他们输入一些数据时 表格，但尚未提交，并且 你不希望他们失去它。*/export default function PreventingTransitionsExample() &#123; return ( &lt;Router&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Form&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/one\"&gt;One&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/two\"&gt;Two&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact children=&#123;&lt;BlockingForm /&gt;&#125; /&gt; &lt;Route path=\"/one\" children=&#123;&lt;h3&gt;One&lt;/h3&gt;&#125; /&gt; &lt;Route path=\"/two\" children=&#123;&lt;h3&gt;Two&lt;/h3&gt;&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; );&#125;function BlockingForm() &#123; let [isBlocking, setIsBlocking] = useState(false); return ( &lt;form onSubmit=&#123;event =&gt; &#123; event.preventDefault(); event.target.reset(); setIsBlocking(false); &#125;&#125; &gt; &lt;Prompt when=&#123;isBlocking&#125; message=&#123;location =&gt; `Are you sure you want to go to $&#123;location.pathname&#125;` &#125; /&gt; &lt;p&gt; Blocking?&#123;\" \"&#125; &#123;isBlocking ? \"Yes, click a link or the back button\" : \"Nope\"&#125; &lt;/p&gt; &lt;p&gt; &lt;input size=\"50\" placeholder=\"type something to block transitions\" onChange=&#123;event =&gt; &#123; setIsBlocking(event.target.value.length &gt; 0); &#125;&#125; /&gt; &lt;/p&gt; &lt;p&gt; &lt;button&gt;Submit to stop blocking&lt;/button&gt; &lt;/p&gt; &lt;/form&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/No_Match","slug":"react_router/examples/No_Match","date":"2020-01-13T11:14:52.115Z","updated":"2020-01-13T11:18:17.273Z","comments":true,"path":"2020/01/13/react_router/examples/No_Match/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/No_Match/","excerpt":"","text":"harmony12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import React from \"react\";import &#123; BrowserRouter as Router, Route, Link, Switch, Redirect, useLocation&#125; from \"react-router-dom\";/* 您可以将&lt;Switch&gt;中的最后一个&lt;Route&gt;用作一种 “后备”路线，以捕获404错误。关于此示例，有一些有用的注意事项： &lt;Switch&gt;呈现与之匹配的第一个子元素&lt;Route&gt; &lt;Redirect&gt;可以用于将旧URL重定向到新URL &lt;Route path =“ *&gt;始终匹配*/export default function NoMatchExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/old-match\"&gt;Old Match, to be redirected&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/will-match\"&gt;Will Match&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/will-not-match\"&gt;Will Not Match&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/also/will/not/match\"&gt;Also Will Not Match&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/old-match\"&gt; &lt;Redirect to=\"/will-match\" /&gt; &lt;/Route&gt; &lt;Route path=\"/will-match\"&gt; &lt;WillMatch /&gt; &lt;/Route&gt; &lt;Route path=\"*\"&gt; &lt;NoMatch /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Home() &#123; return &lt;h3&gt;Home&lt;/h3&gt;;&#125;function WillMatch() &#123; return &lt;h3&gt;Matched!&lt;/h3&gt;;&#125;function NoMatch() &#123; let location = useLocation(); return ( &lt;div&gt; &lt;h3&gt; No match for &lt;code&gt;&#123;location.pathname&#125;&lt;/code&gt; &lt;/h3&gt; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Recursive_Paths","slug":"react_router/examples/Recursive_Paths","date":"2020-01-13T11:12:35.304Z","updated":"2020-01-13T11:14:36.107Z","comments":true,"path":"2020/01/13/react_router/examples/Recursive_Paths/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Recursive_Paths/","excerpt":"","text":"harmony123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, Redirect, useParams, useRouteMatch&#125; from \"react-router-dom\";/*有时您不知道所有可能的路线预先为您的应用程序； 例如，当构建文件系统浏览UI或确定网址是根据数据动态生成的。 在这些情况下，它有助于拥有一个能够在运行时根据需要生成路由。该示例使您可以深入了解朋友递归列表，查看每个用户的朋友列表一路上。 向下钻取时，请注意每个细分被添加到URL。 您可以复制/粘贴此链接 给其他人，他们将看到相同的用户界面。然后单击后退按钮并观看最后一个URL的段与最后一个段一起消失好友列表。*/export default function RecursiveExample() &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path=\"/:id\"&gt; &lt;Person /&gt; &lt;/Route&gt; &lt;Route path=\"/\"&gt; &lt;Redirect to=\"/0\" /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/Router&gt; );&#125;function Person() &#123; let &#123; url &#125; = useRouteMatch(); let &#123; id &#125; = useParams(); let person = find(parseInt(id)); return ( &lt;div&gt; &lt;h3&gt;&#123;person.name&#125;’s Friends&lt;/h3&gt; &lt;ul&gt; &#123;person.friends.map(id =&gt; ( &lt;li key=&#123;id&#125;&gt; &lt;Link to=&#123;`$&#123;url&#125;/$&#123;id&#125;`&#125;&gt;&#123;find(id).name&#125;&lt;/Link&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=&#123;`$&#123;url&#125;/:id`&#125;&gt; &lt;Person /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125;const PEEPS = [ &#123; id: 0, name: \"Michelle\", friends: [1, 2, 3] &#125;, &#123; id: 1, name: \"Sean\", friends: [0, 3] &#125;, &#123; id: 2, name: \"Kim\", friends: [0, 1, 3] &#125;, &#123; id: 3, name: \"David\", friends: [1, 2] &#125;];function find(id) &#123; return PEEPS.find(p =&gt; p.id === id);&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Siderbar","slug":"react_router/examples/Siderbar","date":"2020-01-13T11:04:46.476Z","updated":"2020-01-13T11:06:27.881Z","comments":true,"path":"2020/01/13/react_router/examples/Siderbar/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Siderbar/","excerpt":"","text":"harmony1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link&#125; from \"react-router-dom\";// 每个逻辑“路线”都有两个组成部分，一个用于 //侧边栏，一个用于主区域。 我们想 //当路径与当前URL匹配。// 我们将在2中使用此路由配置 //景点：一次用于侧边栏，一次在主区域 //内容部分。 所有路线都在同一条 //将它们显示在&lt;Switch&gt;中的顺序。const routes = [ &#123; path: \"/\", exact: true, sidebar: () =&gt; &lt;div&gt;home!&lt;/div&gt;, main: () =&gt; &lt;h2&gt;Home&lt;/h2&gt; &#125;, &#123; path: \"/bubblegum\", sidebar: () =&gt; &lt;div&gt;bubblegum!&lt;/div&gt;, main: () =&gt; &lt;h2&gt;Bubblegum&lt;/h2&gt; &#125;, &#123; path: \"/shoelaces\", sidebar: () =&gt; &lt;div&gt;shoelaces!&lt;/div&gt;, main: () =&gt; &lt;h2&gt;Shoelaces&lt;/h2&gt; &#125;];export default function SidebarExample() &#123; return ( &lt;Router&gt; &lt;div style=&#123;&#123; display: \"flex\" &#125;&#125;&gt; &lt;div style=&#123;&#123; padding: \"10px\", width: \"40%\", background: \"#f0f0f0\" &#125;&#125; &gt; &lt;ul style=&#123;&#123; listStyleType: \"none\", padding: 0 &#125;&#125;&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/bubblegum\"&gt;Bubblegum&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/shoelaces\"&gt;Shoelaces&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &#123;routes.map((route, index) =&gt; ( //您可以在许多地方渲染&lt;Route&gt; //如您所愿，在您的应用中。 它将沿着 //和其他也与URL匹配的&lt;Route&gt;匹配。 //因此，侧边栏或面包屑或其他任何东西 //需要您渲染多个事物 //在同一网址的多个位置没有任何内容 //超过多个&lt;Route&gt;。 &lt;Route key=&#123;index&#125; path=&#123;route.path&#125; exact=&#123;route.exact&#125; children=&#123;&lt;route.sidebar /&gt;&#125; /&gt; ))&#125; &lt;/Switch&gt; &lt;/div&gt; &lt;div style=&#123;&#123; flex: 1, padding: \"10px\" &#125;&#125;&gt; &lt;Switch&gt; &#123;routes.map((route, index) =&gt; ( // //渲染更多具有相同路径的&lt;Route&gt; //，但这次是不同的组件。 &lt;Route key=&#123;index&#125; path=&#123;route.path&#125; exact=&#123;route.exact&#125; children=&#123;&lt;route.main /&gt;&#125; /&gt; ))&#125; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Animated_Transitions","slug":"react_router/examples/Animated_Transitions","date":"2020-01-13T11:02:47.165Z","updated":"2020-02-24T10:44:03.461Z","comments":true,"path":"2020/01/13/react_router/examples/Animated_Transitions/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Animated_Transitions/","excerpt":"","text":"harmony12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import React from \"react\";import &#123; BrowserRouter as Router, Link, useLocation&#125; from \"react-router-dom\";// React Router对 // 您应该如何解析URL查询字符串。 // // 如果您使用简单的key = value查询字符串和 // 您不需要支持IE 11，就可以使用 // 浏览器的内置URLSearchParams API。 // // 如果您的查询字符串包含数组或对象 // 语法，您可能需要自带 // 查询解析功能。export default function QueryParamsExample() &#123; return ( &lt;Router&gt; &lt;QueryParamsDemo /&gt; &lt;/Router&gt; );&#125;// 基于useLocation进行解析的自定义钩子 //您的查询字符串。function useQuery() &#123; return new URLSearchParams(useLocation().search);&#125;function QueryParamsDemo() &#123; let query = useQuery(); return ( &lt;div&gt; &lt;div&gt; &lt;h2&gt;Accounts&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/account?name=netflix\"&gt;Netflix&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/account?name=zillow-group\"&gt;Zillow Group&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/account?name=yahoo\"&gt;Yahoo&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/account?name=modus-create\"&gt;Modus Create&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Child name=&#123;query.get(\"name\")&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;function Child(&#123; name &#125;) &#123; return ( &lt;div&gt; &#123;name ? ( &lt;h3&gt; The &lt;code&gt;name&lt;/code&gt; in the query string is &amp;quot;&#123;name&#125; &amp;quot; &lt;/h3&gt; ) : ( &lt;h3&gt;There is no name in the query string&lt;/h3&gt; )&#125; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Route_Config","slug":"react_router/examples/Route_Config","date":"2020-01-13T10:59:04.757Z","updated":"2020-01-13T11:02:12.146Z","comments":true,"path":"2020/01/13/react_router/examples/Route_Config/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Route_Config/","excerpt":"","text":"harmony123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link&#125; from \"react-router-dom\";// 有些人在集中式路由配置中发现价值。路由配置只是数据。React擅长映射将数据放入组件中，而`&lt;Route&gt;`是一个组件。// 我们的路由配置只是逻辑“路由”的数组// 与`path`和`component`道具一起订购// 您在`&lt;Switch&gt;`中执行的方式。const routes = [ &#123; path: \"/sandwiches\", component: Sandwiches &#125;, &#123; path: \"/tacos\", component: Tacos, routes: [ &#123; path: \"/tacos/bus\", component: Bus &#125;, &#123; path: \"/tacos/cart\", component: Cart &#125; ] &#125;];export default function RouteConfigExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/tacos\"&gt;Tacos&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/sandwiches\"&gt;Sandwiches&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &#123;routes.map((route, i) =&gt; ( &lt;RouteWithSubRoutes key=&#123;i&#125; &#123;...route&#125; /&gt; ))&#125; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;// `&lt;Route&gt;`的特殊包装，它知道如何 //通过在“路由”中传递“子”路由 //对其呈现的组件进行支撑。function RouteWithSubRoutes(route) &#123; return ( &lt;Route path=&#123;route.path&#125; render=&#123;props =&gt; ( // 向下传递子路线以保持嵌套 &lt;route.component &#123;...props&#125; routes=&#123;route.routes&#125; /&gt; )&#125; /&gt; );&#125;function Sandwiches() &#123; return &lt;h2&gt;Sandwiches&lt;/h2&gt;;&#125;function Tacos(&#123; routes &#125;) &#123; return ( &lt;div&gt; &lt;h2&gt;Tacos&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/tacos/bus\"&gt;Bus&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/tacos/cart\"&gt;Cart&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &#123;routes.map((route, i) =&gt; ( &lt;RouteWithSubRoutes key=&#123;i&#125; &#123;...route&#125; /&gt; ))&#125; &lt;/Switch&gt; &lt;/div&gt; );&#125;function Bus() &#123; return &lt;h3&gt;Bus&lt;/h3&gt;;&#125;function Cart() &#123; return &lt;h3&gt;Cart&lt;/h3&gt;;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Modal_Gallery","slug":"react_router/examples/Modal_Gallery","date":"2020-01-13T10:52:52.158Z","updated":"2020-01-13T10:58:45.726Z","comments":true,"path":"2020/01/13/react_router/examples/Modal_Gallery/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Modal_Gallery/","excerpt":"","text":"harmony123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useHistory, useLocation, useParams&#125; from \"react-router-dom\";// 本示例说明如何渲染两个不同的屏幕（或在不同上下文中的同一屏幕）在同一URL上，取决于您到达那里的方式。// 点击“精选图片”，然后全屏查看。然后“访问图库”，然后单击颜色。注意URL和组件与以前相同，但现在我们可以看到它们在图库屏幕顶部的模态中。export default function ModalGalleryExample() &#123; return ( &lt;Router&gt; &lt;ModalSwitch /&gt; &lt;/Router&gt; );&#125;function ModalSwitch() &#123; let location = useLocation(); // 当其中一个单击图库链接。“背景”状态是其中之一时我们所在的位置单击图库链接。如果有的话将其用作`&lt;Switch&gt;`的位置，因此//我们在后台显示画廊模态 let background = location.state &amp;&amp; location.state.background; return ( &lt;div&gt; &lt;Switch location=&#123;background || location&#125;&gt; &lt;Route exact path=\"/\" children=&#123;&lt;Home /&gt;&#125; /&gt; &lt;Route path=\"/gallery\" children=&#123;&lt;Gallery /&gt;&#125; /&gt; &lt;Route path=\"/img/:id\" children=&#123;&lt;ImageView /&gt;&#125; /&gt; &lt;/Switch&gt; &#123;/* 设置背景页面时显示模式 */&#125; &#123;background &amp;&amp; &lt;Route path=\"/img/:id\" children=&#123;&lt;Modal /&gt;&#125; /&gt;&#125; &lt;/div&gt; );&#125;const IMAGES = [ &#123; id: 0, title: \"Dark Orchid\", color: \"DarkOrchid\" &#125;, &#123; id: 1, title: \"Lime Green\", color: \"LimeGreen\" &#125;, &#123; id: 2, title: \"Tomato\", color: \"Tomato\" &#125;, &#123; id: 3, title: \"Seven Ate Nine\", color: \"#789\" &#125;, &#123; id: 4, title: \"Crimson\", color: \"Crimson\" &#125;];function Thumbnail(&#123; color &#125;) &#123; return ( &lt;div style=&#123;&#123; width: 50, height: 50, background: color &#125;&#125; /&gt; );&#125;function Image(&#123; color &#125;) &#123; return ( &lt;div style=&#123;&#123; width: \"100%\", height: 400, background: color &#125;&#125; /&gt; );&#125;function Home() &#123; return ( &lt;div&gt; &lt;Link to=\"/gallery\"&gt;Visit the Gallery&lt;/Link&gt; &lt;h2&gt;Featured Images&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/img/2\"&gt;Tomato&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/img/4\"&gt;Crimson&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; );&#125;function Gallery() &#123; let location = useLocation(); return ( &lt;div&gt; &#123;IMAGES.map(i =&gt; ( &lt;Link key=&#123;i.id&#125; to=&#123;&#123; pathname: `/img/$&#123;i.id&#125;`, // 这是把戏！ 该链接集 // the `background` in location state. state: &#123; background: location &#125; &#125;&#125; &gt; &lt;Thumbnail color=&#123;i.color&#125; /&gt; &lt;p&gt;&#123;i.title&#125;&lt;/p&gt; &lt;/Link&gt; ))&#125; &lt;/div&gt; );&#125;function ImageView() &#123; let &#123; id &#125; = useParams(); let image = IMAGES[parseInt(id, 10)]; if (!image) return &lt;div&gt;Image not found&lt;/div&gt;; return ( &lt;div&gt; &lt;h1&gt;&#123;image.title&#125;&lt;/h1&gt; &lt;Image color=&#123;image.color&#125; /&gt; &lt;/div&gt; );&#125;function Modal() &#123; let history = useHistory(); let &#123; id &#125; = useParams(); let image = IMAGES[parseInt(id, 10)]; if (!image) return null; let back = e =&gt; &#123; e.stopPropagation(); history.goBack(); &#125;; return ( &lt;div onClick=&#123;back&#125; style=&#123;&#123; position: \"absolute\", top: 0, left: 0, bottom: 0, right: 0, background: \"rgba(0, 0, 0, 0.15)\" &#125;&#125; &gt; &lt;div className=\"modal\" style=&#123;&#123; position: \"absolute\", background: \"#fff\", top: 25, left: \"10%\", right: \"10%\", padding: 15, border: \"2px solid #444\" &#125;&#125; &gt; &lt;h1&gt;&#123;image.title&#125;&lt;/h1&gt; &lt;Image color=&#123;image.color&#125; /&gt; &lt;button type=\"button\" onClick=&#123;back&#125;&gt; Close &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/StaticRouter_Context","slug":"react_router/examples/StaticRouter_Context","date":"2020-01-13T10:49:24.935Z","updated":"2020-01-13T10:51:55.744Z","comments":true,"path":"2020/01/13/react_router/examples/StaticRouter_Context/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/StaticRouter_Context/","excerpt":"","text":"harmony123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React, &#123; Component &#125; from \"react\";import &#123; StaticRouter as Router, Route &#125; from \"react-router-dom\";// 本示例在StaticRouter中渲染路由并填充其路由staticContext，然后将其打印出来。在现实世界中，您会使用StaticRouter进行服务器端渲染：//// import express from \"express\";// import ReactDOMServer from \"react-dom/server\";//// const app = express()//// app.get('*', (req, res) =&gt; &#123;// let staticContext = &#123;&#125;//// let html = ReactDOMServer.renderToString(// &lt;StaticRouter location=&#123;req.url&#125; context=&#123;staticContext&#125;&gt;// &lt;App /&gt; (includes the RouteStatus component below e.g. for 404 errors)// &lt;/StaticRouter&gt;// );//// res.status(staticContext.statusCode || 200).send(html);// &#125;);//// app.listen(process.env.PORT || 3000);function RouteStatus(props) &#123; return ( &lt;Route render=&#123;(&#123; staticContext &#125;) =&gt; &#123; // 我们必须检查staticContext是否存在//，因为如果通过BrowserRouter呈现，它将是未定义的 if (staticContext) &#123; staticContext.statusCode = props.statusCode; &#125; return &lt;div&gt;&#123;props.children&#125;&lt;/div&gt;; &#125;&#125; /&gt; );&#125;function PrintContext(props) &#123; return &lt;p&gt;Static context: &#123;JSON.stringify(props.staticContext)&#125;&lt;/p&gt;;&#125;export default class StaticRouterExample extends Component &#123; // 这是我们传递给StaticRouter的上下文对象。可以通过路由进行修改以提供其他信息,用于服务器端渲染。 staticContext = &#123;&#125;; render() &#123; return ( &lt;Router location=\"/foo\" context=&#123;this.staticContext&#125;&gt; &lt;div&gt; &lt;RouteStatus statusCode=&#123;404&#125;&gt; &lt;p&gt;Route with statusCode 404&lt;/p&gt; &lt;PrintContext staticContext=&#123;this.staticContext&#125; /&gt; &lt;/RouteStatus&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Query_Paramenters","slug":"react_router/examples/Query_Paramenters","date":"2020-01-13T10:43:07.627Z","updated":"2020-01-13T10:48:36.871Z","comments":true,"path":"2020/01/13/react_router/examples/Query_Paramenters/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Query_Paramenters/","excerpt":"","text":"harmony12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React from \"react\";import &#123; BrowserRouter as Router, Link, useLocation&#125; from \"react-router-dom\";// React Router对您应该如何解析URL查询字符串。//// 如果你使用 key=value query strings and// 你不需要 支持 IE 11, 您可以使用//浏览器的内置URLSearchParams API。////如果您的查询字符串包含数组或对象语法，您可能需要自带语法查询解析功能。export default function QueryParamsExample() &#123; return ( &lt;Router&gt; &lt;QueryParamsDemo /&gt; &lt;/Router&gt; );&#125;// 基于useLocation进行解析的自定义钩子您的查询字符串。function useQuery() &#123; return new URLSearchParams(useLocation().search);&#125;function QueryParamsDemo() &#123; let query = useQuery(); return ( &lt;div&gt; &lt;div&gt; &lt;h2&gt;Accounts&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/account?name=netflix\"&gt;Netflix&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/account?name=zillow-group\"&gt;Zillow Group&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/account?name=yahoo\"&gt;Yahoo&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/account?name=modus-create\"&gt;Modus Create&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Child name=&#123;query.get(\"name\")&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;function Child(&#123; name &#125;) &#123; return ( &lt;div&gt; &#123;name ? ( &lt;h3&gt; The &lt;code&gt;name&lt;/code&gt; in the query string is &amp;quot;&#123;name&#125; &amp;quot; &lt;/h3&gt; ) : ( &lt;h3&gt;There is no name in the query string&lt;/h3&gt; )&#125; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/BrowserRouter","slug":"react_router/Api/BrowserRouter","date":"2020-01-13T08:33:34.178Z","updated":"2020-01-13T08:38:38.642Z","comments":true,"path":"2020/01/13/react_router/Api/BrowserRouter/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/BrowserRouter/","excerpt":"","text":"使用HTML5历史记录API（pushState，replaceState和popstate事件）的&lt;Router&gt;使UI与URL保持同步。 harmony12345678&lt;BrowserRouter basename=&#123;optionalString&#125; forceRefresh=&#123;optionalBool&#125; getUserConfirmation=&#123;optionalFunc&#125; keyLength=&#123;optionalNumber&#125;&gt; &lt;App /&gt;&lt;/BrowserRouter&gt; basename: string所有位置的基本URL。如果您的应用是通过服务器上的子目录提供的，则需要将其设置为子目录。格式正确的基本名称应以斜杠开头，但不能以斜杠结尾。 harmony12&lt;BrowserRouter basename=\"/calendar\" /&gt;&lt;Link to=\"/today\"/&gt; // renders &lt;a href=\"/calendar/today\"&gt; getUserConfirmation: func用于确认导航的功能。默认使用window.confirm。 harmony1234567&lt;BrowserRouter getUserConfirmation=&#123;(message, callback) =&gt; &#123; // this is the default behavior const allowTransition = window.confirm(message); callback(allowTransition); &#125;&#125;/&gt; forceRefresh: bool如果为true，则路由器将在页面导航中使用整页刷新。您可能希望使用它来模仿传统的服务器渲染应用程序在页面导航之间刷新整个页面的方式。 harmony1&lt;BrowserRouter forceRefresh=&#123;true&#125; /&gt; keyLength: numberlocation.key的长度。默认为6。 harmony1&lt;BrowserRouter keyLength=&#123;12&#125; /&gt; children: node要渲染的子元素。 注意：在React &lt;16上，您必须使用单个子元素，因为render方法不能返回多个元素。如果需要多个元素，则可以尝试将它们包装在额外的&lt;div&gt;中。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/HashRouter","slug":"react_router/Api/HashRouter","date":"2020-01-13T08:27:15.997Z","updated":"2020-01-13T08:33:19.505Z","comments":true,"path":"2020/01/13/react_router/Api/HashRouter/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/HashRouter/","excerpt":"","text":"&lt;Router&gt;使用URL的哈希部分（即window.location.hash）使UI与URL保持同步。 重要说明：哈希历史记录不支持location.key或location.state。在以前的版本中，我们尝试对行为进行匀称处理，但存在一些无法解决的极端情况。任何需要此行为的代码或插件都将无法使用。由于此技术仅旨在支持旧版浏览器，因此建议您将服务器配置为与&lt;BrowserHistory&gt;一起使用。 harmony1234567&lt;HashRouter basename=&#123;optionalString&#125; getUserConfirmation=&#123;optionalFunc&#125; hashType=&#123;optionalString&#125;&gt; &lt;App /&gt;&lt;/HashRouter&gt; basename: string所有位置的基本URL。格式正确的基本名称应以斜杠开头，但不能以斜杠结尾。 harmony12&lt;HashRouter basename=\"/calendar\"/&gt;&lt;Link to=\"/today\"/&gt; // renders &lt;a href=\"#/calendar/today\"&gt; getUserConfirmation: func用于确认导航的功能。默认使用window.confirm。 harmony1234567&lt;HashRouter getUserConfirmation=&#123;(message, callback) =&gt; &#123; // this is the default behavior const allowTransition = window.confirm(message); callback(allowTransition); &#125;&#125;/&gt; hashType: string用于window.location.hash的编码类型。可用值为： “slash”：创建＃/ 和 ＃/sunshine/lollipops之类的哈希 “slash”：创建hash # and #sunshine/lollipops “hashbang”：创建“可抓取的ajax”（Google弃用）哈希l#!/ and #!/sunshine/lollipops默认为“斜线”。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/Prompt","slug":"react_router/Api/Prompt","date":"2020-01-13T08:24:27.980Z","updated":"2020-01-13T08:25:08.197Z","comments":true,"path":"2020/01/13/react_router/Api/Prompt/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/Prompt/","excerpt":"","text":"Re-exported from core Prompt。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/MemoryRouter","slug":"react_router/Api/MemoryRouter","date":"2020-01-13T08:19:54.751Z","updated":"2020-01-13T08:24:06.731Z","comments":true,"path":"2020/01/13/react_router/Api/MemoryRouter/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/MemoryRouter/","excerpt":"","text":"一个&lt;Router&gt;，用于将“ URL”的历史记录保留在内存中（不读取或写入地址栏）。在测试和非浏览器环境（如React Native）中很有用。 harmony12345678&lt;MemoryRouter initialEntries=&#123;optionalArray&#125; initialIndex=&#123;optionalNumber&#125; getUserConfirmation=&#123;optionalFunc&#125; keyLength=&#123;optionalNumber&#125;&gt; &lt;App /&gt;&lt;/MemoryRouter&gt; initialEntries: array历史记录堆栈中的位置数组。这些可能是带有{路径名，搜索，哈希，状态}或简单字符串URL的成熟位置对象。 harmony123456&lt;MemoryRouter initialEntries=&#123;[\"/one\", \"/two\", &#123; pathname: \"/three\" &#125;]&#125; initialIndex=&#123;1&#125;&gt; &lt;App /&gt;&lt;/MemoryRouter&gt; initialIndex: number初始位置在initialEntries数组中的索引。 getUserConfirmation: func用于确认导航的功能。直接将&lt;MemoryRouter&gt;与&lt;Prompt&gt;一起使用时，必须使用此选项。 keyLength: numberlocation.key的长度。默认为6。 harmony1&lt;MemoryRouter keyLength=&#123;12&#125; /&gt; children: node要渲染的子元素。 注意：在React &lt;16上，您必须使用单个子元素，因为render方法不能返回多个元素。如果需要多个元素，则可以尝试将它们包装在额外的&lt;div&gt;中。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/StaticRouter","slug":"react_router/Api/StaticRouter","date":"2020-01-13T08:09:32.682Z","updated":"2020-01-13T08:19:14.079Z","comments":true,"path":"2020/01/13/react_router/Api/StaticRouter/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/StaticRouter/","excerpt":"","text":"永远不会更改位置的&lt;Router&gt;。 当用户实际上没有四处点击时，这在服务器端渲染方案中很有用，因此位置永远不会发生实际变化。因此，名称为：静态。当您只需要插入一个位置并在渲染输出中进行断言时，它在简单测试中也很有用。 这是一个示例节点服务器，它为&lt;Redirect&gt;发送302状态代码，并为其他请求发送常规HTML： harmony12345678910111213141516171819202122232425262728import http from \"http\";import React from \"react\";import ReactDOMServer from \"react-dom/server\";import &#123; StaticRouter &#125; from \"react-router\";http .createServer((req, res) =&gt; &#123; // This context object contains the results of the render const context = &#123;&#125;; const html = ReactDOMServer.renderToString( &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt; ); // context.url will contain the URL to redirect to if a &lt;Redirect&gt; was used if (context.url) &#123; res.writeHead(302, &#123; Location: context.url &#125;); res.end(); &#125; else &#123; res.write(html); res.end(); &#125; &#125;) .listen(3000); basename: string所有位置的基本URL。格式正确的基本名称应以斜杠开头，但不能以斜杠结尾。 harmony123&lt;StaticRouter basename=\"/calendar\"&gt; &lt;Link to=\"/today\"/&gt; // renders &lt;a href=\"/calendar/today\"&gt;&lt;/StaticRouter&gt; location: string服务器收到的URL，可能是节点服务器上的req.url。 harmony123&lt;StaticRouter location=&#123;req.url&#125;&gt; &lt;App /&gt;&lt;/StaticRouter&gt; location: object类似的位置对象{ pathname, search, hash, state } harmony123&lt;StaticRouter location=&#123;&#123; pathname: \"/bubblegum\" &#125;&#125;&gt; &lt;App /&gt;&lt;/StaticRouter&gt; context: object一个普通的JavaScript对象。在渲染期间，组件可以向对象添加属性以存储有关渲染的信息。 当&lt;Route&gt;匹配时，它将把上下文对象传递给它作为staticContext属性呈现的组件。请查看服务器渲染指南，以获取有关如何自行执行此操作的更多信息。 harmony1234const context = &#123;&#125;&lt;StaticRouter context=&#123;context&#125;&gt; &lt;App /&gt;&lt;/StaticRouter&gt; 当&lt;Route&gt;匹配时，它将把上下文对象传递给它作为staticContext属性呈现的组件。请查看服务器渲染指南，以获取有关如何自行执行此操作的更多信息。 渲染后，这些属性可用于配置服务器的响应。 harmony123if (context.status === \"404\") &#123; // ...&#125; 当&lt;Route&gt;匹配时，它将把上下文对象传递给它作为staticContext属性呈现的组件。请查看服务器渲染指南，以获取有关如何自行执行此操作的更多信息。 children: node要渲染的子元素。注意：在React &lt;16上，您必须使用单个子元素，因为render方法不能返回多个元素。如果需要多个元素，则可以尝试将它们包装在额外的&lt;div&gt;中。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/match","slug":"react_router/Api/match","date":"2020-01-13T07:49:34.704Z","updated":"2020-01-13T08:08:00.828Z","comments":true,"path":"2020/01/13/react_router/Api/match/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/match/","excerpt":"","text":"匹配对象包含有关&lt;Route path&gt;如何与URL匹配的信息。匹配对象包含以下属性： params —— (object) Key/value对从 路径的动态段对应的URL解析 isExact —— (boolean)true 如果整个URL都匹配（没有结尾字符） path —— (string) 用于匹配的路径模式。用于构建嵌套的&lt;Route&gt; url —— (string) URL的匹配部分。对于构建嵌套的&lt;Link&gt;有用 您将可以在各个地方匹配对象： Route component as this.props.match Route render as ({ match }) =&gt; () Route children as ({ match }) =&gt; () withRouter as this.props.match matchPath as the return value 如果路线没有路径，因此始终匹配，则将获得最接近的父项匹配项。路由器也是如此。 null matches即使子路径的路径与当前位置不匹配，使用子项道具的&lt;Route&gt;也会调用其子函数。在这种情况下，匹配将为空。能够在匹配时呈现&lt;Route&gt;的内容可能会很有用，但是这种情况会带来一些挑战。“解析” URL的默认方法是将match.url字符串连接到“相对”路径。 harmony1let path = `$&#123;match.url&#125;/relative-path`; 如果在匹配为null时尝试执行此操作，则最终将出现TypeError。这意味着在使用子道具时尝试在&lt;Route&gt;内部加入“相对”路径是不安全的。 当在生成空匹配对象的&lt;Route&gt;中使用无路径&lt;Route&gt;时，会发生类似但更微妙的情况。 harmony1234567891011// location.pathname = '/matches'&lt;Route path=\"/does-not-match\" children=&#123;(&#123; match &#125;) =&gt; ( // match === null &lt;Route render=&#123;(&#123; match: pathlessMatch &#125;) =&gt; ( // pathlessMatch === ??? )&#125; /&gt; )&#125;/&gt; 无路径&lt;Route&gt;从其父级继承其match对象。如果其父匹配项为null，则其匹配项也将为null。这意味着a）任何子级路由/链接都必须是绝对的，因为没有父级可以解析，并且b）父级匹配可以为null的无路径路由将需要使用子级prop进行渲染。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/withRouter","slug":"react_router/Api/withRouter","date":"2020-01-13T07:40:51.739Z","updated":"2020-01-13T07:47:15.104Z","comments":true,"path":"2020/01/13/react_router/Api/withRouter/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/withRouter/","excerpt":"","text":"您可以通过withRouter高阶组件访问历史对象的属性和最接近的&lt;Route&gt;匹配项。每当呈现时，withRouter都会将更新的匹配，位置和历史道具传递给包装的组件。 harmony12345678910111213141516171819202122import React from \"react\";import PropTypes from \"prop-types\";import &#123; withRouter &#125; from \"react-router\";// A simple component that shows the pathname of the current locationclass ShowTheLocation extends React.Component &#123; static propTypes = &#123; match: PropTypes.object.isRequired, location: PropTypes.object.isRequired, history: PropTypes.object.isRequired &#125;; render() &#123; const &#123; match, location, history &#125; = this.props; return &lt;div&gt;You are now at &#123;location.pathname&#125;&lt;/div&gt;; &#125;&#125;// Create a new component that is \"connected\" (to borrow redux// terminology) to the router.const ShowTheLocationWithRouter = withRouter(ShowTheLocation); 重要的提示 withRouter不像React Redux的connect那样订阅位置更改以进行状态更改。而是在位置更改后从&lt;Router&gt;组件传播出去后重新渲染。这意味着withRouter不会在路由转换时重新呈现，除非其父组件重新呈现。 静态方法和属性 包装组件的所有非特定于反应的静态方法和属性将自动复制到“connected”组件。 Component.WrappedComponent包装的组件在返回的组件上作为静态属性WrappedComponent公开，它可以用于隔离测试组件等。 harmony123456// MyComponent.jsexport default withRouter(MyComponent)// MyComponent.test.jsimport MyComponent from './MyComponent'render(&lt;MyComponent.WrappedComponent location=&#123;&#123;...&#125;&#125; ... /&gt;) wrappedComponentRef: func该函数将作为ref prop传递给包装的组件。 harmony1234567891011class Container extends React.Component &#123; componentDidMount() &#123; this.component.doSomething(); &#125; render() &#123; return ( &lt;MyComponent wrappedComponentRef=&#123;c =&gt; (this.component = c)&#125; /&gt; ); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/matchPath","slug":"react_router/Api/matchPath","date":"2020-01-13T07:30:00.292Z","updated":"2020-01-13T07:35:17.653Z","comments":true,"path":"2020/01/13/react_router/Api/matchPath/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/matchPath/","excerpt":"","text":"这使您可以使用&lt;Route&gt;使用的相同匹配代码，但不在正常渲染周期之内，例如在服务器上渲染之前收集数据依赖项。 harmony1234567import &#123; matchPath &#125; from \"react-router\";const match = matchPath(\"/users/123\", &#123; path: \"/users/:id\", exact: true, strict: false&#125;); pathname第一个参数是您要匹配的路径名。如果您在带有Node.js的服务器上使用它，则为req.path props第二个参数是要匹配的道具，它们与Route接受的匹配道具相同。它也可以是字符串或字符串数​​组，作为{path}的快捷方式。 harmony12345&#123; path, // like /users/:id; either a single string or an array of strings strict, // optional, defaults to false exact // optional, defaults to false&#125; returns当提供的路径名与路径属性匹配时，它将返回一个对象。 harmony12345678910111213matchPath(\"/users/2\", &#123; path: \"/users/:id\", exact: true, strict: true&#125;);// &#123;// isExact: true// params: &#123;// id: \"2\"// &#125;// path: \"/users/:id\"// url: \"/users/2\"// &#125; 如果提供的路径名与路径属性不匹配，则返回null。 harmony1234567matchPath(\"/users\", &#123; path: \"/users/:id\", exact: true, strict: true&#125;);// null","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/NavLink","slug":"react_router/Api/NavLink","date":"2020-01-13T06:59:03.209Z","updated":"2020-01-13T07:30:33.097Z","comments":true,"path":"2020/01/13/react_router/Api/NavLink/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/NavLink/","excerpt":"","text":"&lt;Link&gt;的特殊版本，当它与当前URL匹配时，它将为rendered的元素添加样式属性。 harmony1&lt;NavLink to=\"/about\"&gt;About&lt;/NavLink&gt; activeClassName: string元素处于active状态时提供的类。默认给定的类是active的。这将与className prop一起加入。 harmony123&lt;NavLink to=\"/faq\" activeClassName=\"selected\"&gt; FAQs&lt;/NavLink&gt; activeStyle: object元素处于活动状态时应用于元素的样式。 harmony123456789&lt;NavLink to=\"/faq\" activeStyle=&#123;&#123; fontWeight: \"bold\", color: \"red\" &#125;&#125;&gt; FAQs&lt;/NavLink&gt; exact: bool如果为true，则仅在位置完全匹配时才应用活动的类/样式。 harmony123&lt;NavLink exact to=\"/profile\"&gt; Profile&lt;/NavLink&gt; strict: bool如果为true，则在确定位置是否与当前URL匹配时，将考虑位置路径名上的斜杠。有关更多信息，请参见&lt;Route strict&gt;文档。 harmony123&lt;NavLink strict to=\"/events/\"&gt; Events&lt;/NavLink&gt; isActive: func一种添加额外逻辑以确定链接是否处于活动状态的功能。如果您要做的事情不仅仅是验证链接的路径名是否与当前URL的路径名匹配，则应使用此选项。 harmony1234567891011121314&lt;NavLink to=\"/events/123\" isActive=&#123;(match, location) =&gt; &#123; if (!match) &#123; return false; &#125; // only consider an event active if its event id is an odd number const eventID = parseInt(match.params.eventID); return !isNaN(eventID) &amp;&amp; eventID % 2 === 1; &#125;&#125;&gt; Event 123&lt;/NavLink&gt; location: objectisActive比较当前历史记录位置（通常是当前浏览器URL）。要与其他位置进行比较，可以传递一个位置。 aria-current: string活动链接上使用的aria-current属性的值。可用值为： “page”: 用于指示一组分页链接中的链接。 “step”: 用于指示基于步骤的过程的步骤指示器中的链接 “location”: 用于指示视觉上突出显示的图像作为流程图的当前组成部分。 “date”: 用于指示日历中的当前日期。 “time”: 用于指示时间表中的当前时间。 “true”: 用于指示NavLink是否处于活动状态默认为“page”。 基于WAI-ARIA 1.1规范","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/Link","slug":"react_router/Api/Link","date":"2020-01-13T06:26:48.825Z","updated":"2020-01-13T06:58:45.280Z","comments":true,"path":"2020/01/13/react_router/Api/Link/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/Link/","excerpt":"","text":"提供围绕应用程序的声明式，可访问的导航。 harmony1&lt;Link to=\"/about\"&gt;About&lt;/Link&gt; to: string链接位置的字符串表示形式，是通过将位置的路径名，搜索和哈希属性连接起来而创建的。 harmony1&lt;Link to=\"/courses?sort=name\" /&gt; to: object可以具有以下任何属性的对象: pathname: 表示链接到的路径的字符串。 search: query 参数的字符串表示形式。 hash: 网址中的哈希值，例如＃a-hash。 state: state位置harmony12345678&lt;Link to=&#123;&#123; pathname: \"/courses\", search: \"?sort=name\", hash: \"#the-hash\", state: &#123; fromDashboard: true &#125; &#125;&#125;/&gt; to: function当前位置作为参数传递给该函数的函数，该函数应以字符串或对象的形式返回位置表示形式harmony1&lt;Link to=&#123;location =&gt; (&#123; ...location, pathname: \"/courses\" &#125;)&#125; /&gt; harmony1&lt;Link to=&#123;location =&gt; `$&#123;location.pathname&#125;?sort=name`&#125; /&gt; replace: bool如果为true，则单击链接将替换历史记录堆栈中的当前条目，而不是添加新条目。 harmony1&lt;Link to=\"/courses\" replace /&gt; innerRef: function从React Router 5.1开始，如果您使用的是React 16，则不需要此道具，因为我们会将ref转发到基础。请改用普通ref替换。 允许访问组件的基础引用。 harmony1234567&lt;Link to=\"/\" innerRef=&#123;node =&gt; &#123; // `node` refers 为了挂载 Dom元素 // or 卸载时为null &#125;&#125;/&gt; innerRef: RefObject从React Router 5.1开始，如果您使用的是React 16，则不需要此道具，因为我们会将ref转发到基础。请改用普通ref替换。 使用React.createRef获取组件的基础引用。 harmony123let anchorRef = React.createRef()&lt;Link to=\"/\" innerRef=&#123;anchorRef&#125; /&gt; others您还可以通过props想要在&lt;a&gt;上显示的例如标题，id，className等。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/Hooks","slug":"react_router/Api/Hooks","date":"2020-01-13T06:10:51.926Z","updated":"2020-01-13T06:26:53.189Z","comments":true,"path":"2020/01/13/react_router/Api/Hooks/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/Hooks/","excerpt":"","text":"useHistoryuseHistory挂钩使您可以访问可用于导航的历史记录实例。 harmony1234567891011121314import &#123; useHistory &#125; from \"react-router-dom\";function HomeButton() &#123; let history = useHistory(); function handleClick() &#123; history.push(\"/home\") &#125; return ( &lt;button type=\"button\" onClick=&#123;handleClick&#125;&gt; Go home &lt;/button&gt;)&#125; useLocationuseLocation挂钩返回代表当前URL的位置对象。您可以像useState一样考虑它，只要URL更改，它就会返回一个新位置。 这可能非常有用，例如在您希望每次加载新页面时都使用Web分析工具触发新的“页面浏览”事件的情况下，如以下示例所示： harmony1234567891011121314151617181920212223242526import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Switch, useLocation&#125; from \"react-router-dom\";function usePageViews() &#123; let location = useLocation(); React.useEffect(() =&gt; &#123; ga.send([\"pageview\", location.pathname]); &#125;, [location]);&#125;function App() &#123; usePageViews(); return &lt;Switch&gt;...&lt;/Switch&gt;;&#125;ReactDOM.render( &lt;Router&gt; &lt;App /&gt; &lt;/Router&gt;, node); useParamsuseParams返回URL参数的键/值对的对象。使用它来访问当前的match.params。 harmony123456789101112131415161718192021222324252627import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Switch, Route, useParams&#125; from \"react-router-dom\";function BlogPost() &#123; let &#123; slug &#125; = useParams(); return &lt;div&gt;Now showing post &#123;slug&#125;&lt;/div&gt;;&#125;ReactDOM.render( &lt;Router&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;HomePage /&gt; &lt;/Route&gt; &lt;Route path=\"/blog/:slug\"&gt; &lt;BlogPost /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/Router&gt;, node); useRouteMatchuseRouteMatch挂钩尝试以与相同的方式匹配当前URL。在无需实际呈现&lt;Route&gt;的情况下访问匹配数据最有用。 现在，代替 harmony12345678910111213import &#123; Route &#125; from \"react-router-dom\";function BlogPost() &#123; return ( &lt;Route path=\"/blog/:slug\" render=&#123;(&#123; match &#125;) =&gt; &#123; // Do whatever you want with the match... return &lt;div /&gt;; &#125;&#125; /&gt; );&#125; 你也可以 harmony12345678import &#123; useRouteMatch &#125; from \"react-router-dom\";function BlogPost() &#123; let match = useRouteMatch(\"/blog/:slug\"); // Do whatever you want with the match... return &lt;div /&gt;;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/location","slug":"react_router/Api/location","date":"2020-01-10T09:13:26.126Z","updated":"2020-01-10T09:30:11.774Z","comments":true,"path":"2020/01/10/react_router/Api/location/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/Api/location/","excerpt":"","text":"locationlocation表示该应用程序现在的位置，您希望其运行的位置，甚至是以前的位置。看起来像这样： 123456789&#123; key: 'ac3df4', // not with HashHistory! pathname: '/somewhere', search: '?some=search-string', hash: '#howdy', state: &#123; [userDefined]: true &#125;&#125; 路由器提供位置对象： Route component as this.props.location Route render as ({ location }) =&gt; () Route children as ({ location }) =&gt; () withRouter as this.props.location也可以在history.location上找到它，但是您不应使用它，因为它是可变的。您可以在历史记录文档中阅读有关此内容的更多信息。位置对象永远不会发生变化，因此您可以在生命周期挂钩中使用它来确定什么时候进行导航，这对于数据获取和动画处理非常有用。12345componentWillReceiveProps(nextProps) &#123; if (nextProps.location !== this.props.location) &#123; // navigated! &#125;&#125; 您可以提供locations替换各个地方的导航： Web Link to Native Link to Redirect to history.push history.replace通常，您只使用字符串，但是如果您需要添加一些“location state”，只要应用返回到该特定位置，该状态就会可用，则可以使用位置对象代替。如果您要基于导航历史而不是仅基于路径（如模式）来分支UI，这将非常有用。 12345678910111213// usually all you need&lt;Link to=\"/somewhere\"/&gt;// but you can use a location insteadconst location = &#123; pathname: '/somewhere', state: &#123; fromDashboard: true &#125;&#125;&lt;Link to=&#123;location&#125;/&gt;&lt;Redirect to=&#123;location&#125;/&gt;history.push(location)history.replace(location) 最后，您可以将位置传递给以下组件： Route Switch 这样可以防止他们在路由器状态下使用实际位置。这对于动画和待处理的导航很有用，或者在您想要诱使组件在与真实位置不同的位置进行渲染时，这很有用。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/history","slug":"react_router/Api/history","date":"2020-01-10T08:37:10.940Z","updated":"2020-01-10T09:12:25.321Z","comments":true,"path":"2020/01/10/react_router/Api/history/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/Api/history/","excerpt":"","text":"history本文档中的术语“历史记录”和“历史记录对象”是指历史记录包，它是React Router仅有的两个主要依赖项之一（除了React本身），并提供了多种不同的实现来管理JavaScript中的会话历史记录。环境。使用的语法： “browser history”————Dom特殊的实现，在支持HTML5历史记录API的Web浏览器中很有用。 “hash history“————遗留Web浏览器的DOM特定实现。 “memory history”————内存历史记录实现，可用于测试和非DOM环境（例如React Native） 历史记录对象通常具有以下属性和方法： length ——(number) 历史记录堆栈中的条目数。 action ——(string)当前 action (PUSH, REPLACE, or POP) location ——(object) 当前位置，具有以下属性：pathname——（string）URL的路径 search——（string)URL查询字符串 hash———（string)URL哈希片段 state——（object)提供给例如当此位置被压入堆栈时，push（path，state）。仅在浏览器和内存历史记录中可用。 push(path, [state])——（function）将新条目推入历史记录堆栈 replace(path, [state]) ——(function)替换历史记录堆栈上的当前条目 go(n)——(function)将历史记录返回n个。 goBack()——(function)相当于go(-1) goForward()——(function)相当于go(1) block(prompt)——(function) 防止导航（请参阅历史记录文档）history is mutable历史对象是可变的。因此建议访问位置使用props&lt;Route&gt;的渲染，而不是history.location访问位置。这可以确保您对React的假设在生命周期挂钩中是正确的。例如： 12345678910111213class Comp extends React.Component &#123; componentDidUpdate(prevProps) &#123; // will be true const locationChanged = this.props.location !== prevProps.location; // INCORRECT, will *always* be false because history is mutable. const locationChanged = this.props.history.location !== prevProps.history.location; &#125;&#125;&lt;Route component=&#123;Comp&#125; /&gt;; 根据您所使用的实现方式，可能还会显示其他属性。请参阅历史记录文档以获取更多详细信息。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/Switch","slug":"react_router/Api/Switch","date":"2020-01-10T08:10:15.787Z","updated":"2020-01-10T08:36:09.619Z","comments":true,"path":"2020/01/10/react_router/Api/Switch/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/Api/Switch/","excerpt":"","text":"Switch渲染与位置匹配的第一个子元素&lt;Route&gt;或&lt;Redirect&gt;。 这与仅使用&lt;Route&gt;有什么不同？&lt;Switch&gt;的独特之处在于它专门呈现一条路由。相反，每个与该位置匹配的&lt;Route&gt;都将进行包含性渲染。考虑这些路线。 123456789101112131415import &#123; Route &#125; from \"react-router\";let routes = ( &lt;div&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/:user\"&gt; &lt;User /&gt; &lt;/Route&gt; &lt;Route&gt; &lt;NoMatch /&gt; &lt;/Route&gt; &lt;/div&gt;); 如果URL是/ about，则&lt;About&gt;，&lt;User&gt;和&lt;NoMatch&gt;将全部呈现，因为它们都与路径匹配。这是设计使然，允许我们以多种方式将 &lt;Route&gt;组合到我们的应用中，例如边栏和面包屑，引导程序标签等。 但是，有时我们只选择一个&lt;Route&gt;进行渲染。如果我们位于/ about，我们不想同时匹配/：user（或显示“ 404”页面）。使用Switch的方法如下： 123456789101112131415161718import &#123; Route, Switch &#125; from \"react-router\";let routes = ( &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/:user\"&gt; &lt;User /&gt; &lt;/Route&gt; &lt;Route&gt; &lt;NoMatch /&gt; &lt;/Route&gt; &lt;/Switch&gt;); 现在，如果我们位于/ about，&lt;Switch&gt;将开始寻找匹配的&lt;Route&gt;。&lt;Route path =“ / about” /&gt;将匹配，而&lt;Switch&gt;将停止寻找匹配并呈现&lt;About&gt;。同样，如果我们在/ michael位置，则会显示&lt;User&gt;。 这对于动画过渡也很有用，因为匹配的&lt;Route&gt;呈现在与上一个相同的位置。 1234567891011121314151617let routes = ( &lt;Fade&gt; &lt;Switch&gt; &#123;/* 这里只有一个child */&#125; &lt;Route /&gt; &lt;Route /&gt; &lt;/Switch&gt; &lt;/Fade&gt;);let routes = ( &lt;Fade&gt; &#123;/* 这里有两个，一个可能会变为null，但会进行过渡解决起来比较麻烦*/&#125; &lt;Route /&gt; &lt;Route /&gt; &lt;/Fade&gt;); location: object用于匹配子元素的位置对象，而不是当前历史记录位置（通常是当前浏览器URL）。 children: node&lt;Switch&gt;的所有子代应为&lt;Route&gt;或&lt;Redirect&gt;元素。仅第一个与当前位置匹配的child会被渲染。&lt;Route&gt;元素使用其路径属性进行匹配，而&lt;Redirect&gt;元素使用其from属性进行匹配。没有路径属性的&lt;Route&gt;或没有from属性的&lt;Redirect&gt;将始终与当前位置匹配。在&lt;Switch&gt;中包含&lt;Redirect&gt;时，它可以使用&lt;Route&gt;的任何位置匹配道具：path, exact, and strict。from只是路径属性的别名。如果为&lt;Switch&gt;提供了位置提示，它将覆盖匹配的子元素上的位置提示。 123456789101112131415161718import &#123; Redirect, Route, Switch &#125; from \"react-router\";let routes = ( &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/users\"&gt; &lt;Users /&gt; &lt;/Route&gt; &lt;Redirect from=\"/accounts\" to=\"/users\" /&gt; &lt;Route&gt; &lt;NoMatch /&gt; &lt;/Route&gt; &lt;/Switch&gt;);","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/Router","slug":"react_router/Api/Router","date":"2020-01-10T08:05:24.784Z","updated":"2020-01-11T08:56:31.951Z","comments":true,"path":"2020/01/10/react_router/Api/Router/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/Api/Router/","excerpt":"","text":"Router所有路由器组件的通用底层接口。通常，应用将使用高级路由器之一代替： &lt;BrowserRouter&gt; &lt;HashRouter&gt; &lt;MemoryRouter&gt; &lt;NativeRouter&gt; &lt;StaticRouter&gt; 使用底层&lt;Router&gt;的最常见用例是将自定义历史记录与状态管理库（如Redux或Mobx）进行同步。请注意，并不需要将状态管理库与React Router一起使用，它仅用于深度集成。 12345678910111213import React from \"react\";import ReactDOM from \"react-dom\";import &#123; Router &#125; from \"react-router\";import &#123; createBrowserHistory &#125; from \"source/_posts/react_router/Api/history\";const history = createBrowserHistory();ReactDOM.render( &lt;Router history=&#123;history&#125;&gt; &lt;App /&gt; &lt;/Router&gt;, node); history: object用于导航的历史对象。 1234567import React from \"react\";import ReactDOM from \"react-dom\";import &#123; createBrowserHistory &#125; from \"history\";const customHistory = createBrowserHistory();ReactDOM.render(&lt;Router history=&#123;customHistory&#125; /&gt;, node); children: node要渲染的子元素。 123 &lt;Router&gt; &lt;App /&gt;&lt;/Router&gt;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/Route","slug":"react_router/Api/Route","date":"2020-01-10T07:11:34.794Z","updated":"2020-01-10T08:04:14.469Z","comments":true,"path":"2020/01/10/react_router/Api/Route/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/Api/Route/","excerpt":"","text":"Route render methods建议使用&lt;Route&gt;渲染某些内容的方法是使用子元素，如上所示。但是，还有一些其他方法可用于使用&lt;Route&gt;渲染内容。提供这些主要是为了支持在引入hook之前使用早期版本的路由器构建的应用程序。 &lt;Route component&gt; &lt;Route render&gt; &lt;Route children&gt; function您应该在给定的上仅使用这些道具之一。请参阅下面的说明以了解它们之间的区别。 Route props所有这三种渲染方法将通过相同的三个路由道具。 match location history component一个仅在位置匹配时才呈现的React组件。它将与路线道具一起渲染。 123456789101112131415import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Route &#125; from \"react-router-dom\";// All route props (match, location and history) are available to Userfunction User(props) &#123; return &lt;h1&gt;Hello &#123;props.match.params.username&#125;!&lt;/h1&gt;;&#125;ReactDOM.render( &lt;Router&gt; &lt;Route path=\"/user/:username\" component=&#123;User&#125; /&gt; &lt;/Router&gt;, node); 当您使用组件（而不是下面的渲染器或子组件）时，路由器会使用React.createElement从给定的组件中创建一个新的React元素。这意味着，如果您向组件prop提供内联函数，则将在每个渲染中创建一个新组件。这将导致现有组件的卸载和新组件的安装，而不仅仅是更新现有组件。使用内联函数进行内联渲染时，请使用render或children道具（如下）。 render: func这样可以方便地进行内联渲染和包装，而无需进行上述不必要的重新安装。无需使用组件prop为您创建新的React元素，而是可以传递位置匹配时要调用的函数。渲染道具功能可以访问与组件渲染道具相同的所有路线道具（匹配，位置和历史）。 123456789101112131415161718192021222324252627282930313233import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Route &#125; from \"react-router-dom\";// convenient inline renderingReactDOM.render( &lt;Router&gt; &lt;Route path=\"/home\" render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125; /&gt; &lt;/Router&gt;, node);// wrapping/composing// You can spread routeProps to make them available to your rendered Componentfunction FadingRoute(&#123; component: Component, ...rest &#125;) &#123; return ( &lt;Route &#123;...rest&#125; render=&#123;routeProps =&gt; ( &lt;FadeIn&gt; &lt;Component &#123;...routeProps&#125; /&gt; &lt;/FadeIn&gt; )&#125; /&gt; );&#125;ReactDOM.render( &lt;Router&gt; &lt;FadingRoute path=\"/cool\" component=&#123;Something&#125; /&gt; &lt;/Router&gt;, node); 警告：&lt;Route组件&gt;优先于&lt;Route渲染&gt;，因此请勿在同一&lt;Route&gt;中同时使用两者。 children: func有时您需要渲染路径是否与位置匹配。在这种情况下，您可以使用child道具功能。它与render完全一样，除了是否存在匹配项而被调用。 子级渲染道具将接收与组件和渲染方法相同的所有路由道具，除非当路线未能与URL匹配时，则match为null。这使您可以根据路由是否匹配来动态调整UI。如果路线匹配，我们在此处添加一个活动班级。 123456789101112131415161718192021222324252627282930import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Link, Route&#125; from \"react-router-dom\";function ListItemLink(&#123; to, ...rest &#125;) &#123; return ( &lt;Route path=&#123;to&#125; children=&#123;(&#123; match &#125;) =&gt; ( &lt;li className=&#123;match ? \"active\" : \"\"&#125;&gt; &lt;Link to=&#123;to&#125; &#123;...rest&#125; /&gt; &lt;/li&gt; )&#125; /&gt; );&#125;ReactDOM.render( &lt;Router&gt; &lt;ul&gt; &lt;ListItemLink to=\"/somewhere\" /&gt; &lt;ListItemLink to=\"/somewhere-else\" /&gt; &lt;/ul&gt; &lt;/Router&gt;, node); 这对于动画也可能有用： 123456789&lt;Route children=&#123;(&#123; match, ...rest &#125;) =&gt; ( &#123;/* Animate will always render, so you can use lifecycles to animate its child in and out */&#125; &lt;Animate&gt; &#123;match &amp;&amp; &lt;Something &#123;...rest&#125;/&gt;&#125; &lt;/Animate&gt; )&#125;/&gt; 警告：&lt;Route children&gt;优先于&lt;Route component&gt;和&lt;Route render&gt;，因此请不要在同一&lt;Route&gt;中使用多个 path: string | string[]path-to-regexp@^1.7.0可以理解的任何有效URL路径或路径数组。 123&lt;Route path=\"/users/:id\"&gt; &lt;User /&gt;&lt;/Route&gt; 123&lt;Route path=&#123;[\"/users/:id\", \"/profile/:id\"]&#125;&gt; &lt;User /&gt;&lt;/Route&gt; 没有路径的路线总是匹配的。 exact: boolexact:true时，只有在路径与location.pathname完全匹配时才匹配 path location.pathname exact matches ? /one /one/two true no /one /one/two false yes strict: bool设置为true时，带有斜杠的路径将只匹配带有斜杠的location.pathname。当location.pathname中有其他URL段时，这无效。 123 &lt;Route strict path=\"/one/\"&gt; &lt;About /&gt;&lt;/Route&gt;| path | location.pathname | matches? || :———— | :———— | :———— ||/one/ |/one/ | no || /one/ | /one/ | yes || /one/ | /one/two | yes | 警告：strict可以用于强制location.pathname不带斜杠，但是要做到这一点，strict和精确都必须为真。 123&lt;Route exact strict path=\"/one\"&gt; &lt;About /&gt;&lt;/Route&gt; path location.pathname matches? /one/ /one/ yes /one/ /one/ no /one/ /one/two no location: object&lt;Route&gt;元素尝试将其路径与当前历史记录位置（通常是当前浏览器URL）匹配。但是，也可以传递路径名不同的位置进行匹配。 如需要将&lt;Route&gt;匹配到当前历史记录位置以外的位置时，这很有用，如Animated Transitions示例所示。 如果&lt;Route&gt;元素包装在&lt;Switch&gt;中并且与传递给&lt;Switch&gt;的位置（或当前历史记录位置）相匹配，则传递给&lt;Route&gt;的位置prop将被（在此处给出）。 sensitive: bool为true时，如果路径区分大小写，则将匹配。 123&lt;Route sensitive path=\"/one\"&gt; &lt;About /&gt;&lt;/Route&gt; path location.pathname sensitive matches? /one /one/two true no /one /one/two false yes","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/custom_link","slug":"react_router/examples/custom_link","date":"2020-01-10T06:58:03.375Z","updated":"2020-01-13T10:42:32.359Z","comments":true,"path":"2020/01/10/react_router/examples/custom_link/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/examples/custom_link/","excerpt":"","text":"harmony1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useRouteMatch&#125; from \"react-router-dom\";// 这个实力显示的是如何自定义// &lt;Link&gt; 会在url中呈现特殊内容// 与&lt;Link&gt;指向的对象相同export default function CustomLinkExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;OldSchoolMenuLink activeOnlyWhenExact=&#123;true&#125; to=\"/\" label=\"Home\" /&gt; // &lt;OldSchoolMenuLink to=\"/about\" label=\"About\" /&gt; &lt;hr /&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function OldSchoolMenuLink(&#123; label, to, activeOnlyWhenExact &#125;) &#123; let match = useRouteMatch(&#123; path: to, exact: activeOnlyWhenExact &#125;); return ( &lt;div className=&#123;match ? \"active\" : \"\"&#125;&gt; &#123;match &amp;&amp; \"&gt; \"&#125; &lt;Link to=&#123;to&#125;&gt;&#123;label&#125;&lt;/Link&gt; &lt;/div&gt; );&#125;function Home() &#123; return ( &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/div&gt; );&#125;function About() &#123; return ( &lt;div&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/redirect","slug":"react_router/examples/redirect","date":"2020-01-09T16:09:15.461Z","updated":"2020-01-09T16:10:59.700Z","comments":true,"path":"2020/01/10/react_router/examples/redirect/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/examples/redirect/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, Redirect, useHistory, useLocation&#125; from \"react-router-dom\";// 这个例子有3个页面: 一个公共的, 一个受保护的// 页面, 和一个登陆屏幕. 为了看到受保护的页面, 你必须第一次使用. 相当标准的东西.// 首先, 访问 公共页面. 然后, 访问protected页面 .你没有登陆的话, 所以你被重定向到login页面.登录后, 你被重定向返回到受保护的页面.// 注意URL每次都会变.在此刻如果你点击返回按钮, 你是否希望回到登录页面? 不! 你已经登陆了. 试试看,// 您会看到您返回到您的访问页面仅在登陆之前的页面。export default function AuthExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;AuthButton /&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/public\"&gt;Public Page&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/protected\"&gt;Protected Page&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=\"/public\"&gt; &lt;PublicPage /&gt; &lt;/Route&gt; &lt;Route path=\"/login\"&gt; &lt;LoginPage /&gt; &lt;/Route&gt; &lt;PrivateRoute path=\"/protected\"&gt; &lt;ProtectedPage /&gt; &lt;/PrivateRoute&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;const fakeAuth = &#123; isAuthenticated: false, authenticate(cb) &#123; fakeAuth.isAuthenticated = true; setTimeout(cb, 100); // fake async &#125;, signout(cb) &#123; fakeAuth.isAuthenticated = false; setTimeout(cb, 100); &#125;&#125;;function AuthButton() &#123; let history = useHistory(); return fakeAuth.isAuthenticated ? ( &lt;p&gt; Welcome!&#123;\" \"&#125; &lt;button onClick=&#123;() =&gt; &#123; fakeAuth.signout(() =&gt; history.push(\"/\")); &#125;&#125; &gt; Sign out &lt;/button&gt; &lt;/p&gt; ) : ( &lt;p&gt;You are not logged in.&lt;/p&gt; );&#125;//&lt;Route&gt;的包装器，重定向到登录屏幕，如果您尚未通过身份验证。function PrivateRoute(&#123; children, ...rest &#125;) &#123; return ( &lt;Route &#123;...rest&#125; render=&#123;(&#123; location &#125;) =&gt; fakeAuth.isAuthenticated ? ( children ) : ( &lt;Redirect to=&#123;&#123; pathname: \"/login\", state: &#123; from: location &#125; &#125;&#125; /&gt; ) &#125; /&gt; );&#125;function PublicPage() &#123; return &lt;h3&gt;Public&lt;/h3&gt;;&#125;function ProtectedPage() &#123; return &lt;h3&gt;Protected&lt;/h3&gt;;&#125;function LoginPage() &#123; let history = useHistory(); let location = useLocation(); //useLocation挂钩返回代表当前URL的位置对象。 let &#123; from &#125; = location.state || &#123; from: &#123; pathname: \"/\" &#125; &#125;; let login = () =&gt; &#123; fakeAuth.authenticate(() =&gt; &#123; history.replace(from); &#125;); &#125;; return ( &lt;div&gt; &lt;p&gt;You must log in to view the page at &#123;from.pathname&#125;&lt;/p&gt; &lt;button onClick=&#123;login&#125;&gt;Log in&lt;/button&gt; &lt;/div&gt; );&#125; 这可能非常有用，例如在您希望每次加载新页面时都使用Web分析工具触发新的“页面浏览”事件的情况下，如以下示例所示：","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/嵌套","slug":"react_router/examples/嵌套","date":"2020-01-09T14:54:50.396Z","updated":"2020-01-09T15:12:17.179Z","comments":true,"path":"2020/01/09/react_router/examples/嵌套/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/examples/%E5%B5%8C%E5%A5%97/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useParams, useRouteMatch&#125; from \"react-router-dom\";// 路线是常规的React组件, 他们可以在程序中的任何位置呈现。包含element的子元素。// 当需要对代码分割时，会有所帮助。代码分割分成多个bundle,React router与代码拆分任何其他 React app 是相同.export default function NestingExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/topics\"&gt;Topics&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/topics\"&gt; &lt;Topics /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Home() &#123; return ( &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/div&gt; );&#125;function Topics() &#123; // The `path` 让我构建 &lt;Route&gt; 路径，那是相对于父Route,而url允许让我们建立相对links let &#123; path, url &#125; = useRouteMatch(); return ( &lt;div&gt; &lt;h2&gt;Topics&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;url&#125;/rendering`&#125;&gt;Rendering with React&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;url&#125;/components`&#125;&gt;Components&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;url&#125;/props-v-state`&#125;&gt;Props v. State&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route exact path=&#123;path&#125;&gt; &lt;h3&gt;Please select a topic.&lt;/h3&gt; &lt;/Route&gt; &lt;Route path=&#123;`$&#123;path&#125;/:topicId`&#125;&gt; &lt;Topic /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125;function Topic() &#123; /* The &lt;Route&gt; 呈现此组件&lt;Route&gt;具有 `/topics/:topicId`. The `:topicId` 部分的网址表示一个占位符，我们可以从 `useParams()`获取.*/ let &#123; topicId &#125; = useParams(); return ( &lt;div&gt; &lt;h3&gt;&#123;topicId&#125;&lt;/h3&gt; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/url_parameters","slug":"react_router/examples/url_parameters","date":"2020-01-09T14:18:16.942Z","updated":"2020-01-13T08:42:53.369Z","comments":true,"path":"2020/01/09/react_router/examples/url_parameters/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/examples/url_parameters/","excerpt":"","text":"harmony12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useParams&#125; from \"react-router-dom\";&#123;/*参数是URL开头的占位符 冒号，例如`：id`在这个实例中的路线。 相似的用于匹配其他动态细分流行的Web框架，例如 Rails and Express */&#125; export default function ParamsExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;h2&gt;Accounts&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/netflix\"&gt;Netflix&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/zillow-group/3331\"&gt;Zillow Group&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/yahoo\"&gt;Yahoo&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/modus-create\"&gt;Modus Create&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=\"/:id\" children=&#123;&lt;Child /&gt;&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Child() &#123; // 我们可以在这里使用`useParams`钩子来访问 // the URL的动态片段 let &#123; id &#125; = useParams(); return ( &lt;div&gt; &lt;h3&gt;ID: &#123;id&#125;&lt;/h3&gt; &lt;/div&gt; );&#125; 123456789101112import &#123; Route &#125; from \"react-router-dom\";function BlogPost() &#123; return ( &lt;Route path=\"/blog/:slug\" render=&#123;(&#123; match &#125;) =&gt; &#123; return &lt;div /&gt;; &#125;&#125; /&gt; );&#125; 你可以 1234567import &#123; useRouteMatch &#125; from \"react-router-dom\";function BlogPost() &#123; let match = useRouteMatch(\"/blog/:slug\"); return &lt;div /&gt;;&#125; useParams返回URL参数的键/值对的对象。使用它来访问当前&lt;Route&gt;的match.params。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Basic","slug":"react_router/examples/Basic","date":"2020-01-09T14:02:48.489Z","updated":"2020-01-09T14:36:09.022Z","comments":true,"path":"2020/01/09/react_router/examples/Basic/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/examples/Basic/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link&#125; from \"react-router-dom\";&#123;/*本网站共有3页，所有页面均已呈现 在浏览器中动态显示（不呈现服务器）。尽管页面永远不会刷新，但请注意 当您浏览时，React Router使URL保持最新 通过网站. 保留 the browser history, making sure 后退按钮和书签之类的东西*/&#125; export default function BasicExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &#123;/* &lt;Switch&gt;遍历其所有子节点&lt;Route&gt; elements and renders 第一个路径 matches the current URL. 随时使用 a &lt;Switch&gt; 你有很多的routes, but you want 一个一次渲染 */&#125; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/dashboard\"&gt; &lt;Dashboard /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;// 你可以将这些组件视为页面// in your app.function Home() &#123; return ( &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/div&gt; );&#125;function About() &#123; return ( &lt;div&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;/div&gt; );&#125;function Dashboard() &#123; return ( &lt;div&gt; &lt;h2&gt;Dashboard&lt;/h2&gt; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Static_Routes","slug":"react_router/指南/Static_Routes","date":"2020-01-09T08:43:22.856Z","updated":"2020-01-09T08:44:37.778Z","comments":true,"path":"2020/01/09/react_router/指南/Static_Routes/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Static_Routes/","excerpt":"","text":"Static Routes以前版本的React Router使用静态路由来配置应用程序的路由。这样可以在渲染之前检查和匹配路线。由于v4转移到动态组件而不是路由配置，因此一些以前的用例变得不那么明显和棘手。 我们正在开发一个可与静态路由配置和React Router配合使用的软件包，以继续满足这些用例。现在正在开发中，但我们希望您能尝试一下并提供帮助。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Redux整合","slug":"react_router/指南/Redux整合","date":"2020-01-09T08:35:56.819Z","updated":"2020-01-09T08:43:04.840Z","comments":true,"path":"2020/01/09/react_router/指南/Redux整合/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Redux%E6%95%B4%E5%90%88/","excerpt":"","text":"Redux整合Redux是React生态系统的重要组成部分。对于想要同时使用React Router和Redux的人，我们希望使其无缝集成。 阻止的更新通常，React Router和Redux可以很好地协同工作。不过，有时候，应用程序的组件可能会在位置更改时（子路线或活动的导航链接不更新）不更新。 在以下情况下会发生这种情况： 1.该组件通过connect（）（Comp）连接到redux。 2.该组件不是“路由组件”，这意味着它的呈现方式不是这样：&lt;Route component = {SomeConnectedThing} /&gt; 问题在于Redux实现了shouldComponentUpdate，如果没有从路由器接收道具，则没有任何迹象表明发生了任何变化。这很容易解决。查找连接组件的位置，然后将其与Router包装在一起。 123456// beforeexport default connect(mapStateToProps)(Something)// afterimport &#123; withRouter &#125; from 'react-router-dom'export default withRouter(connect(mapStateToProps)(Something)) 深度整合有些人想： 1.与商店同步并从商店访问路由数据。 2.能够通过调度动作进行导航。 3.在Redux devtools中支持对路径更改进行时间旅行调试。 所有这些都需要更深入的集成。 我们的建议是不要将路线完全保留在Redux商店中。推理: 1.路由数据已经成为大多数关心它的组件的支持。无论是来自商店还是路由器，您组件的代码都基本相同。 2.在大多数情况下，您可以使用链接，导航链接和重定向来执行导航操作。有时，在某些最初由操作启动的异步任务之后，您可能还需要以编程方式导航。例如，您可以在用户提交登录表单时调度操作。然后，您的重击，传奇或其他异步处理程序会对凭据进行身份验证，如果成功，则需要以某种方式导航到新页面。此处的解决方案只是将历史对象（提供给所有路由组件）包括在操作的有效负载中，并且异步处理程序可以在适当的时候使用此对象进行导航。 3.路线更改对于时间旅行调试不太重要。唯一明显的情况是调试路由器/商店同步中的问题，如果根本不同步它们，则该问题将消失。 但是，如果您强烈希望与商店同步路由，则可以尝试使用Connected React Router，这是React Router v4和Redux的第三方绑定。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Testing","slug":"react_router/指南/Testing","date":"2020-01-09T08:20:30.143Z","updated":"2020-01-09T08:35:00.942Z","comments":true,"path":"2020/01/09/react_router/指南/Testing/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Testing/","excerpt":"","text":"TestingReact Router依靠React上下文来工作。这会影响您如何测试使用我们的组件的组件。 Context如果您尝试对呈现&lt;Link&gt;或&lt;Route&gt;等的组件之一进行单元测试，则会收到一些有关上下文的错误和警告。虽然您可能会想自己尝试添加路由器上下文，但是我们建议您将单元测试包装在以下路由器组件之一中：具有历史记录属性的基本路由器，或&lt;StaticRouter&gt;，&lt;MemoryRouter&gt;或&lt;BrowserRouter&gt;（如果window.history在测试环境中可用作全局变量）。 建议使用MemoryRouter或自定义历史记录，以便能够在两次测试之间重置路由器。 1234567891011121314151617181920212223242526272829303132333435class Sidebar extends Component &#123; // ... render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.toggleExpand&#125;&gt;expand&lt;/button&gt; &lt;ul&gt; &#123;users.map(user =&gt; ( &lt;li&gt; &lt;Link to=&#123;user.path&#125;&gt;&#123;user.name&#125;&lt;/Link&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;// brokentest(\"it expands when the button is clicked\", () =&gt; &#123; render(&lt;Sidebar /&gt;); click(theButton); expect(theThingToBeOpen);&#125;);// fixedtest(\"it expands when the button is clicked\", () =&gt; &#123; render( &lt;MemoryRouter&gt; &lt;Sidebar /&gt; &lt;/MemoryRouter&gt; ); click(theButton); expect(theThingToBeOpen);&#125;); 从特定路线开始&lt;MemoryRouter&gt;支持initialEntries和initialIndex道具，因此您可以在特定位置启动应用程序（或应用程序的任何较小部分）。 12345678test(\"current user is active in sidebar\", () =&gt; &#123; render( &lt;MemoryRouter initialEntries=&#123;[\"/users/2\"]&#125;&gt; &lt;Sidebar /&gt; &lt;/MemoryRouter&gt; ); expectUserToBeActive(2);&#125;); Navigating我们进行了很多测试，以检查路线在位置更改时是否有效，因此您可能不需要测试这些东西。但是，如果您需要在应用程序中测试导航，则可以这样进行： 123456789101112131415161718192021222324252627282930// app.js (a component file)import React from \"react\";import &#123; Route, Link &#125; from \"react-router-dom\";// our 项目, the App, but you can test any 子项// 部分 of your app tooconst App = () =&gt; ( &lt;div&gt; &lt;Route exact path=\"/\" render=&#123;() =&gt; ( &lt;div&gt; &lt;h1&gt;Welcome&lt;/h1&gt; &lt;/div&gt; )&#125; /&gt; &lt;Route path=\"/dashboard\" render=&#123;() =&gt; ( &lt;div&gt; &lt;h1&gt;Dashboard&lt;/h1&gt; &lt;Link to=\"/\" id=\"click-me\"&gt; Home &lt;/Link&gt; &lt;/div&gt; )&#125; /&gt; &lt;/div&gt;); 12345678910111213141516171819202122232425262728293031// 您也可以使用 a renderer like \"@testing-library/react\" or \"enzyme/mount\" hereimport &#123; render, unmountComponentAtNode &#125; from \"react-dom\";import &#123; act &#125; from 'react-dom/test-utils';import &#123; MemoryRouter &#125; from \"react-router-dom\";// app.test.jsit(\"navigates home when you click the logo\", async =&gt; &#123; // in a real test a renderer like \"@testing-library/react\" // would 负责设置 the DOM elements const root = document.createElement('div'); document.body.appendChild(root); // Render app render( &lt;MemoryRouter initialEntries=&#123;['/my/initial/route']&#125;&gt; &lt;App /&gt; &lt;MemoryRouter&gt;, root ); // 页面互动 act(() =&gt; &#123; // 查找链接（可能使用文本内容） const goHomeLink = document.querySelector('#nav-logo-home'); // Click it goHomeLink.dispatchEvent(new MouseEvent(\"click\", &#123; bubbles: true &#125;)); &#125;); // 检查显示的页面内容是否正确 expect(document.body.textContent).toBe('Home');&#125;); 检查测试中的位置您不必在测试中经常访问位置或历史记录对象，但如果这样做（例如，验证是否在url栏中设置了新的查询参数），则可以添加一条路由来更新测试中的变量： 12345678910111213141516171819202122232425262728// app.test.jstest(\"clicking filter links updates product query params\", () =&gt; &#123; let history, location; render( &lt;MemoryRouter initialEntries=&#123;[\"/my/initial/route\"]&#125;&gt; &lt;App /&gt; &lt;Route path=\"*\" render=&#123;(&#123; history, location &#125;) =&gt; &#123; history = history; location = location; return null; &#125;&#125; /&gt; &lt;/MemoryRouter&gt;, node ); act(() =&gt; &#123; // example: click a &lt;Link&gt; to /products?id=1234 &#125;); // assert about url expect(location.pathname).toBe(\"/products\"); const searchParams = new URLSearchParams(location.search); expect(searchParams.has(\"id\")).toBe(true); expect(searchParams.get(\"id\")).toEqual(\"1234\");&#125;); 备选方案 如果您的测试环境具有浏览器全局变量window.location和window.history（这是通过JSDOM在Jest中的默认设置，但您无法重置测试之间的历史记录），则也可以使用BrowserRouter。 您可以将基本路由器与历史包中的历史道具一起使用，而不是将自定义路由传递给MemoryRouter 1234567891011121314// app.test.jsimport &#123; createMemoryHistory &#125; from \"history\";import &#123; Router &#125; from \"react-router\";test(\"redirects to login page\", () =&gt; &#123; const history = createMemoryHistory(); render( &lt;Router history=&#123;history&#125;&gt; &lt;App signedInUser=&#123;null&#125; /&gt; &lt;/Router&gt;, node ); expect(history.location.pathname).toBe(\"/login\");&#125;); React测试库","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Philosophy","slug":"react_router/指南/Philosophy","date":"2020-01-09T07:45:24.676Z","updated":"2020-01-09T08:10:48.855Z","comments":true,"path":"2020/01/09/react_router/指南/Philosophy/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Philosophy/","excerpt":"","text":"Philosophy本指南的目的是说明使用React Router时要具有的思维模型。我们称之为“动态路由”，它与您可能更熟悉的“静态路由”完全不同。 静态路由如果您使用过Rails，Express，Ember，Angular等，则使用了静态路由。在这些框架中，您需要在进行任何渲染之前将路由声明为应用初始化的一部分。React Router pre-v4也是静态的（大部分是静态的）。让我们看一下如何快速配置路由： 1234567// Express Style routing:app.get(\"/\", handleIndex);app.get(\"/invoices\", handleInvoices);app.get(\"/invoices/:id\", handleInvoice);app.get(\"/invoices/:id/edit\", handleInvoiceEdit);app.listen(); 请注意在应用监听之前如何声明路由。我们使用的客户端路由器相似。在Angular中，您先声明路线，然后在渲染之前将其导入顶级AppModule： 123456789101112131415161718192021222324252627282930// Angular Style routing:const appRoutes: Routes = [ &#123; path: \"crisis-center\", component: CrisisListComponent &#125;, &#123; path: \"hero/:id\", component: HeroDetailComponent &#125;, &#123; path: \"heroes\", component: HeroListComponent, data: &#123; title: \"Heroes List\" &#125; &#125;, &#123; path: \"\", redirectTo: \"/heroes\", pathMatch: \"full\" &#125;, &#123; path: \"**\", component: PageNotFoundComponent &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(appRoutes)]&#125;)export class AppModule &#123;&#125; Ember具有常规的route.js文件，该版本会为您读取并导入到应用程序中。同样，这是在您的应用渲染之前发生的。 12345678910// Ember Style Router:Router.map(function() &#123; this.route(\"about\"); this.route(\"contact\"); this.route(\"rentals\", function() &#123; this.route(\"show\", &#123; path: \"/:rental_id\" &#125;); &#125;);&#125;);export default Router; 尽管API不同，但它们都共享“静态路由”模型。React Router也跟进了直到v4。 为了成功使用React Router，您需要忘记所有这些！：O Backstory坦率地说，我们对v2采取React Router的方向感到非常沮丧。我们（Michael和Ryan）感到受API的限制，认识到我们正在重新实现React的各个部分（生命周期等），而这与React为构建UI提供的思维模型不符。 我们正要经过车间讨论要怎么做的研讨会前的酒店走廊。我们互相问：“如果使用我们在讲习班中教授的模式建造路由器，那会是什么样？” 仅仅几个小时的开发时间，我们就获得了概念证明，我们知道这是我们想要路由的未来。我们最终得到的API并不是React的“外部”，它是由React的其余部分组成或自然地融入其中的。我们认为您会喜欢的。 动态 Routing当说动态路由时，是指在您的应用渲染时发生的路由，而不是在运行的应用之外的配置或约定中进行。这意味着几乎所有内容都是React Router中的一个组件。这是对该API的60秒回顾，以了解其工作原理： 首先，为您要定位的环境获取一个Router组件，并将其呈现在应用程序的顶部。 123456789101112// react-nativeimport &#123; NativeRouter &#125; from \"react-router-native\";// react-dom (what we'll use here)import &#123; BrowserRouter &#125; from \"react-router-dom\";ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, el); 接下来，获取链接组件以链接到新位置： 1234567const App = () =&gt; ( &lt;div&gt; &lt;nav&gt; &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt; &lt;/nav&gt; &lt;/div&gt;); 最后，渲染一个Route以在用户访问/ dashboard时显示一些UI。 12345678910const App = () =&gt; ( &lt;div&gt; &lt;nav&gt; &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt; &lt;/nav&gt; &lt;div&gt; &lt;Route path=\"/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;/div&gt; &lt;/div&gt;); 路线将渲染&lt;Dashboard {… props} /&gt;，其中道具是路由器特定的东西，看起来像{匹配，位置，历史}。如果用户不在/ dashboard上，则Route将呈现null。差不多就够了。 嵌套路线许多路由器都具有“嵌套路由”的概念。如果您使用了v4之前的React Router版本，那么您也会知道它也是如此！当您从静态路由配置转移到动态渲染的路由时，如何“嵌套路由”？好吧，如何嵌套div？ 12345678910111213141516171819const App = () =&gt; ( &lt;BrowserRouter&gt; &#123;/* here's a div */&#125; &lt;div&gt; &#123;/* here's a Route */&#125; &lt;Route path=\"/tacos\" component=&#123;Tacos&#125; /&gt; &lt;/div&gt; &lt;/BrowserRouter&gt;);// 当网址与`/ tacos`相匹配时，此组件呈现const Tacos = (&#123; match &#125;) =&gt; ( // here's a nested div &lt;div&gt; &#123;/* here's a 嵌套 Route, match.url 帮助我们建立相对的路径 */&#125; &lt;Route path=&#123;match.url + \"/carnitas\"&#125; component=&#123;Carnitas&#125; /&gt; &lt;/div&gt;); 看看路由器如何没有“嵌套” API？就像div一样，Route只是一个组件。因此，要嵌套一个Route或一个div，您只需…做就可以了。 响应路线考虑用户导航到’ /invoices ‘。您的应用程序适应不同的屏幕尺寸，它们的视口狭窄，因此您只向他们显示发票清单和发票仪表板的链接。他们可以从那里更深入地导航。 123456789101112131415161718192021222324Small Screenurl: &#x2F;invoices+----------------------+| || Dashboard || |+----------------------+| || Invoice 01 || |+----------------------+| || Invoice 02 || |+----------------------+| || Invoice 03 || |+----------------------+| || Invoice 04 || |+----------------------+ 在较大的屏幕上，我们想显示一个主从视图，其中导航在左侧，仪表板或特定发票在右侧。 123456789101112131415161718192021222324Large Screenurl: &#x2F;invoices&#x2F;dashboard+----------------------+---------------------------+| | || Dashboard | || | Unpaid: 5 |+----------------------+ || | Balance: $53,543.00 || Invoice 01 | || | Past Due: 2 |+----------------------+ || | || Invoice 02 | || | +-------------------+ |+----------------------+ | | || | | + + + | || Invoice 03 | | | + | | | || | | | | | + | + | |+----------------------+ | | | | | | | | || | +--+-+--+--+--+--+--+ || Invoice 04 | || | |+----------------------+---------------------------+ 现在暂停一分钟，并考虑两种屏幕尺寸的 /invoices 网址。它甚至是大屏幕的有效路线吗？我们应该在右边放什么？ 1234567891011121314151617181920212223Large Screenurl: &#x2F;invoices+----------------------+---------------------------+| | || Dashboard | || | |+----------------------+ || | || Invoice 01 | || | |+----------------------+ || | || Invoice 02 | ??? || | |+----------------------+ || | || Invoice 03 | || | |+----------------------+ || | || Invoice 04 | || | |+----------------------+---------------------------+ 在大屏幕上，/invoices 不是有效的路径，但在小屏幕上则是！为了使事情变得更有趣，请考虑使用大型手机的人。他们可能会纵向查看/发票，然后将手机旋转至横向。突然，我们有足够的空间来显示主从界面，因此您应该立即进行重定向！ React Router以前版本的静态路由并没有真正解决这个问题的方法。但是，当路由是动态的时，您可以声明性地组合此功能。如果您开始考虑将路由选择为UI，而不是静态配置，那么您的直觉将引导您进入以下代码 123456789101112131415161718192021222324252627282930313233343536373839const App = () =&gt; ( &lt;AppLayout&gt; &lt;Route path=\"/invoices\" component=&#123;Invoices&#125; /&gt; &lt;/AppLayout&gt;);const Invoices = () =&gt; ( &lt;Layout&gt; &#123;/* 总是显示导航 */&#125; &lt;InvoicesNav /&gt; &lt;Media query=&#123;PRETTY_SMALL&#125;&gt; &#123;screenIsSmall =&gt; screenIsSmall ? ( // 小屏幕没有重定向 &lt;Switch&gt; &lt;Route exact path=\"/invoices/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"/invoices/:id\" component=&#123;Invoice&#125; /&gt; &lt;/Switch&gt; ) : ( // 大屏幕 &lt;Switch&gt; &lt;Route exact path=\"/invoices/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"/invoices/:id\" component=&#123;Invoice&#125; /&gt; &lt;Redirect from=\"/invoices\" to=\"/invoices/dashboard\" /&gt; &lt;/Switch&gt; ) &#125; &lt;/Media&gt; &lt;/Layout&gt;); 当用户将手机从纵向旋转到横向时，此代码将自动将其重定向到仪表板。有效路线集会根据用户手中移动设备的动态性质而变化。 这只是一个例子。我们可以讨论许多其他内容，但我们将总结以下建议：为了使您的直觉与React Router的直觉相符，请考虑组件而不是静态路由。考虑一下如何使用React的声明式可组合性解决问题，因为几乎每个“ React Router问题”都可能是“ React问题”。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Scroll_Restoration","slug":"react_router/指南/Scroll_Restoration","date":"2020-01-09T06:44:18.843Z","updated":"2020-01-09T07:45:01.256Z","comments":true,"path":"2020/01/09/react_router/指南/Scroll_Restoration/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Scroll_Restoration/","excerpt":"","text":"滚动还原在早期版本的React Router中，我们提供了对滚动恢复的开箱即用的支持，从那以后人们一直在要求它。希望本文档可以帮助您从滚动条和路由中获得所需的信息！ 浏览器开始以自己的history.pushState处理滚动还原，其处理方式与使用普通浏览器导航时的处理方式相同。它已经可以在Chrome浏览器中使用，而且非常棒。这是滚动恢复规范。 由于浏览器开始处理“默认情况”，并且应用具有不同的滚动需求（例如本网站！），因此我们不提供默认滚动管理功能。本指南应帮助您实现任何滚动需求。 滚动到顶部在大多数情况下，您所需要做的只是“滚动到顶部”，因为您有一个较长的内容页面，该页面在导航到该页面时始终保持向下滚动。使用组件可以轻松处理此问题，该组件将在每次导航时向上滚动窗口： 123456789101112import &#123; useEffect &#125; from \"react\";import &#123; useLocation &#125; from \"react-router-dom\";export default function ScrollToTop() &#123; const &#123; pathname &#125; = useLocation(); useEffect(() =&gt; &#123; window.scrollTo(0, 0); &#125;, [pathname]); return null;&#125; 如果您尚未运行React 16.8，则可以使用React.Component子类执行相同的操作： 123456789101112131415161718import React from \"react\";import &#123; withRouter &#125; from \"react-router-dom\";class ScrollToTop extends React.Component &#123; componentDidUpdate(prevProps) &#123; if ( this.props.location.pathname !== prevProps.location.pathname ) &#123; window.scrollTo(0, 0); &#125; &#125; render() &#123; return null; &#125;&#125;export default withRouter(ScrollToTop); 然后将其呈现在您应用的顶部，但在路由器下方 12345678function App() &#123; return ( &lt;Router&gt; &lt;ScrollToTop /&gt; &lt;App /&gt; &lt;/Router&gt; );&#125; 如果您将标签页接口连接到路由器，那么当他们切换标签页时，您可能不想滚动到顶部。相反，关于在您需要的特定位置&lt;ScrollToTopOnMount&gt;？ 12345678910111213141516171819202122import &#123; useEffect &#125; from \"react\";function ScrollToTopOnMount() &#123; useEffect(() =&gt; &#123; window.scrollTo(0, 0); &#125;, []); return null;&#125;// Render this somewhere using:// &lt;Route path=\"...\" children=&#123;&lt;LongContent /&gt;&#125; /&gt;function LongContent() &#123; return ( &lt;div&gt; &lt;ScrollToTopOnMount /&gt; &lt;h1&gt;Here is my long content page&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;/div&gt; );&#125; 再说一次，如果您还没有运行React 16.8，则可以对React.Component子类做同样的事情： 12345678910111213141516171819202122232425class ScrollToTopOnMount extends React.Component &#123; componentDidMount() &#123; window.scrollTo(0, 0); &#125; render() &#123; return null; &#125;&#125;// Render this somewhere using:// &lt;Route path=\"...\" children=&#123;&lt;LongContent /&gt;&#125; /&gt;class LongContent extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ScrollToTopOnMount /&gt; &lt;h1&gt;Here is my long content page&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 通用解决方案对于通用解决方案（以及哪些浏览器已开始在本机实现），我们谈论的是两件事： 向上滚动导航，这样就不会启动滚动到底部的 新屏幕恢复窗口的滚动位置和“后退”和“前进”单击上的溢出元素（但不单击“链接”单击！） 在某一时刻，我们希望提供一个通用的API。这就是我们要去的方向： 12345678910111213&lt;Router&gt; &lt;ScrollRestoration&gt; &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;RestoredScroll id=\"bunny\"&gt; &lt;div style=&#123;&#123; height: \"200px\", overflow: \"auto\" &#125;&#125;&gt; I will overflow &lt;/div&gt; &lt;/RestoredScroll&gt; &lt;/div&gt; &lt;/ScrollRestoration&gt;&lt;/Router&gt; 首先，ScrollRestoration将在导航时向上滚动窗口。 其次，它将使用location.key将窗口滚动位置和RestoredScroll组件的滚动位置保存到sessionStorage。 然后，在安装ScrollRestoration或RestoredScroll组件时，它们可以从sessionStorage查找其位置。 棘手的部分是为不希望管理窗口滚动的情况定义一个“退出” API。例如，如果您在页面内容内浮动了一些标签导航，则可能不想滚动到顶部（这些标签可能会滚出视线！）。 当我们得知Chrome现在可以为我们管理滚动位置，并意识到不同的应用程序将具有不同的滚动需求时，我们有点迷失了我们需要提供某些东西的信念，尤其是当人们只想滚动到顶部时（您可以直接将其直接添加到您的应用中）。 基于此，我们不再有足够的力气自己完成工作（就像您一样，我们的时间有限！）。但是，我们很乐意为有志于实施通用解决方案的任何人提供帮助。一个可靠的解决方案甚至可以存在于项目中。如果您开始使用它，请与我们联系:)","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Code_Splitting","slug":"react_router/指南/Code_Splitting","date":"2020-01-09T06:33:56.160Z","updated":"2020-01-09T06:43:00.133Z","comments":true,"path":"2020/01/09/react_router/指南/Code_Splitting/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Code_Splitting/","excerpt":"","text":"Code Splitting网络的一项重要功能是，我们无需让访问者下载整个应用程序即可使用。您可以将代码拆分视为增量下载应用程序。为了实现这中功能我们要使用 webpack, @babel/plugin-syntax-dynamic-import, and loadable-components. webpack内置了对动态导入的支持；但是，如果您使用的是Babel（例如，将JSX编译为JavaScript），则需要使用@ babel / plugin-syntax-dynamic-import插件。这是仅语法的插件，这意味着Babel不会进行任何其他转换。该插件仅允许Babel解析动态导入，因此webpack可以将它们捆绑为代码拆分。您的.babelrc应该如下所示： 1234&#123; &quot;presets&quot;: [&quot;@babel&#x2F;preset-react&quot;], &quot;plugins&quot;: [&quot;@babel&#x2F;plugin-syntax-dynamic-import&quot;]&#125; loadable-components是用于通过动态导入加载组件的库。它自动处理各种边缘情况，并使代码拆分变得简单！这是有关如何使用可加载组件的示例： 123456789101112import loadable from \"@loadable/component\";import Loading from \"./Loading.js\";const LoadableComponent = loadable(() =&gt; import(\"./Dashboard.js\"), &#123; fallback: &lt;Loading /&gt;&#125;);export default class LoadableDashboard extends React.Component &#123; render() &#123; return &lt;LoadableComponent /&gt;; &#125;&#125; 这里所有都是它的！只需使用LoadableDashboard（或任何您命名的组件），当您在应用程序中使用它时，它将自动加载并呈现。回退是一个占位符组件，用于在加载实际组件时显示。 Code Splitting and Server-Side Renderloadable-components包含服务器端渲染的指南。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Server_Rendering","slug":"react_router/指南/Server_Rendering","date":"2020-01-09T05:36:56.725Z","updated":"2020-01-09T06:28:54.359Z","comments":true,"path":"2020/01/09/react_router/指南/Server_Rendering/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Server_Rendering/","excerpt":"","text":"服务器渲染由于服务器都是无状态的，因此在服务器上的渲染有点不同。基本思想是将应用程序包装在无状态的&lt;StaticRouter&gt;中，而不是在&lt;BrowserRouter&gt;中。我们从服务器传入请求的url，以便路由可以匹配，然后我们将讨论上下文支持。 123456789101112// 客户端&lt;BrowserRouter&gt; &lt;App/&gt;&lt;/BrowserRouter&gt;// 服务器端 (not the complete story)&lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App/&gt;&lt;/StaticRouter&gt; 当您在客户端上呈现&lt;Redirect&gt;时，浏览器历史记录会更改状态，并且我们会获得新屏幕。在静态服务器环境中，我们无法更改应用程序状态。相反，我们使用上下文道具来找出渲染的结果。如果找到context.url，则表明该应用已重定向。这使我们能够从服务器发送适当的重定向。 12345678910111213const context = &#123;&#125;;const markup = ReactDOMServer.renderToString( &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt;);if (context.url) &#123; // 某处 `&lt;Redirect&gt;` 是被重定向的 redirect(301, context.url);&#125; else &#123; // 我们很好，发送响应回复&#125; 添加特定于应用程序的上下文信息路由器仅添加context.url。但是您可能希望将某些重定向重定向为301，将其他重定向重定向为302。或者，如果呈现了UI的某些特定分支，则可能要发送404响应，如果未授权，则要发送401。上下文道具是您的，因此您可以对其进行突变。这是区分301和302重定向的一种方法： 123456789101112131415161718192021222324252627282930313233343536373839404142function RedirectWithStatus(&#123; from, to, status &#125;) &#123; return ( &lt;Route render=&#123;(&#123; staticContext &#125;) =&gt; &#123; // 客户端上没有“ staticContext”，因此 // 我们需要在这里提防 if (staticContext) staticContext.status = status; return &lt;Redirect from=&#123;from&#125; to=&#123;to&#125; /&gt;; &#125;&#125; /&gt; );&#125;// 应用中的某处function App() &#123; return ( &lt;Switch&gt; &#123;/* 其他route */&#125; &lt;RedirectWithStatus status=&#123;301&#125; from=\"/users\" to=\"/profiles\" /&gt; &lt;RedirectWithStatus status=&#123;302&#125; from=\"/courses\" to=\"/dashboard\" /&gt; &lt;/Switch&gt; );&#125;// 在服务器上const context = &#123;&#125;;const markup = ReactDOMServer.renderToString( &lt;StaticRouter context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt;);if (context.url) &#123; // 可以使用 `context.status` 因 // 我们在 RedirectWithStatus 添加了属性 redirect(context.status, context.url);&#125; 404, 401, or any other status我们可以做与上述相同的事情。创建一个添加一些上下文的组件，并将其呈现在应用程序中的任何位置以获取不同的状态代码。 12345678910function Status(&#123; code, children &#125;) &#123; return ( &lt;Route render=&#123;(&#123; staticContext &#125;) =&gt; &#123; if (staticContext) staticContext.status = code; return children; &#125;&#125; /&gt; );&#125; 现在，您可以在要将代码添加到staticContext的应用程序中的任何位置呈现状态。 12345678910111213141516171819function NotFound() &#123; return ( &lt;Status code=&#123;404&#125;&gt; &lt;div&gt; &lt;h1&gt;Sorry, can’t find that.&lt;/h1&gt; &lt;/div&gt; &lt;/Status&gt; );&#125;function App() &#123; return ( &lt;Switch&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; );&#125; Putting it all together这不是一个真正的应用程序，但是它显示了将所有内容组合在一起所需的所有常规内容。 12345678910111213141516171819202122232425262728293031import http from \"http\";import React from \"react\";import ReactDOMServer from \"react-dom/server\";import &#123; StaticRouter &#125; from \"react-router-dom\";import App from \"./App.js\";http .createServer((req, res) =&gt; &#123; const context = &#123;&#125;; const html = ReactDOMServer.renderToString( &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt; ); if (context.url) &#123; res.writeHead(301, &#123; Location: context.url &#125;); res.end(); &#125; else &#123; res.write(` &lt;!doctype html&gt; &lt;div id=\"app\"&gt;$&#123;html&#125;&lt;/div&gt; `); res.end(); &#125; &#125;) .listen(3000); 客户端 1234567891011import ReactDOM from \"react-dom\";import &#123; BrowserRouter &#125; from \"react-router-dom\";import App from \"./App.js\";ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById(\"app\")); 资料载入有许多种不同的方法，而且还没有明确的最佳实践，因此我们力求与任何一种方法融为一体，而不是规定或倾向于任何一种方法。我们相信路由器可以放入您的应用程序约束之内。 主要限制是您要在渲染之前加载数据。React Router导出其内部使用的matchPath静态函数以将位置匹配到路由。您可以在服务器上使用此功能来帮助确定呈现之前的数据依赖关系。 这种方法的要旨是依赖于静态路由配置，该配置既可以呈现您的路由，也可以在呈现之前进行匹配以确定数据依赖性。 12345678const routes = [ &#123; path: \"/\", component: Root, loadData: () =&gt; getSomeData() &#125; // etc.]; 然后使用此配置在应用中呈现您的路线： 1234567891011import &#123; routes &#125; from \"./routes.js\";function App() &#123; return ( &lt;Switch&gt; &#123;routes.map(route =&gt; ( &lt;Route &#123;...route&#125; /&gt; ))&#125; &lt;/Switch&gt; );&#125; 然后，在服务器上您将看到以下内容： 1234567891011121314151617import &#123; matchPath &#125; from \"react-router-dom\";// inside a requestconst promises = [];// use `some` to imitate `&lt;Switch&gt;` behavior of selecting only// the first to matchroutes.some(route =&gt; &#123; // use `matchPath` here const match = matchPath(req.path, route); if (match) promises.push(route.loadData(match)); return match;&#125;);Promise.all(promises).then(data =&gt; &#123; // do something w/ the data so the client // can access it then render the app&#125;); 最后，客户将需要提取数据。同样，我们不为您的应用程序规定数据加载模式，但这是您需要实现的接触点。 您可能对我们的React Router Config软件包感兴趣，以通过静态路由配置协助数据加载和服务器渲染。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Primary_Components","slug":"react_router/指南/Primary_Components","date":"2020-01-09T04:42:03.343Z","updated":"2020-01-09T05:36:06.684Z","comments":true,"path":"2020/01/09/react_router/指南/Primary_Components/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Primary_Components/","excerpt":"","text":"Primary ComponentsReact Router中的组件主要分为三类： routers,例如 and route匹配，例如 and 导航 例如 , , and 使用的web应运都应从react-router-dom导入。 import { BrowserRouter, Route, Link } from &quot;react-router-dom&quot;; RoutersRouters 每个React Router应用程序的核心应该是路由器组件。对于Web项目，react-router-dom提供 &lt;BrowserRouter&gt;和&lt;HashRouter&gt;路由器。两者之间的主要区别在于它们存储URL和与Web服务器通信的方式。 &lt;BrowserRouter&gt;使用常规URL路径。这些通常是外观最好的URL，但是它们要求正确配置服务器。具体来说，您的Web服务器需要在所有由React Router客户端管理的URL上提供相同的页面。Create React App在开发中即开即用地支持此功能，并附带有关如何配置生产服务器的说明。 &lt;HashRouter&gt;将当前位置存储在URL的哈希部分中，因此URL看起来类似于http://example.com/#/your/page。由于哈希从不发送到服务器，因此这意味着不需要特殊的服务器配置。 要使用路由器，只需确保将其呈现在元素层次结构的根目录下即可。通常，您会将顶级元素包装在路由器中，如下所示： 1234567891011121314import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter &#125; from \"react-router-dom\";function App() &#123; return &lt;h1&gt;Hello React Router&lt;/h1&gt;;&#125;ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById(\"root\")); Route Matchers有两个路由匹配组件：Switch and Route。呈现&lt;Switch&gt;时，它将搜索其子&lt;Route&gt;元素以查找其路径与当前URL匹配的元素。当找到一个时，它将呈现该&lt;Route&gt;并忽略所有其他路由。这意味着您应该将&lt;Route&gt;包含更多特定路径（通常较长）的路径放在不那么特定路径之前。 如果没有匹配，则不呈现任何内容（空） 12345678910111213141516171819202122232425262728293031323334353637383940414243import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Switch, Route&#125; from \"react-router-dom\";function App() &#123; return ( &lt;div&gt; &lt;Switch&gt; &#123;/* 如果当前URL是/ about，则呈现此路由 而其余的则被忽略 */&#125; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &#123;/* 请注意这两个路由的顺序。更具体path =\" / contact /：id\"在path =\" / contact\"之前，因此查看单个联系人时，路线将呈现 */&#125; &lt;Route path=\"/contact/:id\"&gt; &lt;Contact /&gt; &lt;/Route&gt; &lt;Route path=\"/contact\"&gt; &lt;AllContacts /&gt; &lt;/Route&gt; &#123;/* 如果先前的路线都不提供任何东西， 这条路线充当后备路线。 重要提示：路径=\" /\"的路线将*始终*匹配URL，因为所有URL均以/开头。所以那是为什么我们把这一切放在最后 */&#125; &lt;Route path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;Router&gt; &lt;App /&gt; &lt;/Router&gt;, document.getElementById(\"root\")); 需要注意的重要一件事是&lt;Route path&gt;匹配URL的开头，而不是整个开头。因此，&lt;Route path =“ /”&gt;将始终与URL匹配。因此，我们通常将此&lt;Route&gt;放在&lt;Switch&gt;的最后。另一种可能的解决方案是使用确实与整个URL匹配的&lt;Route exact path=&quot;/&quot;&gt;。 注意：尽管React Router确实支持在&lt;Switch&gt;之外渲染&lt;Route&gt;元素，但是从5.1版本开始，我们建议您改用useRouteMatch钩子。此外，我们不建议您渲染不带路径的&lt;Route&gt;，而是建议您使用钩子来访问所需的任何变量。 导航（或路线更改器）React Router提供了一个&lt;Link&gt;组件来在您的应用程序中创建链接。无论在何处呈现&lt;Link&gt;，锚点（&lt;a&gt;）都将呈现在HTML文档中。 12&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;// &lt;a href=\"/\"&gt;Home&lt;/a&gt; &lt;NavLink&gt;是&lt;Link&gt;的一种特殊类型，当其prop与当前位置匹配时，可以将其自身设置为“active”。 123456789&lt;NavLink to=\"/react\" activeClassName=\"hurray\"&gt; React&lt;/NavLink&gt;// 当 URL 是 /react, 呈现:// &lt;a href=\"/react\" className=\"hurray\"&gt;React&lt;/a&gt;// 没有设置成active，呈现：// &lt;a href=\"/react\"&gt;React&lt;/a&gt; 任何时候要强制导航，都可以给予&lt;Redirect&gt;。当&lt;Redirect&gt;呈现时，它将使用其prop进行导航。 1&lt;Redirect to=\"/login\" /&gt;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Start","slug":"react_router/指南/Start","date":"2020-01-09T04:35:40.087Z","updated":"2020-01-09T04:37:45.995Z","comments":true,"path":"2020/01/09/react_router/指南/Start/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Start/","excerpt":"","text":"快速开始npm install -g create-react-app 全局安装create-react-app create-react-app可以很方便，快速的帮你搭建react app。 npx create-react-app my-app &amp;&amp; cd my-app // 2. 创建一个react应用项目 或 npm init react-app my-app 或 yarn create react-app my-app 您可以使用npm或yarn从公共npm注册表中安装React Router。由于我们正在构建网络应用程序，因此在本指南中将使用react-router-dom。 npm install react-router-dom 第一个示例： 基本路由。 在此示例中，路由器处理了3个“页面”：主页，“关于”页面和“用户”页面。当您单击不同的&lt;Link&gt;时，路由器将呈现匹配的&lt;Route&gt;。 注意：在幕后，&lt;Link&gt;会使用真实的href渲染&lt;a&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link&#125; from \"react-router-dom\";export default function App() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/users\"&gt;Users&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &#123;/* &lt;Switch&gt;通过子&lt;Route&gt; 查找 呈现与当前URL匹配的第一个。如果有两个相同的URL只渲染一次这个路径不会渲染第二次*/&#125; &lt;Switch&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/users\"&gt; &lt;Users /&gt; &lt;/Route&gt; &lt;Route path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Home() &#123; return &lt;h2&gt;Home&lt;/h2&gt;;&#125;function About() &#123; return &lt;h2&gt;About&lt;/h2&gt;;&#125;function Users() &#123; return &lt;h2&gt;Users&lt;/h2&gt;;&#125; 第二个示例： 这个例子现实的是嵌套路由的方式。路由 ‘/topic’ 加载Topics组件，该组件将在path: id值上有条件地呈现任何其他 Route 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useRouteMatch, useParams&#125; from \"react-router-dom\";export default function App() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/topics\"&gt;Topics&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/topics\"&gt; &lt;Topics /&gt; &lt;/Route&gt; &lt;Route path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Home() &#123; return &lt;h2&gt;Home&lt;/h2&gt;;&#125;function About() &#123; return &lt;h2&gt;About&lt;/h2&gt;;&#125;function Topics() &#123; let match = useRouteMatch();//相对于父路由建立&lt;Route&gt;,而url允许建立相对的links. return ( &lt;div&gt; &lt;h2&gt;Topics&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/components`&#125;&gt;Components&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/props-v-state`&#125;&gt; Props v. State &lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &#123;/*Topics页面有自己的&lt;Switch&gt;里面又包含很多的&lt;Route&gt;,Topics里的&lt;Switch&gt;里面的路径是建立在'/topics'路径上的文件。第二个&lt;Route&gt;作为所有主题的页面或者没有主题时选择的页面 */&#125; &lt;Switch&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:topicId`&#125;&gt; &lt;Topic /&gt; &lt;/Route&gt; &lt;Route path=&#123;match.path&#125;&gt; &lt;h3&gt;Please select a topic.&lt;/h3&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125;function Topic() &#123; let &#123; topicId &#125; = useParams(); return &lt;h3&gt;Requested topic ID: &#123;topicId&#125;&lt;/h3&gt;;&#125;","categories":[],"tags":[],"keywords":[]}]}