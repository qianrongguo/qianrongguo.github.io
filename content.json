{"meta":{"title":"Title","subtitle":"","description":"","author":"just coding","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"npm/npm公开包","slug":"npm/npm公开包","date":"2020-02-06T09:22:50.920Z","updated":"2020-02-06T10:51:55.913Z","comments":true,"path":"2020/02/06/npm/npm公开包/","link":"","permalink":"http://yoursite.com/2020/02/06/npm/npm%E5%85%AC%E5%BC%80%E5%8C%85/","excerpt":"","text":"403 Forbidden - PUT https://registry.npm.taobao.org/myproject - [no_perms] Private mode enable, only admin can publish this module 提示镜像源错误： npm config set registry http://www.npmjs.org https://juejin.im/post/5c5012926fb9a049d37f81e1 创建项目mkdir my-test-project git init git remote add origin git@github.com:usename//my-test-project.git git push -u origin master 4.在项目根目录下即my-test-project目录下执行，npm init 发布npm adduser // or npm login Username: npm-user-name Password: Email: your-email 执行npm publish 关于测试更新已发布的包修改版本号 npm publish 撤销发布npm unpublish","categories":[],"tags":[],"keywords":[]},{"title":"npm/npm_link","slug":"npm/npm_link","date":"2020-02-06T08:07:40.294Z","updated":"2020-02-06T08:18:58.445Z","comments":true,"path":"2020/02/06/npm/npm_link/","link":"","permalink":"http://yoursite.com/2020/02/06/npm/npm_link/","excerpt":"","text":"https://blog.csdn.net/u014291497/article/details/75194456 如果我们想自己开发一个依赖包，在多个项目中使用它，如果直接发布到官网上固然可以，但如果修改则会非常麻烦，而且不利于在多个项目中使用。 npm link命令可以帮助我们实现这个事情 npm link 命令，这个命令的作用就是在全局环境下，生成一个符号链接文件，该文件的名字就是package.json文件中指定的模块名。同时我们对此模块的修改会实时反馈在全局目录下。 将自定义的模块与此项目连接起来。执行npm link allenModule95。 如此，我们可以在任何目录下使用该模块，并且一处修改，处处改变，节省了同步依赖包的步骤。 如果想解除项目与模块的依赖则可以在项目目录下执行npm unlink allenModule95即可。 如果想要从全局环境移除allenModule95模块链接，则可以在该模块目录下执行npm unlink allenModule95即可。","categories":[],"tags":[],"keywords":[]},{"title":"seesion/ReadME","slug":"seesion/ReadME","date":"2020-02-05T12:28:34.955Z","updated":"2020-02-05T14:02:54.484Z","comments":true,"path":"2020/02/05/seesion/ReadME/","link":"","permalink":"http://yoursite.com/2020/02/05/seesion/ReadME/","excerpt":"","text":"一、单系统登录机制 http无状态协议 web应用采用browser/server架构，http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联。这个过程用下图说明，三次请求/响应对之间没有任何联系： 但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求：要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。 会话机制， 浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联 服务器在内存中保存会话对象，浏览器怎么保存会话id呢？你可能会想到两种方式 1.请求参数 2.cookie 讲会话id作为每一个请求的参数，服务器接收请求自然能解析参数获得会话id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话id吧，每次发送http请求自动发送会话id,cookie机制正好来做这件事。cookie是浏览器用来存储少量数据的一种机制，数据以”key/value”形式存储，浏览器发送http请求时自动附带cookie信息。 tomcat会话机制当然也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为“JSESSIONID”的cookie，这就是tomcat会话机制维护的会话id,使用了cookie的请求响应过程如下图： 登录状态 有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下： 12HttpSession session = request.getSession();session.setAttribute(\"isLogin\", true); 用户再次访问时，tomcat在会话对象中查看登录状态 12HttpSession session = request.getSession();session.getAttribute(\"isLogin\"); 实现了登录状态的浏览器请求服务器模型如下图描述： 每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。 二、 多系统的复杂性web系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样 web系统有单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。 虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？ 单系统登录解决方案是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie。 既然这样，为什么不将cookie应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。 然而，可行并不代表好。共享cookie的方式存在很多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法跨语言技术水平登陆的，比如java、php、.net系统之间；第三，cookie本身不安全。 因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录 三、单点登录什么是单点登录？单点登录全称Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分 登录 相比于当系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名和密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，既得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明： 下面对上图简要描述 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数 sso认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌 sso认证中心带着令牌跳转会最初的请求地址（系统1） 系统1拿到令牌，去sso认证中心校验令牌是否有效 sso认证中心校验令牌，返回有效，注册系统1 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源 用户访问系统2的受保护资源 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数 sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌 系统2拿到令牌，去sso认证中心校验令牌是否有效 sso认证中心校验令牌，返回有效，注册系统2 系统2使用该令牌创建与用户的局部会话，返回受保护资源 用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系 局部会话存在，全局会话一定存在全局会话存在，局部会话不一定存在全局会话销毁，局部会话必须销毁 你可以通过博客园、百度、csdn、淘宝等网站的登录过程加深对单点登录的理解，注意观察登录过程中的跳转url与参数 注销 单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明： sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作， 下面对上图简要说明 用户向系统1发起注销请求 系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求 sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址 sso认证中心向所有注册系统发起注销请求 各注册系统接收sso认证中心的注销请求，销毁局部会话 sso认证中心引导用户至登录页面 四、部署图单点登录涉及sso认证中心与众子系统，子系统与sso认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成sso的客户端，sso认证中心则是sso服务端，整个单点登录过程实质是sso客户端与服务端通信的过程，用下图描述 sso认证中心与sso客户端通信方式有多种，这里以简单好用的httpClient为例，web service、rpc、restful api都可以 https://www.cnblogs.com/ywlaker/p/6113927.html","categories":[],"tags":[],"keywords":[]},{"title":"gitError","slug":"gitError","date":"2020-01-26T14:06:31.001Z","updated":"2020-01-26T14:08:19.658Z","comments":true,"path":"2020/01/26/gitError/","link":"","permalink":"http://yoursite.com/2020/01/26/gitError/","excerpt":"","text":"error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54 解决方法： 查看镜像 nrm ls npm install -g cnpm --registry=https://registry.npm.taobao.org","categories":[],"tags":[],"keywords":[]},{"title":"docker/mysqlError","slug":"docker/mysqlError","date":"2020-01-21T06:03:45.848Z","updated":"2020-01-21T06:06:31.293Z","comments":true,"path":"2020/01/21/docker/mysqlError/","link":"","permalink":"http://yoursite.com/2020/01/21/docker/mysqlError/","excerpt":"","text":"Client does not support authentication protocol requested by server; consider upgrading MySQL client 解决方法： mysql -u root -p ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;Ll123456&#39; flush privileges; 相关连接：https://medium.com/@nickhuang_1199/client-does-not-support-authentication-protocol-requested-by-server-consider-upgrading-mysql-98540705553f","categories":[],"tags":[],"keywords":[]},{"title":"NodeJS/MySQL","slug":"NodeJS/MySQL","date":"2020-01-20T12:39:09.144Z","updated":"2020-01-20T14:04:54.149Z","comments":true,"path":"2020/01/20/NodeJS/MySQL/","link":"","permalink":"http://yoursite.com/2020/01/20/NodeJS/MySQL/","excerpt":"","text":"安装MySQL驱动程序npm install mysql 建立连接123456789101112var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\");&#125;); 查询数据库12345678con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"Result: \" + result); &#125;);&#125;); 创建数据库要在MySQL中创建数据库，请使用CREATE DATABASE语句： 创建一个名为“ mydb”的数据库： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); con.query(\"CREATE DATABASE mydb\", function (err, result) &#123; if (err) throw err; console.log(\"Database created\"); &#125;);&#125;); 创建表格要在MySQL中创建表，请使用CREATE TABLE语句。确保在创建连接时定义数据库的名称。 创建一个名为“ customers”的表： 123456789101112131415161718var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); var sql = \"CREATE TABLE customers (name VARCHAR(255), address VARCHAR(255))\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"Table created\"); &#125;);&#125;); primary key创建表时，还应为每个记录创建一个具有唯一键的列。 这可以通过将列定义为INT AUTO_INCREMENT PRIMARY KEY来完成，该列将为每个记录插入一个唯一编号。从1开始，每条记录增加1。 创建表时创建主键： 123456789101112131415161718var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); var sql = \"CREATE TABLE customers (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), address VARCHAR(255))\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"Table created\"); &#125;);&#125;); 如果该表已经存在，请使用ALTER TABLE关键字： 在现有表上创建主键： 123456789101112131415161718var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); var sql = \"ALTER TABLE customers ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"Table altered\"); &#125;);&#125;); 插入表格在“customers”表中插入一条记录： 123456789101112131415161718var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); var sql = \"INSERT INTO customers (name, address) VALUES ('Company Inc', 'Highway 37')\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"1 record inserted\"); &#125;);&#125;); 插入多条记录要插入多个记录，请创建一个包含值的数组，然后在sql中插入问号，该问号将被值数组替换：INSERT INTO customers (name, address) VALUES ? 用数据填充“客户”表： 12345678910111213141516171819202122232425262728293031323334var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; console.log(\"Connected!\"); var sql = \"INSERT INTO customers (name, address) VALUES ?\"; var values = [ ['John', 'Highway 71'], ['Peter', 'Lowstreet 4'], ['Amy', 'Apple st 652'], ['Hannah', 'Mountain 21'], ['Michael', 'Valley 345'], ['Sandy', 'Ocean blvd 2'], ['Betty', 'Green Grass 1'], ['Richard', 'Sky st 331'], ['Susan', 'One way 98'], ['Vicky', 'Yellow Garden 2'], ['Ben', 'Park Lane 38'], ['William', 'Central st 954'], ['Chuck', 'Main Road 989'], ['Viola', 'Sideway 1633'] ]; con.query(sql, [values], function (err, result) &#123; if (err) throw err; console.log(\"Number of records inserted: \" + result.affectedRows); &#125;);&#125;); 结果对象执行查询时，将返回结果对象。 结果对象包含有关查询如何影响表的信息。 从上面的示例返回的结果对象如下所示： 12345678910&#123; fieldCount: 0, affectedRows: 14, insertId: 0, serverStatus: 2, warningCount: 0, message: '\\'Records:14 Duplicated: 0 Warnings: 0', protocol41: true, changedRows: 0&#125; 属性值可以这样显示 返回受影响的行数: 1console.log(result.affectedRows) 获取插入的ID对于具有自动递增ID字段的表，可以通过询问结果对象来获取刚插入的行的ID。 注意：为了能够获得插入的ID，只能插入一行。 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"INSERT INTO customers (name, address) VALUES ('Michelle', 'Blue Village 1')\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"1 record inserted, ID: \" + result.insertId); &#125;);&#125;); 查询表（select from table）1.要从MySQL中的表中选择数据，请使用“ SELECT”语句。 从“customers”表中选择所有记录，并显示结果对象： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT * FROM customers\", function (err, result, fields) &#123; if (err) throw err; console.log(result); &#125;);&#125;); SELECT 将返回所有列 2.要仅选择表中的某些列，请使用“ SELECT”语句，后跟列名 从“customers”表中选择名称和地址，并显示返回对象： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT name, address FROM customers\", function (err, result, fields) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 结果 12345678910111213141516[ &#123; name: 'John', address: 'Highway 71'&#125;, &#123; name: 'Peter', address: 'Lowstreet 4'&#125;, &#123; name: 'Amy', address: 'Apple st 652'&#125;, &#123; name: 'Hannah', address: 'Mountain 21'&#125;, &#123; name: 'Michael', address: 'Valley 345'&#125;, &#123; name: 'Sandy', address: 'Ocean blvd 2'&#125;, &#123; name: 'Betty', address: 'Green Grass 1'&#125;, &#123; name: 'Richard', address: 'Sky st 331'&#125;, &#123; name: 'Susan', address: 'One way 98'&#125;, &#123; name: 'Vicky', address: 'Yellow Garden 2'&#125;, &#123; name: 'Ben', address: 'Park Lane 38'&#125;, &#123; name: 'William', address: 'Central st 954'&#125;, &#123; name: 'Chuck', address: 'Main Road 989'&#125;, &#123; name: 'Viola', address: 'Sideway 1633'&#125;] 结果对象从上面示例的结果中可以看到，结果对象是一个包含每一行作为对象的数组。 要返回例如第三条记录的地址，只需参考第三条数组对象的address属性： 返回第三条记录的地址： 1console.log(result[2].address); 字段对象回调函数的第三个参数是一个数组，其中包含有关结果中每个字段的信息。 从“customers”表中选择所有记录，然后显示字段对象： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT name, address FROM customers\", function (err, result, fields) &#123; if (err) throw err; console.log(fields); &#125;);&#125;); 结果 12345678910111213141516171819202122232425262728293031323334[ &#123; catalog: 'def', db: 'mydb', table: 'customers', orgTable: 'customers', name: 'name', orgName: 'address', charsetNr: 33, length: 765, type: 253, flags: 0, decimals: 0, default: undefined, zeroFill: false, protocol41: true &#125;, &#123; catalog: 'def', db: 'mydb', table: 'customers', orgTable: 'customers', name: 'address', orgName: 'address', charsetNr: 33, length: 765, type: 253, flags: 0, decimals: 0, default: undefined, zeroFill: false, protocol41: true &#123;] where选择带过滤器从表中选择记录时，可以使用“ WHERE”语句过滤选择： 选择地址为“ Park Lane 38”的记录： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT * FROM customers WHERE address = 'Park Lane 38'\", function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 通配符您也可以选择以给定字母或短语开头，包含或结尾的记录。 使用’％’通配符表示零个，一个或多个字符： 选择地址以字母“ S”开头的记录： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT * FROM customers WHERE address LIKE 'S%'\", function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 转义查询值当查询值是用户提供的变量时，应转义这些值。 这是为了防止SQL注入，这是破坏或滥用数据库的常见Web黑客技术。 MySQL模块具有以下方法来转义查询值： 使用以下mysql.escape() 方法转义查询值： 123456var adr = 'Mountain 21';var sql = 'SELECT * FROM customers WHERE address = ' + mysql.escape(adr);con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result);&#125;); 通过使用占位符? 方法转义查询值： 123456var adr = 'Mountain 21';var sql = 'SELECT * FROM customers WHERE address = ?';con.query(sql, [adr], function (err, result) &#123; if (err) throw err; console.log(result);&#125;); 如果您有多个占位符，则数组按该顺序包含多个值： 1234567var name = 'Amy';var adr = 'Mountain 21';var sql = 'SELECT * FROM customers WHERE name = ? OR address = ?';con.query(sql, [name, adr], function (err, result) &#123; if (err) throw err; console.log(result);&#125;); sort result使用ORDER BY语句对结果进行升序或降序排序。 缺省情况下，ORDER BY关键字对结果进行升序排序。要按降序对结果进行排序，请使用DESC关键字。 按名称的字母顺序对结果进行排序： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT * FROM customers ORDER BY name\", function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 结果 12345678910111213141516[ &#123; id: 3, name: 'Amy', address: 'Apple st 652'&#125;, &#123; id: 11, name: 'Ben', address: 'Park Lane 38'&#125;, &#123; id: 7, name: 'Betty', address: 'Green Grass 1'&#125;, &#123; id: 13, name: 'Chuck', address: 'Main Road 989'&#125;, &#123; id: 4, name: 'Hannah', address: 'Mountain 21'&#125;, &#123; id: 1, name: 'John', address: 'Higheay 71'&#125;, &#123; id: 5, name: 'Michael', address: 'Valley 345'&#125;, &#123; id: 2, name: 'Peter', address: 'Lowstreet 4'&#125;, &#123; id: 8, name: 'Richard', address: 'Sky st 331'&#125;, &#123; id: 6, name: 'Sandy', address: 'Ocean blvd 2'&#125;, &#123; id: 9, name: 'Susan', address: 'One way 98'&#125;, &#123; id: 10, name: 'Vicky', address: 'Yellow Garden 2'&#125;, &#123; id: 14, name: 'Viola', address: 'Sideway 1633'&#125;, &#123; id: 12, name: 'William', address: 'Central st 954'&#125;] 按订单排序使用DESC关键字以降序对结果进行排序。 按name的字母顺序对结果进行反向排序： 12345678910111213141516var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; con.query(\"SELECT * FROM customers ORDER BY name DESC\", function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 结果 12345678910111213141516[ &#123; id: 12, name: 'William', address: 'Central st 954'&#125;, &#123; id: 14, name: 'Viola', address: 'Sideway 1633'&#125;, &#123; id: 10, name: 'Vicky', address: 'Yellow Garden 2'&#125;, &#123; id: 9, name: 'Susan', address: 'One way 98'&#125;, &#123; id: 6, name: 'Sandy', address: 'Ocean blvd 2'&#125;, &#123; id: 8, name: 'Richard', address: 'Sky st 331'&#125;, &#123; id: 2, name: 'Peter', address: 'Lowstreet 4'&#125;, &#123; id: 5, name: 'Michael', address: 'Valley 345'&#125;, &#123; id: 1, name: 'John', address: 'Higheay 71'&#125;, &#123; id: 4, name: 'Hannah', address: 'Mountain 21'&#125;, &#123; id: 13, name: 'Chuck', address: 'Main Road 989'&#125;, &#123; id: 7, name: 'Betty', address: 'Green Grass 1'&#125;, &#123; id: 11, name: 'Ben', address: 'Park Lane 38'&#125;, &#123; id: 3, name: 'Amy', address: 'Apple st 652'&#125;] delete删除记录您可以使用“ DELETE FROM”语句从现有表中删除记录：删除地址为“ Mountain 21”的所有记录： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"DELETE FROM customers WHERE address = 'Mountain 21'\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"Number of records deleted: \" + result.affectedRows); &#125;);&#125;); 请注意DELETE语法中的WHERE子句： WHERE子句指定应删除的记录。如果省略WHERE子句，则将删除所有记录！ 结果对象执行查询时，将返回结果对象。 结果对象包含有关查询如何影响表的信息。 从上面的示例返回的结果对象如下所示： 12345678910&#123; fieldCount: 0, affectedRows: 1, insertId: 0, serverStatus: 34, warningCount: 0, message: '', protocol41: true, changedRows: 0&#125; 属性值可以这样显示console.log(result.affectedRows) Drop Table删除表格您可以使用“ DROP TABLE”语句删除现有表： 删除表“ customers”： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"DROP TABLE customers\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(\"Table deleted\"); &#125;);&#125;); 仅在存在时drop如果您要删除的表已被删除，或者由于任何其他原因不存在，则可以使用IF EXISTS关键字来避免出现错误。删除表“ customers”（如果存在）： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"DROP TABLE IF EXISTS customers\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 如果该表存在，则结果对象将如下所示： 12345678910&#123; fieldCount: 0, affectedRows: 0, insertId: 0, serverstatus: 2, warningCount: 0, message: '', protocol41: true, changedRows: 0&#125; 如果该表不存在，则结果对象将如下所示： 12345678910&#123; fieldCount: 0, affectedRows: 0, insertId: 0, serverstatus: 2, warningCount: 1, message: '', protocol41: true, changedRows: 0&#125; 如您所见，唯一的区别是如果表不存在，则warningCount属性设置为1。 updateupdate表您可以使用“ UPDATE”语句来更新表中的现有记录： 将地址列从“ Valley 345”覆盖为“ Canyon 123”： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"UPDATE customers SET address = 'Canyon 123' WHERE address = 'Valley 345'\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result.affectedRows + \" record(s) updated\"); &#125;);&#125;); 请注意UPDATE语法中的WHERE子句： WHERE子句指定应更新的记录。如果省略WHERE子句，所有记录将被更新！ 结果对象执行查询时，将返回结果对象。 结果对象包含有关查询如何影响表的信息。 从上面的示例返回的结果对象如下所示 12345678910&#123; fieldCount: 0, affectedRows: 1, insertId: 0, serverStatus: 34, warningCount: 0, message: '(Rows matched: 1 Changed: 1 Warnings: 0', protocol41: true, changedRows: 1&#125; limit限制结果1.您可以使用“ LIMIT”语句来限制查询返回的记录数： 在“customers”表中选择前5条记录： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"SELECT * FROM customers LIMIT 5\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 从另一个位置开始2.如果要从第三条记录开始返回五条记录，则可以使用“ OFFSET”关键字： 从位置3开始，并返回接下来的5条记录： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"SELECT * FROM customers LIMIT 5 OFFSET 2\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 注意： “offset 2”表示从第三个位置开始，而不是第二个位置！ 较短的语法3.您还可以使用像这样的“ LIMIT 2、5”这样编写SQL语句，该语句返回与上面的偏移量示例相同的结果： 从位置3开始，并返回接下来的5条记录： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"SELECT * FROM customers LIMIT 2, 5\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 注意：数字是相反的：“ LIMIT 2、5”与“ LIMIT 5 OFFSET 2”相同 JOIN联接两个或更多表您可以使用JOIN语句基于两个或多个表之间的相关列来合并行。 考虑您有一个“customers”表和一个“production”表： 使用者 1234567[ &#123; id: 1, name: 'John', favorite_product: 154&#125;, &#123; id: 2, name: 'Peter', favorite_product: 154&#125;, &#123; id: 3, name: 'Amy', favorite_product: 155&#125;, &#123; id: 4, name: 'Hannah', favorite_product:&#125;, &#123; id: 5, name: 'Michael', favorite_product:&#125;] 产品展示 12345[ &#123; id: 154, name: 'Chocolate Heaven' &#125;, &#123; id: 155, name: 'Tasty Lemons' &#125;, &#123; id: 156, name: 'Vanilla Dreams' &#125;] 可以通过使用用户favorite_product字段和产品 id字段来组合这两个表。 选择两个表中都匹配的记录： 1234567891011121314151617var mysql = require('mysql');var con = mysql.createConnection(&#123; host: \"localhost\", user: \"yourusername\", password: \"yourpassword\", database: \"mydb\"&#125;);con.connect(function(err) &#123; if (err) throw err; var sql = \"SELECT users.name AS user, products.name AS favorite FROM users JOIN products ON users.favorite_product = products.id\"; con.query(sql, function (err, result) &#123; if (err) throw err; console.log(result); &#125;);&#125;); 注意：您可以使用INNER JOIN代替JOIN。他们都会给你相同的结果。 left JOIN如果要返回所有用户，无论他们是否拥有喜欢的产品，请使用LEFT JOIN语句： 选择所有用户及其喜爱的产品： 1234SELECT users.name AS user,products.name AS favoriteFROM usersLEFT JOIN products ON users.favorite_product = products.id right JOIN如果您想退回所有产品，并且将其作为收藏的用户，即使没有用户将其作为收藏，请使用RIGHT JOIN语句： 选择所有产品以及将其作为收藏的用户： 1234SELECT users.name AS user,products.name AS favoriteFROM usersRIGHT JOIN products ON users.favorite_product = products.id 结果 123456[ &#123; user: 'John', favorite: 'Chocolate Heaven' &#125;, &#123; user: 'Peter', favorite: 'Chocolate Heaven' &#125;, &#123; user: 'Amy', favorite: 'Tasty Lemons' &#125;, &#123; user: null, favorite: 'Vanilla Dreams' &#125;] 注意：没有喜欢的产品的汉娜（Hannah）和迈克尔（Michael）不包括在结果中。","categories":[],"tags":[],"keywords":[]},{"title":"面试题/javascript面试题","slug":"面试题/javascript面试题","date":"2020-01-20T12:35:56.130Z","updated":"2020-01-20T12:36:38.116Z","comments":true,"path":"2020/01/20/面试题/javascript面试题/","link":"","permalink":"http://yoursite.com/2020/01/20/%E9%9D%A2%E8%AF%95%E9%A2%98/javascript%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"href与src的区别 页面渲染","categories":[],"tags":[],"keywords":[]},{"title":"面试题/nodejs与javascript的区别","slug":"面试题/nodejs与javascript的区别","date":"2020-01-19T12:48:16.979Z","updated":"2020-01-20T12:36:38.114Z","comments":true,"path":"2020/01/19/面试题/nodejs与javascript的区别/","link":"","permalink":"http://yoursite.com/2020/01/19/%E9%9D%A2%E8%AF%95%E9%A2%98/nodejs%E4%B8%8Ejavascript%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"javascript使用了 ECMAScript 语法规范，外加Web API, 缺一不可 （web API w3c规范） DOM操作BOM操作事件绑定Ajax 请求等两者结合，即可完成浏览器端的任何操作 nodejs使用了语法规范，外加nodejs API，缺一不可处理http, 处理文件，具体参考 http://nodejs.cn/api两者结合，即可完成server端的任何操作 ECMAScript是语法规范node = ECMAScript + nodejs APIjavascript = ECMAScript + webAPI","categories":[],"tags":[],"keywords":[]},{"title":"eggjs/service","slug":"eggjs/service","date":"2020-01-16T11:38:11.668Z","updated":"2020-01-17T13:18:10.051Z","comments":true,"path":"2020/01/16/eggjs/service/","link":"","permalink":"http://yoursite.com/2020/01/16/eggjs/service/","excerpt":"","text":"npm install mysql //下载并安装mysql数据库驱动程序","categories":[],"tags":[],"keywords":[]},{"title":"NodeJS/MongoDB","slug":"NodeJS/MongoDB","date":"2020-01-14T06:48:28.400Z","updated":"2020-01-14T08:50:15.042Z","comments":true,"path":"2020/01/14/NodeJS/MongoDB/","link":"","permalink":"http://yoursite.com/2020/01/14/NodeJS/MongoDB/","excerpt":"","text":"cnpm install mongodb 创建数据库 要在MongoDB中创建数据库，请先创建一个MongoClient对象，然后使用正确的IP地址和要创建的数据库名称指定连接URL。 如果数据库不存在，MongoDB将创建该数据库并建立连接。 创建mydb数据库: 12345678var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/mydb\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; console.log(\"Database created!\"); db.close();&#125;); 重要提示：在MongoDB中，直到获得内容才创建数据库 在实际创建数据库（和集合）之前，MongoDB会等到您创建了一个集合（表）（至少包含一个文档（记录））后，再进行创建。 创建集合MongoDB中的集合与MySQL中的表相同 要在MongoDB中创建集合，请使用createCollection()方法： 创建一个名为“客户”的集合： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.createCollection(\"customers\", function(err, res) &#123; if (err) throw err; console.log(\"Collection created!\"); db.close(); &#125;);&#125;); 重要提示：在MongoDB中，只有在获得内容后才创建集合！ MongoDB等到您插入文档后才真正创建集合。 数据库操作 insert 插入集合要将记录或在MongoDB中调用的文档插入集合，我们使用insertOne（）方法。 MongoDB中的文档与MySQL中的记录相同insertOne（）方法的第一个参数是一个对象，其中包含您要插入的文档中每个字段的名称和值。它还带有一个回调函数，您可以在其中处理任何错误或插入结果：例 将文档插入“customs”集合中： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myobj = &#123; name: \"Company Inc\", address: \"Highway 37\" &#125;; dbo.collection(\"customers\").insertOne(myobj, function(err, res) &#123; if (err) throw err; console.log(\"1 document inserted\"); db.close(); &#125;);&#125;); 注意：如果您尝试在不存在的集合中插入文档，MongoDB将自动创建集合。 插入多个文档 要将多个文档插入MongoDB的集合中，我们使用insertMany()方法。 insertMany()方法的第一个参数是一个对象数组，其中包含要插入的数据。 它还带有一个回调函数，您可以在其中处理任何错误或插入结果： 在”customrs”集合插入多个文档 12345678910111213141516171819202122232425262728var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myobj = [ &#123; name: 'John', address: 'Highway 71'&#125;, &#123; name: 'Peter', address: 'Lowstreet 4'&#125;, &#123; name: 'Amy', address: 'Apple st 652'&#125;, &#123; name: 'Hannah', address: 'Mountain 21'&#125;, &#123; name: 'Michael', address: 'Valley 345'&#125;, &#123; name: 'Sandy', address: 'Ocean blvd 2'&#125;, &#123; name: 'Betty', address: 'Green Grass 1'&#125;, &#123; name: 'Richard', address: 'Sky st 331'&#125;, &#123; name: 'Susan', address: 'One way 98'&#125;, &#123; name: 'Vicky', address: 'Yellow Garden 2'&#125;, &#123; name: 'Ben', address: 'Park Lane 38'&#125;, &#123; name: 'William', address: 'Central st 954'&#125;, &#123; name: 'Chuck', address: 'Main Road 989'&#125;, &#123; name: 'Viola', address: 'Sideway 1633'&#125; ]; dbo.collection(\"customers\").insertMany(myobj, function(err, res) &#123; if (err) throw err; console.log(\"Number of documents inserted: \" + res.insertedCount); db.close(); &#125;);&#125;); 结果对象 执行insertMany（）方法时，将返回结果对象。 结果对象包含有关插入如何影响数据库的信息 从上面的示例返回的对象如下所示： 12345678910111213141516171819202122232425262728293031323334&#123; result: &#123; ok: 1, n: 14 &#125;, ops: [ &#123; name: 'John', address: 'Highway 71', _id: 58fdbf5c0ef8a50b4cdd9a84 &#125;, &#123; name: 'Peter', address: 'Lowstreet 4', _id: 58fdbf5c0ef8a50b4cdd9a85 &#125;, &#123; name: 'Amy', address: 'Apple st 652', _id: 58fdbf5c0ef8a50b4cdd9a86 &#125;, &#123; name: 'Hannah', address: 'Mountain 21', _id: 58fdbf5c0ef8a50b4cdd9a87 &#125;, &#123; name: 'Michael', address: 'Valley 345', _id: 58fdbf5c0ef8a50b4cdd9a88 &#125;, &#123; name: 'Sandy', address: 'Ocean blvd 2', _id: 58fdbf5c0ef8a50b4cdd9a89 &#125;, &#123; name: 'Betty', address: 'Green Grass 1', _id: 58fdbf5c0ef8a50b4cdd9a8a &#125;, &#123; name: 'Richard', address: 'Sky st 331', _id: 58fdbf5c0ef8a50b4cdd9a8b &#125;, &#123; name: 'Susan', address: 'One way 98', _id: 58fdbf5c0ef8a50b4cdd9a8c &#125;, &#123; name: 'Vicky', address: 'Yellow Garden 2', _id: 58fdbf5c0ef8a50b4cdd9a8d &#125;, &#123; name: 'Ben', address: 'Park Lane 38', _id: 58fdbf5c0ef8a50b4cdd9a8e &#125;, &#123; name: 'William', address: 'Central st 954', _id: 58fdbf5c0ef8a50b4cdd9a8f &#125;, &#123; name: 'Chuck', address: 'Main Road 989', _id: 58fdbf5c0ef8a50b4cdd9a90 &#125;, &#123; name: 'Viola', address: 'Sideway 1633', _id: 58fdbf5c0ef8a50b4cdd9a91 &#125; ], insertedCount: 14, insertedIds: [ 58fdbf5c0ef8a50b4cdd9a84, 58fdbf5c0ef8a50b4cdd9a85, 58fdbf5c0ef8a50b4cdd9a86, 58fdbf5c0ef8a50b4cdd9a87, 58fdbf5c0ef8a50b4cdd9a88, 58fdbf5c0ef8a50b4cdd9a89, 58fdbf5c0ef8a50b4cdd9a8a, 58fdbf5c0ef8a50b4cdd9a8b, 58fdbf5c0ef8a50b4cdd9a8c, 58fdbf5c0ef8a50b4cdd9a8d, 58fdbf5c0ef8a50b4cdd9a8e, 58fdbf5c0ef8a50b4cdd9a8f 58fdbf5c0ef8a50b4cdd9a90, 58fdbf5c0ef8a50b4cdd9a91 ]&#125;属性值可以这样显示： 返回插入的文档数： 1console.log(res.insertedCount) _id字段 如果您未指定_id字段，则MongoDB将为您添加一个，并为每个文档分配唯一的ID。 在上面的示例中，没有指定_id字段，从结果对象可以看到，MongoDB为每个文档分配了唯一的_id。 如果确实指定_id字段，则每个文档的值必须唯一： 在带有指定_id字段的“products”表中插入三个记录： 1234567891011121314151617var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myobj = [ &#123; _id: 154, name: 'Chocolate Heaven'&#125;, &#123; _id: 155, name: 'Tasty Lemon'&#125;, &#123; _id: 156, name: 'Vanilla Dream'&#125; ]; dbo.collection(\"products\").insertMany(myobj, function(err, res) &#123; if (err) throw err; console.log(res); db.close(); &#125;);&#125;); Find 在MongoDB中，我们使用find和findOne方法在集合中查找数据。就像SELECT语句用于在MySQL数据库的表中查找数据一样。 Find One 要从MongoDB中的集合中选择数据，我们可以使用findOne（）方法。 findOne（）方法返回选择中的第一个匹配项。 findOne（）方法的第一个参数是查询对象。在此示例中，我们使用一个空的查询对象，该对象选择集合中的所有文档（但仅返回第一个文档）。 在客户集合中找到第一个文档： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").findOne(&#123;&#125;, function(err, result) &#123; if (err) throw err; console.log(result.name); db.close(); &#125;);&#125;); Find All 要从MongoDB中的表中选择数据，我们还可以使用find（）方法。 find（）方法返回选择中的所有匹配项。 find（）方法的第一个参数是查询对象。在此示例中，我们使用一个空的查询对象，该对象选择集合中的所有文档。 查找customs集合中的所有文档： 1234567891011var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").find(&#123;&#125;).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;); Find Some find（）方法的第二个参数是投影对象，它描述要在结果中包括哪些字段。 此参数是可选的，如果省略，则所有字段都将包含在结果中。 返回客户集合中所有文档的“名称”和“地址”字段： 1234567891011var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").find(&#123;&#125;, &#123; projection: &#123; _id: 0, name: 1, address: 1 &#125; &#125;).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 您不允许在同一对象中同时指定0和1值（除非其中一个字段是_id字段）。如果您指定值为0的字段，则所有其他字段的值为1，反之亦然： 此示例将从结果中排除“地址”： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").find(&#123;&#125;, &#123; projection: &#123; address: 0 &#125; &#125;).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;);要排除_id字段，必须将其值设置为0： 如果在同一对象中同时指定0和1值，则会出现错误（除非其中一个字段是_id字段）： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").find(&#123;&#125;, &#123; projection: &#123; name: 1, address: 0 &#125; &#125;).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 结果对象从上面示例的结果可以看出，可以将结果转换为包含每个文档作为对象的数组。要返回例如第三个文档的地址，只需引用第三个数组对象的address属性： 返回第三个文档的地址： 1console.log(result[2].address); queryFilter 结果在集合中查找文档时，可以使用查询对象过滤结果。 find（）方法的第一个参数是查询对象，用于限制搜索。 查找address“ Park Lane 38”的文档： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var query = &#123; address: \"Park Lane 38\" &#125;; dbo.collection(\"customers\").find(query).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 用正则表达式过滤您可以编写正则表达式以准确查找要搜索的内容。 正则表达式只能用于查询字符串。 要仅查找“address”字段以字母“ S”开头的文档，请使用正则表达式/ ^ S /： 查找地址以字母“ S”开头的文档： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var query = &#123; address: /^S/ &#125;; dbo.collection(\"customers\").find(query).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 排序结果使用sort（）方法对结果进行升序或降序排序。 sort（）方法采用一个参数，这是一个定义排序顺序的对象。 按名称的字母顺序对结果进行排序： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var mysort = &#123; name: 1 &#125;; dbo.collection(\"customers\").find().sort(mysort).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 降序排列在排序对象中使用值-1进行降序排序。 12&#123; name: 1 &#125; // ascending&#123; name: -1 &#125; // descending 按名称的字母顺序对结果进行反向排序： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var mysort = &#123; name: -1 &#125;; dbo.collection(\"customers\").find().sort(mysort).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); delete删除文件要删除在MongoDB中调用的记录或文档，我们使用deleteOne（）方法。 deleteOne（）方法的第一个参数是一个查询对象，用于定义要删除的文档 注意：如果查询找到多个文档，则仅删除第一次出现的文档。 删除address “Mountain 21” 的文档： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myquery = &#123; address: 'Mountain 21' &#125;; dbo.collection(\"customers\").deleteOne(myquery, function(err, obj) &#123; if (err) throw err; console.log(\"1 document deleted\"); db.close(); &#125;);&#125;); 删除许多要删除多个文档，请使用deleteMany（）方法。 deleteMany（）方法的第一个参数是一个查询对象，用于定义要删除的文档。 删除地址以字母“ O”开头的所有文档： 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myquery = &#123; address: /^O/ &#125;; dbo.collection(\"customers\").deleteMany(myquery, function(err, obj) &#123; if (err) throw err; console.log(obj.result.n + \" document(s) deleted\"); db.close(); &#125;);&#125;); 结果对象deleteMany（）方法返回一个对象，该对象包含有关执行如何影响数据库的信息。 大多数信息不是很重要，但该对象内部的一个对象称为“结果”，它告诉我们执行是否正常以及有多少文档受到影响 结果对象如下所示： 1&#123; n: 2, ok: 1 &#125; 您可以使用此对象返回已删除文档的数量： 返回已删除文档的数量： 1console.log(obj.result.n); drop集合您可以使用drop（）方法删除表或在MongoDB中调用的集合。 drop（）方法采用一个回调函数，该函数包含错误对象和result参数，如果成功删除了集合，则返回true，否则返回false。 删除”customs”表： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").drop(function(err, delOK) &#123; if (err) throw err; if (delOK) console.log(\"Collection deleted\"); db.close(); &#125;);&#125;); db.dropCollection您也可以使用dropCollection（）方法删除表（集合）。 dropCollection（）方法采用两个参数：集合的名称和回调函数。 使用dropCollection（）删除“customs”集合： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.dropCollection(\"customers\", function(err, delOK) &#123; if (err) throw err; if (delOK) console.log(\"Collection deleted\"); db.close(); &#125;);&#125;); 更新文件您可以使用updateOne（）方法更新记录或在MongoDB中调用的文档。 updateOne（）方法的第一个参数是一个查询对象，用于定义要更新的文档。 注意：如果查询找到多个记录，则仅更新第一个记录。 第二个参数是定义文档新值的对象。 使用address=”Valley 345”将文档更新为name =”Mickey”和address =”Canyon 123”： 1234567891011121314var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://127.0.0.1:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myquery = &#123; address: \"Valley 345\" &#125;; var newvalues = &#123; $set: &#123;name: \"Mickey\", address: \"Canyon 123\" &#125; &#125;; dbo.collection(\"customers\").updateOne(myquery, newvalues, function(err, res) &#123; if (err) throw err; console.log(\"1 document updated\"); db.close(); &#125;);&#125;); 仅更新特定字段使用$set运算符时，仅更新指定的字段： 将address =”Valley 345”更新为”Canyon 123”： 123var myquery = &#123; address: \"Valley 345\" &#125;; var newvalues = &#123; $set: &#123; address: \"Canyon 123\" &#125; &#125;; dbo.collection(\"customers\").updateOne(myquery, newvalues, function(err, res) &#123; 更新许多文件要更新所有符合查询条件的文档，请使用updateMany（）方法。 更新名称以字母“ S”开头的所有文档： 1234567891011121314var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://127.0.0.1:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myquery = &#123; address: /^S/ &#125;; var newvalues = &#123;$set: &#123;name: \"Minnie\"&#125; &#125;; dbo.collection(\"customers\").updateMany(myquery, newvalues, function(err, res) &#123; if (err) throw err; console.log(res.result.nModified + \" document(s) updated\"); db.close(); &#125;);&#125;); 结果对象updateOne（）和updateMany（）方法返回一个对象，该对象包含有关执行如何影响数据库的信息。 大多数信息并不是很重要，但对象内部的一个对象称为“结果”，它告诉我们执行是否正常以及受影响的文档数量。 结果对象如下所示： 1&#123; n: 1, nModified: 2, ok: 1 &#125; 您可以使用此对象返回更新的文档数： 返回更新的文档数： 1console.log(res.result.nModified); limit限制结果为了限制MongoDB中的结果，我们使用limit（）方法。 limit（）方法采用一个参数，一个数字定义要返回的文档数。 考虑您有一个”customs”集合： 将结果限制为仅返回5个文档： 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection(\"customers\").find().limit(5).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); joinjoin集合MongoDB不是关联数据库，但是您可以使用$lookup阶段执行左外部联接。 通过$lookup阶段，您可以指定要与当前集合一起加入的集合以及应该匹配的字段。 考虑您有一个”orders”集合和一个”products”集合： orders [ { _id: 1, product_id: 154, status: 1 } ] products [ { _id: 154, name: &apos;Chocolate Heaven&apos; }, { _id: 155, name: &apos;Tasty Lemons&apos; }, { _id: 156, name: &apos;Vanilla Dreams&apos; } ]将匹配的“products”文档加入“orders”集合： 1234567891011121314151617181920var url = \"mongodb://127.0.0.1:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection('orders').aggregate([ &#123; $lookup: &#123; from: 'products', localField: 'product_id', foreignField: '_id', as: 'orderdetails' &#125; &#125; ]).toArray(function(err, res) &#123; if (err) throw err; console.log(JSON.stringify(res)); db.close(); &#125;);&#125;); 从上面的结果可以看到，产品集合中的匹配文档以数组的形式包含在订单集合中。","categories":[],"tags":[],"keywords":[]},{"title":"docker/mongoDBError","slug":"docker/mongoDBError","date":"2020-01-14T06:32:36.186Z","updated":"2020-01-21T06:07:21.488Z","comments":true,"path":"2020/01/14/docker/mongoDBError/","link":"","permalink":"http://yoursite.com/2020/01/14/docker/mongoDBError/","excerpt":"","text":"[root@test3] # docker run -itd –name mongo -p 27017:27017 mongo –auth Error response from daemon: Conflict. The container name &quot;/mysql-server&quot; is already in use by container bdc8d8c475cb86695c466d23fd7102221f2c040898c2d576f94cd06c93ca811b. You have to remove (or rename) that container to be able to reuse that name..See &apos;/usr/bin/docker-current run --help&apos;. 1.docker ps 2.docker ps -l 3.docker rm bdc8d8c475cbhttps://blog.csdn.net/972301/article/details/80915127https://thispointer.com/docker-how-to-stop-remove-a-running-container-by-id-or-name/","categories":[],"tags":[],"keywords":[]},{"title":"docker/error","slug":"docker/error","date":"2020-01-14T06:32:36.000Z","updated":"2020-01-14T09:46:45.000Z","comments":true,"path":"2020/01/14/docker/error/","link":"","permalink":"http://yoursite.com/2020/01/14/docker/error/","excerpt":"","text":"[root@test3] # docker run -itd –name mongo -p 27017:27017 mongo –auth Error response from daemon: Conflict. The container name &quot;/mysql-server&quot; is already in use by container bdc8d8c475cb86695c466d23fd7102221f2c040898c2d576f94cd06c93ca811b. You have to remove (or rename) that container to be able to reuse that name..See &apos;/usr/bin/docker-current run --help&apos;. 1.docker ps 2.docker ps -l 3.docker rm bdc8d8c475cbhttps://blog.csdn.net/972301/article/details/80915127https://thispointer.com/docker-how-to-stop-remove-a-running-container-by-id-or-name/","categories":[],"tags":[],"keywords":[]},{"title":"面试题/react_面试题","slug":"面试题/react_面试题","date":"2020-01-14T03:22:51.671Z","updated":"2020-01-14T04:06:52.668Z","comments":true,"path":"2020/01/14/面试题/react_面试题/","link":"","permalink":"http://yoursite.com/2020/01/14/%E9%9D%A2%E8%AF%95%E9%A2%98/react_%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"this.setState 同步和异步特性： setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。 setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。 setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。 https://juejin.im/post/5bf1444cf265da614a3a1660 写一个闭包： 12345678910111213function foo() &#123; let a = 2; function bar() &#123; console.log( a ); &#125; return bar;&#125;let baz = foo();baz(); 防抖和节流： 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。 结合应用场景 debouncesearch搜索联想，用户在不断输入值时，用防抖来节约请求资源。window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 throttle鼠标不断点击触发，mousedown(单位时间内只触发一次)监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断 https://juejin.im/post/5b8de829f265da43623c4261 什么事真实dom?什么是虚拟dom? localStorage 和 sessionStorage 的区别？ es6 的新特性： React怎么判断重新渲染该组件： js的同源策略？ 手写一个冒泡排序算法： jsde的执行顺序：","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Preventing_Transition","slug":"react_router/examples/Preventing_Transition","date":"2020-01-13T11:18:55.488Z","updated":"2020-01-13T11:25:49.919Z","comments":true,"path":"2020/01/13/react_router/examples/Preventing_Transition/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Preventing_Transition/","excerpt":"","text":"harmony123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import React, &#123; useState &#125; from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, Prompt&#125; from \"react-router-dom\";/*有时您想阻止用户 离开页面导航。 最常见的 用例是当他们输入一些数据时 表格，但尚未提交，并且 你不希望他们失去它。*/export default function PreventingTransitionsExample() &#123; return ( &lt;Router&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Form&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/one\"&gt;One&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/two\"&gt;Two&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact children=&#123;&lt;BlockingForm /&gt;&#125; /&gt; &lt;Route path=\"/one\" children=&#123;&lt;h3&gt;One&lt;/h3&gt;&#125; /&gt; &lt;Route path=\"/two\" children=&#123;&lt;h3&gt;Two&lt;/h3&gt;&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; );&#125;function BlockingForm() &#123; let [isBlocking, setIsBlocking] = useState(false); return ( &lt;form onSubmit=&#123;event =&gt; &#123; event.preventDefault(); event.target.reset(); setIsBlocking(false); &#125;&#125; &gt; &lt;Prompt when=&#123;isBlocking&#125; message=&#123;location =&gt; `Are you sure you want to go to $&#123;location.pathname&#125;` &#125; /&gt; &lt;p&gt; Blocking?&#123;\" \"&#125; &#123;isBlocking ? \"Yes, click a link or the back button\" : \"Nope\"&#125; &lt;/p&gt; &lt;p&gt; &lt;input size=\"50\" placeholder=\"type something to block transitions\" onChange=&#123;event =&gt; &#123; setIsBlocking(event.target.value.length &gt; 0); &#125;&#125; /&gt; &lt;/p&gt; &lt;p&gt; &lt;button&gt;Submit to stop blocking&lt;/button&gt; &lt;/p&gt; &lt;/form&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/No_Match","slug":"react_router/examples/No_Match","date":"2020-01-13T11:14:52.115Z","updated":"2020-01-13T11:18:17.273Z","comments":true,"path":"2020/01/13/react_router/examples/No_Match/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/No_Match/","excerpt":"","text":"harmony12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import React from \"react\";import &#123; BrowserRouter as Router, Route, Link, Switch, Redirect, useLocation&#125; from \"react-router-dom\";/* 您可以将&lt;Switch&gt;中的最后一个&lt;Route&gt;用作一种 “后备”路线，以捕获404错误。关于此示例，有一些有用的注意事项： &lt;Switch&gt;呈现与之匹配的第一个子元素&lt;Route&gt; &lt;Redirect&gt;可以用于将旧URL重定向到新URL &lt;Route path =“ *&gt;始终匹配*/export default function NoMatchExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/old-match\"&gt;Old Match, to be redirected&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/will-match\"&gt;Will Match&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/will-not-match\"&gt;Will Not Match&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/also/will/not/match\"&gt;Also Will Not Match&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/old-match\"&gt; &lt;Redirect to=\"/will-match\" /&gt; &lt;/Route&gt; &lt;Route path=\"/will-match\"&gt; &lt;WillMatch /&gt; &lt;/Route&gt; &lt;Route path=\"*\"&gt; &lt;NoMatch /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Home() &#123; return &lt;h3&gt;Home&lt;/h3&gt;;&#125;function WillMatch() &#123; return &lt;h3&gt;Matched!&lt;/h3&gt;;&#125;function NoMatch() &#123; let location = useLocation(); return ( &lt;div&gt; &lt;h3&gt; No match for &lt;code&gt;&#123;location.pathname&#125;&lt;/code&gt; &lt;/h3&gt; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Recursive_Paths","slug":"react_router/examples/Recursive_Paths","date":"2020-01-13T11:12:35.304Z","updated":"2020-01-13T11:14:36.107Z","comments":true,"path":"2020/01/13/react_router/examples/Recursive_Paths/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Recursive_Paths/","excerpt":"","text":"harmony123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, Redirect, useParams, useRouteMatch&#125; from \"react-router-dom\";/*有时您不知道所有可能的路线预先为您的应用程序； 例如，当构建文件系统浏览UI或确定网址是根据数据动态生成的。 在这些情况下，它有助于拥有一个能够在运行时根据需要生成路由。该示例使您可以深入了解朋友递归列表，查看每个用户的朋友列表一路上。 向下钻取时，请注意每个细分被添加到URL。 您可以复制/粘贴此链接 给其他人，他们将看到相同的用户界面。然后单击后退按钮并观看最后一个URL的段与最后一个段一起消失好友列表。*/export default function RecursiveExample() &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path=\"/:id\"&gt; &lt;Person /&gt; &lt;/Route&gt; &lt;Route path=\"/\"&gt; &lt;Redirect to=\"/0\" /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/Router&gt; );&#125;function Person() &#123; let &#123; url &#125; = useRouteMatch(); let &#123; id &#125; = useParams(); let person = find(parseInt(id)); return ( &lt;div&gt; &lt;h3&gt;&#123;person.name&#125;’s Friends&lt;/h3&gt; &lt;ul&gt; &#123;person.friends.map(id =&gt; ( &lt;li key=&#123;id&#125;&gt; &lt;Link to=&#123;`$&#123;url&#125;/$&#123;id&#125;`&#125;&gt;&#123;find(id).name&#125;&lt;/Link&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=&#123;`$&#123;url&#125;/:id`&#125;&gt; &lt;Person /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125;const PEEPS = [ &#123; id: 0, name: \"Michelle\", friends: [1, 2, 3] &#125;, &#123; id: 1, name: \"Sean\", friends: [0, 3] &#125;, &#123; id: 2, name: \"Kim\", friends: [0, 1, 3] &#125;, &#123; id: 3, name: \"David\", friends: [1, 2] &#125;];function find(id) &#123; return PEEPS.find(p =&gt; p.id === id);&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Siderbar","slug":"react_router/examples/Siderbar","date":"2020-01-13T11:04:46.476Z","updated":"2020-01-13T11:06:27.881Z","comments":true,"path":"2020/01/13/react_router/examples/Siderbar/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Siderbar/","excerpt":"","text":"harmony1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link&#125; from \"react-router-dom\";// 每个逻辑“路线”都有两个组成部分，一个用于 //侧边栏，一个用于主区域。 我们想 //当路径与当前URL匹配。// 我们将在2中使用此路由配置 //景点：一次用于侧边栏，一次在主区域 //内容部分。 所有路线都在同一条 //将它们显示在&lt;Switch&gt;中的顺序。const routes = [ &#123; path: \"/\", exact: true, sidebar: () =&gt; &lt;div&gt;home!&lt;/div&gt;, main: () =&gt; &lt;h2&gt;Home&lt;/h2&gt; &#125;, &#123; path: \"/bubblegum\", sidebar: () =&gt; &lt;div&gt;bubblegum!&lt;/div&gt;, main: () =&gt; &lt;h2&gt;Bubblegum&lt;/h2&gt; &#125;, &#123; path: \"/shoelaces\", sidebar: () =&gt; &lt;div&gt;shoelaces!&lt;/div&gt;, main: () =&gt; &lt;h2&gt;Shoelaces&lt;/h2&gt; &#125;];export default function SidebarExample() &#123; return ( &lt;Router&gt; &lt;div style=&#123;&#123; display: \"flex\" &#125;&#125;&gt; &lt;div style=&#123;&#123; padding: \"10px\", width: \"40%\", background: \"#f0f0f0\" &#125;&#125; &gt; &lt;ul style=&#123;&#123; listStyleType: \"none\", padding: 0 &#125;&#125;&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/bubblegum\"&gt;Bubblegum&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/shoelaces\"&gt;Shoelaces&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &#123;routes.map((route, index) =&gt; ( //您可以在许多地方渲染&lt;Route&gt; //如您所愿，在您的应用中。 它将沿着 //和其他也与URL匹配的&lt;Route&gt;匹配。 //因此，侧边栏或面包屑或其他任何东西 //需要您渲染多个事物 //在同一网址的多个位置没有任何内容 //超过多个&lt;Route&gt;。 &lt;Route key=&#123;index&#125; path=&#123;route.path&#125; exact=&#123;route.exact&#125; children=&#123;&lt;route.sidebar /&gt;&#125; /&gt; ))&#125; &lt;/Switch&gt; &lt;/div&gt; &lt;div style=&#123;&#123; flex: 1, padding: \"10px\" &#125;&#125;&gt; &lt;Switch&gt; &#123;routes.map((route, index) =&gt; ( // //渲染更多具有相同路径的&lt;Route&gt; //，但这次是不同的组件。 &lt;Route key=&#123;index&#125; path=&#123;route.path&#125; exact=&#123;route.exact&#125; children=&#123;&lt;route.main /&gt;&#125; /&gt; ))&#125; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Animated_Transitions","slug":"react_router/examples/Animated_Transitions","date":"2020-01-13T11:02:47.165Z","updated":"2020-01-13T11:04:21.650Z","comments":true,"path":"2020/01/13/react_router/examples/Animated_Transitions/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Animated_Transitions/","excerpt":"","text":"harmony1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import React from \"react\";import &#123; BrowserRouter as Router, Link, useLocation&#125; from \"react-router-dom\";// React Router对 // 您应该如何解析URL查询字符串。 // // 如果您使用简单的key = value查询字符串和 // 您不需要支持IE 11，就可以使用 // 浏览器的内置URLSearchParams API。 // // 如果您的查询字符串包含数组或对象 // 语法，您可能需要自带 // 查询解析功能。export default function QueryParamsExample() &#123; return ( &lt;Router&gt; &lt;QueryParamsDemo /&gt; &lt;/Router&gt; );&#125;// 基于useLocation进行解析的自定义钩子 //您的查询字符串。function useQuery() &#123; return new URLSearchParams(useLocation().search);&#125;function QueryParamsDemo() &#123; let query = useQuery(); return ( &lt;div&gt; &lt;div&gt; &lt;h2&gt;Accounts&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/account?name=netflix\"&gt;Netflix&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/account?name=zillow-group\"&gt;Zillow Group&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/account?name=yahoo\"&gt;Yahoo&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/account?name=modus-create\"&gt;Modus Create&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Child name=&#123;query.get(\"name\")&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;function Child(&#123; name &#125;) &#123; return ( &lt;div&gt; &#123;name ? ( &lt;h3&gt; The &lt;code&gt;name&lt;/code&gt; in the query string is &amp;quot;&#123;name&#125; &amp;quot; &lt;/h3&gt; ) : ( &lt;h3&gt;There is no name in the query string&lt;/h3&gt; )&#125; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Route_Config","slug":"react_router/examples/Route_Config","date":"2020-01-13T10:59:04.757Z","updated":"2020-01-13T11:02:12.146Z","comments":true,"path":"2020/01/13/react_router/examples/Route_Config/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Route_Config/","excerpt":"","text":"harmony123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link&#125; from \"react-router-dom\";// 有些人在集中式路由配置中发现价值。路由配置只是数据。React擅长映射将数据放入组件中，而`&lt;Route&gt;`是一个组件。// 我们的路由配置只是逻辑“路由”的数组// 与`path`和`component`道具一起订购// 您在`&lt;Switch&gt;`中执行的方式。const routes = [ &#123; path: \"/sandwiches\", component: Sandwiches &#125;, &#123; path: \"/tacos\", component: Tacos, routes: [ &#123; path: \"/tacos/bus\", component: Bus &#125;, &#123; path: \"/tacos/cart\", component: Cart &#125; ] &#125;];export default function RouteConfigExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/tacos\"&gt;Tacos&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/sandwiches\"&gt;Sandwiches&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &#123;routes.map((route, i) =&gt; ( &lt;RouteWithSubRoutes key=&#123;i&#125; &#123;...route&#125; /&gt; ))&#125; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;// `&lt;Route&gt;`的特殊包装，它知道如何 //通过在“路由”中传递“子”路由 //对其呈现的组件进行支撑。function RouteWithSubRoutes(route) &#123; return ( &lt;Route path=&#123;route.path&#125; render=&#123;props =&gt; ( // 向下传递子路线以保持嵌套 &lt;route.component &#123;...props&#125; routes=&#123;route.routes&#125; /&gt; )&#125; /&gt; );&#125;function Sandwiches() &#123; return &lt;h2&gt;Sandwiches&lt;/h2&gt;;&#125;function Tacos(&#123; routes &#125;) &#123; return ( &lt;div&gt; &lt;h2&gt;Tacos&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/tacos/bus\"&gt;Bus&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/tacos/cart\"&gt;Cart&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &#123;routes.map((route, i) =&gt; ( &lt;RouteWithSubRoutes key=&#123;i&#125; &#123;...route&#125; /&gt; ))&#125; &lt;/Switch&gt; &lt;/div&gt; );&#125;function Bus() &#123; return &lt;h3&gt;Bus&lt;/h3&gt;;&#125;function Cart() &#123; return &lt;h3&gt;Cart&lt;/h3&gt;;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Modal_Gallery","slug":"react_router/examples/Modal_Gallery","date":"2020-01-13T10:52:52.158Z","updated":"2020-01-13T10:58:45.726Z","comments":true,"path":"2020/01/13/react_router/examples/Modal_Gallery/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Modal_Gallery/","excerpt":"","text":"harmony123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useHistory, useLocation, useParams&#125; from \"react-router-dom\";// 本示例说明如何渲染两个不同的屏幕（或在不同上下文中的同一屏幕）在同一URL上，取决于您到达那里的方式。// 点击“精选图片”，然后全屏查看。然后“访问图库”，然后单击颜色。注意URL和组件与以前相同，但现在我们可以看到它们在图库屏幕顶部的模态中。export default function ModalGalleryExample() &#123; return ( &lt;Router&gt; &lt;ModalSwitch /&gt; &lt;/Router&gt; );&#125;function ModalSwitch() &#123; let location = useLocation(); // 当其中一个单击图库链接。“背景”状态是其中之一时我们所在的位置单击图库链接。如果有的话将其用作`&lt;Switch&gt;`的位置，因此//我们在后台显示画廊模态 let background = location.state &amp;&amp; location.state.background; return ( &lt;div&gt; &lt;Switch location=&#123;background || location&#125;&gt; &lt;Route exact path=\"/\" children=&#123;&lt;Home /&gt;&#125; /&gt; &lt;Route path=\"/gallery\" children=&#123;&lt;Gallery /&gt;&#125; /&gt; &lt;Route path=\"/img/:id\" children=&#123;&lt;ImageView /&gt;&#125; /&gt; &lt;/Switch&gt; &#123;/* 设置背景页面时显示模式 */&#125; &#123;background &amp;&amp; &lt;Route path=\"/img/:id\" children=&#123;&lt;Modal /&gt;&#125; /&gt;&#125; &lt;/div&gt; );&#125;const IMAGES = [ &#123; id: 0, title: \"Dark Orchid\", color: \"DarkOrchid\" &#125;, &#123; id: 1, title: \"Lime Green\", color: \"LimeGreen\" &#125;, &#123; id: 2, title: \"Tomato\", color: \"Tomato\" &#125;, &#123; id: 3, title: \"Seven Ate Nine\", color: \"#789\" &#125;, &#123; id: 4, title: \"Crimson\", color: \"Crimson\" &#125;];function Thumbnail(&#123; color &#125;) &#123; return ( &lt;div style=&#123;&#123; width: 50, height: 50, background: color &#125;&#125; /&gt; );&#125;function Image(&#123; color &#125;) &#123; return ( &lt;div style=&#123;&#123; width: \"100%\", height: 400, background: color &#125;&#125; /&gt; );&#125;function Home() &#123; return ( &lt;div&gt; &lt;Link to=\"/gallery\"&gt;Visit the Gallery&lt;/Link&gt; &lt;h2&gt;Featured Images&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/img/2\"&gt;Tomato&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/img/4\"&gt;Crimson&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; );&#125;function Gallery() &#123; let location = useLocation(); return ( &lt;div&gt; &#123;IMAGES.map(i =&gt; ( &lt;Link key=&#123;i.id&#125; to=&#123;&#123; pathname: `/img/$&#123;i.id&#125;`, // 这是把戏！ 该链接集 // the `background` in location state. state: &#123; background: location &#125; &#125;&#125; &gt; &lt;Thumbnail color=&#123;i.color&#125; /&gt; &lt;p&gt;&#123;i.title&#125;&lt;/p&gt; &lt;/Link&gt; ))&#125; &lt;/div&gt; );&#125;function ImageView() &#123; let &#123; id &#125; = useParams(); let image = IMAGES[parseInt(id, 10)]; if (!image) return &lt;div&gt;Image not found&lt;/div&gt;; return ( &lt;div&gt; &lt;h1&gt;&#123;image.title&#125;&lt;/h1&gt; &lt;Image color=&#123;image.color&#125; /&gt; &lt;/div&gt; );&#125;function Modal() &#123; let history = useHistory(); let &#123; id &#125; = useParams(); let image = IMAGES[parseInt(id, 10)]; if (!image) return null; let back = e =&gt; &#123; e.stopPropagation(); history.goBack(); &#125;; return ( &lt;div onClick=&#123;back&#125; style=&#123;&#123; position: \"absolute\", top: 0, left: 0, bottom: 0, right: 0, background: \"rgba(0, 0, 0, 0.15)\" &#125;&#125; &gt; &lt;div className=\"modal\" style=&#123;&#123; position: \"absolute\", background: \"#fff\", top: 25, left: \"10%\", right: \"10%\", padding: 15, border: \"2px solid #444\" &#125;&#125; &gt; &lt;h1&gt;&#123;image.title&#125;&lt;/h1&gt; &lt;Image color=&#123;image.color&#125; /&gt; &lt;button type=\"button\" onClick=&#123;back&#125;&gt; Close &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/StaticRouter_Context","slug":"react_router/examples/StaticRouter_Context","date":"2020-01-13T10:49:24.935Z","updated":"2020-01-13T10:51:55.744Z","comments":true,"path":"2020/01/13/react_router/examples/StaticRouter_Context/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/StaticRouter_Context/","excerpt":"","text":"harmony123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React, &#123; Component &#125; from \"react\";import &#123; StaticRouter as Router, Route &#125; from \"react-router-dom\";// 本示例在StaticRouter中渲染路由并填充其路由staticContext，然后将其打印出来。在现实世界中，您会使用StaticRouter进行服务器端渲染：//// import express from \"express\";// import ReactDOMServer from \"react-dom/server\";//// const app = express()//// app.get('*', (req, res) =&gt; &#123;// let staticContext = &#123;&#125;//// let html = ReactDOMServer.renderToString(// &lt;StaticRouter location=&#123;req.url&#125; context=&#123;staticContext&#125;&gt;// &lt;App /&gt; (includes the RouteStatus component below e.g. for 404 errors)// &lt;/StaticRouter&gt;// );//// res.status(staticContext.statusCode || 200).send(html);// &#125;);//// app.listen(process.env.PORT || 3000);function RouteStatus(props) &#123; return ( &lt;Route render=&#123;(&#123; staticContext &#125;) =&gt; &#123; // 我们必须检查staticContext是否存在//，因为如果通过BrowserRouter呈现，它将是未定义的 if (staticContext) &#123; staticContext.statusCode = props.statusCode; &#125; return &lt;div&gt;&#123;props.children&#125;&lt;/div&gt;; &#125;&#125; /&gt; );&#125;function PrintContext(props) &#123; return &lt;p&gt;Static context: &#123;JSON.stringify(props.staticContext)&#125;&lt;/p&gt;;&#125;export default class StaticRouterExample extends Component &#123; // 这是我们传递给StaticRouter的上下文对象。可以通过路由进行修改以提供其他信息,用于服务器端渲染。 staticContext = &#123;&#125;; render() &#123; return ( &lt;Router location=\"/foo\" context=&#123;this.staticContext&#125;&gt; &lt;div&gt; &lt;RouteStatus statusCode=&#123;404&#125;&gt; &lt;p&gt;Route with statusCode 404&lt;/p&gt; &lt;PrintContext staticContext=&#123;this.staticContext&#125; /&gt; &lt;/RouteStatus&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Query_Paramenters","slug":"react_router/examples/Query_Paramenters","date":"2020-01-13T10:43:07.627Z","updated":"2020-01-13T10:48:36.871Z","comments":true,"path":"2020/01/13/react_router/examples/Query_Paramenters/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/examples/Query_Paramenters/","excerpt":"","text":"harmony12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React from \"react\";import &#123; BrowserRouter as Router, Link, useLocation&#125; from \"react-router-dom\";// React Router对您应该如何解析URL查询字符串。//// 如果你使用 key=value query strings and// 你不需要 支持 IE 11, 您可以使用//浏览器的内置URLSearchParams API。////如果您的查询字符串包含数组或对象语法，您可能需要自带语法查询解析功能。export default function QueryParamsExample() &#123; return ( &lt;Router&gt; &lt;QueryParamsDemo /&gt; &lt;/Router&gt; );&#125;// 基于useLocation进行解析的自定义钩子您的查询字符串。function useQuery() &#123; return new URLSearchParams(useLocation().search);&#125;function QueryParamsDemo() &#123; let query = useQuery(); return ( &lt;div&gt; &lt;div&gt; &lt;h2&gt;Accounts&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/account?name=netflix\"&gt;Netflix&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/account?name=zillow-group\"&gt;Zillow Group&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/account?name=yahoo\"&gt;Yahoo&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/account?name=modus-create\"&gt;Modus Create&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Child name=&#123;query.get(\"name\")&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;function Child(&#123; name &#125;) &#123; return ( &lt;div&gt; &#123;name ? ( &lt;h3&gt; The &lt;code&gt;name&lt;/code&gt; in the query string is &amp;quot;&#123;name&#125; &amp;quot; &lt;/h3&gt; ) : ( &lt;h3&gt;There is no name in the query string&lt;/h3&gt; )&#125; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/BrowserRouter","slug":"react_router/Api/BrowserRouter","date":"2020-01-13T08:33:34.178Z","updated":"2020-01-13T08:38:38.642Z","comments":true,"path":"2020/01/13/react_router/Api/BrowserRouter/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/BrowserRouter/","excerpt":"","text":"使用HTML5历史记录API（pushState，replaceState和popstate事件）的&lt;Router&gt;使UI与URL保持同步。 harmony12345678&lt;BrowserRouter basename=&#123;optionalString&#125; forceRefresh=&#123;optionalBool&#125; getUserConfirmation=&#123;optionalFunc&#125; keyLength=&#123;optionalNumber&#125;&gt; &lt;App /&gt;&lt;/BrowserRouter&gt; basename: string所有位置的基本URL。如果您的应用是通过服务器上的子目录提供的，则需要将其设置为子目录。格式正确的基本名称应以斜杠开头，但不能以斜杠结尾。 harmony12&lt;BrowserRouter basename=\"/calendar\" /&gt;&lt;Link to=\"/today\"/&gt; // renders &lt;a href=\"/calendar/today\"&gt; getUserConfirmation: func用于确认导航的功能。默认使用window.confirm。 harmony1234567&lt;BrowserRouter getUserConfirmation=&#123;(message, callback) =&gt; &#123; // this is the default behavior const allowTransition = window.confirm(message); callback(allowTransition); &#125;&#125;/&gt; forceRefresh: bool如果为true，则路由器将在页面导航中使用整页刷新。您可能希望使用它来模仿传统的服务器渲染应用程序在页面导航之间刷新整个页面的方式。 harmony1&lt;BrowserRouter forceRefresh=&#123;true&#125; /&gt; keyLength: numberlocation.key的长度。默认为6。 harmony1&lt;BrowserRouter keyLength=&#123;12&#125; /&gt; children: node要渲染的子元素。 注意：在React &lt;16上，您必须使用单个子元素，因为render方法不能返回多个元素。如果需要多个元素，则可以尝试将它们包装在额外的&lt;div&gt;中。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/HashRouter","slug":"react_router/Api/HashRouter","date":"2020-01-13T08:27:15.997Z","updated":"2020-01-13T08:33:19.505Z","comments":true,"path":"2020/01/13/react_router/Api/HashRouter/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/HashRouter/","excerpt":"","text":"&lt;Router&gt;使用URL的哈希部分（即window.location.hash）使UI与URL保持同步。 重要说明：哈希历史记录不支持location.key或location.state。在以前的版本中，我们尝试对行为进行匀称处理，但存在一些无法解决的极端情况。任何需要此行为的代码或插件都将无法使用。由于此技术仅旨在支持旧版浏览器，因此建议您将服务器配置为与&lt;BrowserHistory&gt;一起使用。 harmony1234567&lt;HashRouter basename=&#123;optionalString&#125; getUserConfirmation=&#123;optionalFunc&#125; hashType=&#123;optionalString&#125;&gt; &lt;App /&gt;&lt;/HashRouter&gt; basename: string所有位置的基本URL。格式正确的基本名称应以斜杠开头，但不能以斜杠结尾。 harmony12&lt;HashRouter basename=\"/calendar\"/&gt;&lt;Link to=\"/today\"/&gt; // renders &lt;a href=\"#/calendar/today\"&gt; getUserConfirmation: func用于确认导航的功能。默认使用window.confirm。 harmony1234567&lt;HashRouter getUserConfirmation=&#123;(message, callback) =&gt; &#123; // this is the default behavior const allowTransition = window.confirm(message); callback(allowTransition); &#125;&#125;/&gt; hashType: string用于window.location.hash的编码类型。可用值为： “slash”：创建＃/ 和 ＃/sunshine/lollipops之类的哈希 “slash”：创建hash # and #sunshine/lollipops “hashbang”：创建“可抓取的ajax”（Google弃用）哈希l#!/ and #!/sunshine/lollipops默认为“斜线”。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/Prompt","slug":"react_router/Api/Prompt","date":"2020-01-13T08:24:27.980Z","updated":"2020-01-13T08:25:08.197Z","comments":true,"path":"2020/01/13/react_router/Api/Prompt/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/Prompt/","excerpt":"","text":"Re-exported from core Prompt。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/MemoryRouter","slug":"react_router/Api/MemoryRouter","date":"2020-01-13T08:19:54.751Z","updated":"2020-01-13T08:24:06.731Z","comments":true,"path":"2020/01/13/react_router/Api/MemoryRouter/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/MemoryRouter/","excerpt":"","text":"一个&lt;Router&gt;，用于将“ URL”的历史记录保留在内存中（不读取或写入地址栏）。在测试和非浏览器环境（如React Native）中很有用。 harmony12345678&lt;MemoryRouter initialEntries=&#123;optionalArray&#125; initialIndex=&#123;optionalNumber&#125; getUserConfirmation=&#123;optionalFunc&#125; keyLength=&#123;optionalNumber&#125;&gt; &lt;App /&gt;&lt;/MemoryRouter&gt; initialEntries: array历史记录堆栈中的位置数组。这些可能是带有{路径名，搜索，哈希，状态}或简单字符串URL的成熟位置对象。 harmony123456&lt;MemoryRouter initialEntries=&#123;[\"/one\", \"/two\", &#123; pathname: \"/three\" &#125;]&#125; initialIndex=&#123;1&#125;&gt; &lt;App /&gt;&lt;/MemoryRouter&gt; initialIndex: number初始位置在initialEntries数组中的索引。 getUserConfirmation: func用于确认导航的功能。直接将&lt;MemoryRouter&gt;与&lt;Prompt&gt;一起使用时，必须使用此选项。 keyLength: numberlocation.key的长度。默认为6。 harmony1&lt;MemoryRouter keyLength=&#123;12&#125; /&gt; children: node要渲染的子元素。 注意：在React &lt;16上，您必须使用单个子元素，因为render方法不能返回多个元素。如果需要多个元素，则可以尝试将它们包装在额外的&lt;div&gt;中。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/StaticRouter","slug":"react_router/Api/StaticRouter","date":"2020-01-13T08:09:32.682Z","updated":"2020-01-13T08:19:14.079Z","comments":true,"path":"2020/01/13/react_router/Api/StaticRouter/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/StaticRouter/","excerpt":"","text":"永远不会更改位置的&lt;Router&gt;。 当用户实际上没有四处点击时，这在服务器端渲染方案中很有用，因此位置永远不会发生实际变化。因此，名称为：静态。当您只需要插入一个位置并在渲染输出中进行断言时，它在简单测试中也很有用。 这是一个示例节点服务器，它为&lt;Redirect&gt;发送302状态代码，并为其他请求发送常规HTML： harmony12345678910111213141516171819202122232425262728import http from \"http\";import React from \"react\";import ReactDOMServer from \"react-dom/server\";import &#123; StaticRouter &#125; from \"react-router\";http .createServer((req, res) =&gt; &#123; // This context object contains the results of the render const context = &#123;&#125;; const html = ReactDOMServer.renderToString( &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt; ); // context.url will contain the URL to redirect to if a &lt;Redirect&gt; was used if (context.url) &#123; res.writeHead(302, &#123; Location: context.url &#125;); res.end(); &#125; else &#123; res.write(html); res.end(); &#125; &#125;) .listen(3000); basename: string所有位置的基本URL。格式正确的基本名称应以斜杠开头，但不能以斜杠结尾。 harmony123&lt;StaticRouter basename=\"/calendar\"&gt; &lt;Link to=\"/today\"/&gt; // renders &lt;a href=\"/calendar/today\"&gt;&lt;/StaticRouter&gt; location: string服务器收到的URL，可能是节点服务器上的req.url。 harmony123&lt;StaticRouter location=&#123;req.url&#125;&gt; &lt;App /&gt;&lt;/StaticRouter&gt; location: object类似的位置对象{ pathname, search, hash, state } harmony123&lt;StaticRouter location=&#123;&#123; pathname: \"/bubblegum\" &#125;&#125;&gt; &lt;App /&gt;&lt;/StaticRouter&gt; context: object一个普通的JavaScript对象。在渲染期间，组件可以向对象添加属性以存储有关渲染的信息。 当&lt;Route&gt;匹配时，它将把上下文对象传递给它作为staticContext属性呈现的组件。请查看服务器渲染指南，以获取有关如何自行执行此操作的更多信息。 harmony1234const context = &#123;&#125;&lt;StaticRouter context=&#123;context&#125;&gt; &lt;App /&gt;&lt;/StaticRouter&gt; 当&lt;Route&gt;匹配时，它将把上下文对象传递给它作为staticContext属性呈现的组件。请查看服务器渲染指南，以获取有关如何自行执行此操作的更多信息。 渲染后，这些属性可用于配置服务器的响应。 harmony123if (context.status === \"404\") &#123; // ...&#125; 当&lt;Route&gt;匹配时，它将把上下文对象传递给它作为staticContext属性呈现的组件。请查看服务器渲染指南，以获取有关如何自行执行此操作的更多信息。 children: node要渲染的子元素。注意：在React &lt;16上，您必须使用单个子元素，因为render方法不能返回多个元素。如果需要多个元素，则可以尝试将它们包装在额外的&lt;div&gt;中。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/match","slug":"react_router/Api/match","date":"2020-01-13T07:49:34.704Z","updated":"2020-01-13T08:08:00.828Z","comments":true,"path":"2020/01/13/react_router/Api/match/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/match/","excerpt":"","text":"匹配对象包含有关&lt;Route path&gt;如何与URL匹配的信息。匹配对象包含以下属性： params —— (object) Key/value对从 路径的动态段对应的URL解析 isExact —— (boolean)true 如果整个URL都匹配（没有结尾字符） path —— (string) 用于匹配的路径模式。用于构建嵌套的&lt;Route&gt; url —— (string) URL的匹配部分。对于构建嵌套的&lt;Link&gt;有用 您将可以在各个地方匹配对象： Route component as this.props.match Route render as ({ match }) =&gt; () Route children as ({ match }) =&gt; () withRouter as this.props.match matchPath as the return value 如果路线没有路径，因此始终匹配，则将获得最接近的父项匹配项。路由器也是如此。 null matches即使子路径的路径与当前位置不匹配，使用子项道具的&lt;Route&gt;也会调用其子函数。在这种情况下，匹配将为空。能够在匹配时呈现&lt;Route&gt;的内容可能会很有用，但是这种情况会带来一些挑战。“解析” URL的默认方法是将match.url字符串连接到“相对”路径。 harmony1let path = `$&#123;match.url&#125;/relative-path`; 如果在匹配为null时尝试执行此操作，则最终将出现TypeError。这意味着在使用子道具时尝试在&lt;Route&gt;内部加入“相对”路径是不安全的。 当在生成空匹配对象的&lt;Route&gt;中使用无路径&lt;Route&gt;时，会发生类似但更微妙的情况。 harmony1234567891011// location.pathname = '/matches'&lt;Route path=\"/does-not-match\" children=&#123;(&#123; match &#125;) =&gt; ( // match === null &lt;Route render=&#123;(&#123; match: pathlessMatch &#125;) =&gt; ( // pathlessMatch === ??? )&#125; /&gt; )&#125;/&gt; 无路径&lt;Route&gt;从其父级继承其match对象。如果其父匹配项为null，则其匹配项也将为null。这意味着a）任何子级路由/链接都必须是绝对的，因为没有父级可以解析，并且b）父级匹配可以为null的无路径路由将需要使用子级prop进行渲染。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/withRouter","slug":"react_router/Api/withRouter","date":"2020-01-13T07:40:51.739Z","updated":"2020-01-13T07:47:15.104Z","comments":true,"path":"2020/01/13/react_router/Api/withRouter/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/withRouter/","excerpt":"","text":"您可以通过withRouter高阶组件访问历史对象的属性和最接近的&lt;Route&gt;匹配项。每当呈现时，withRouter都会将更新的匹配，位置和历史道具传递给包装的组件。 harmony12345678910111213141516171819202122import React from \"react\";import PropTypes from \"prop-types\";import &#123; withRouter &#125; from \"react-router\";// A simple component that shows the pathname of the current locationclass ShowTheLocation extends React.Component &#123; static propTypes = &#123; match: PropTypes.object.isRequired, location: PropTypes.object.isRequired, history: PropTypes.object.isRequired &#125;; render() &#123; const &#123; match, location, history &#125; = this.props; return &lt;div&gt;You are now at &#123;location.pathname&#125;&lt;/div&gt;; &#125;&#125;// Create a new component that is \"connected\" (to borrow redux// terminology) to the router.const ShowTheLocationWithRouter = withRouter(ShowTheLocation); 重要的提示 withRouter不像React Redux的connect那样订阅位置更改以进行状态更改。而是在位置更改后从&lt;Router&gt;组件传播出去后重新渲染。这意味着withRouter不会在路由转换时重新呈现，除非其父组件重新呈现。 静态方法和属性 包装组件的所有非特定于反应的静态方法和属性将自动复制到“connected”组件。 Component.WrappedComponent包装的组件在返回的组件上作为静态属性WrappedComponent公开，它可以用于隔离测试组件等。 harmony123456// MyComponent.jsexport default withRouter(MyComponent)// MyComponent.test.jsimport MyComponent from './MyComponent'render(&lt;MyComponent.WrappedComponent location=&#123;&#123;...&#125;&#125; ... /&gt;) wrappedComponentRef: func该函数将作为ref prop传递给包装的组件。 harmony1234567891011class Container extends React.Component &#123; componentDidMount() &#123; this.component.doSomething(); &#125; render() &#123; return ( &lt;MyComponent wrappedComponentRef=&#123;c =&gt; (this.component = c)&#125; /&gt; ); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/matchPath","slug":"react_router/Api/matchPath","date":"2020-01-13T07:30:00.292Z","updated":"2020-01-13T07:35:17.653Z","comments":true,"path":"2020/01/13/react_router/Api/matchPath/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/matchPath/","excerpt":"","text":"这使您可以使用&lt;Route&gt;使用的相同匹配代码，但不在正常渲染周期之内，例如在服务器上渲染之前收集数据依赖项。 harmony1234567import &#123; matchPath &#125; from \"react-router\";const match = matchPath(\"/users/123\", &#123; path: \"/users/:id\", exact: true, strict: false&#125;); pathname第一个参数是您要匹配的路径名。如果您在带有Node.js的服务器上使用它，则为req.path props第二个参数是要匹配的道具，它们与Route接受的匹配道具相同。它也可以是字符串或字符串数​​组，作为{path}的快捷方式。 harmony12345&#123; path, // like /users/:id; either a single string or an array of strings strict, // optional, defaults to false exact // optional, defaults to false&#125; returns当提供的路径名与路径属性匹配时，它将返回一个对象。 harmony12345678910111213matchPath(\"/users/2\", &#123; path: \"/users/:id\", exact: true, strict: true&#125;);// &#123;// isExact: true// params: &#123;// id: \"2\"// &#125;// path: \"/users/:id\"// url: \"/users/2\"// &#125; 如果提供的路径名与路径属性不匹配，则返回null。 harmony1234567matchPath(\"/users\", &#123; path: \"/users/:id\", exact: true, strict: true&#125;);// null","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/NavLink","slug":"react_router/Api/NavLink","date":"2020-01-13T06:59:03.209Z","updated":"2020-01-13T07:30:33.097Z","comments":true,"path":"2020/01/13/react_router/Api/NavLink/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/NavLink/","excerpt":"","text":"&lt;Link&gt;的特殊版本，当它与当前URL匹配时，它将为rendered的元素添加样式属性。 harmony1&lt;NavLink to=\"/about\"&gt;About&lt;/NavLink&gt; activeClassName: string元素处于active状态时提供的类。默认给定的类是active的。这将与className prop一起加入。 harmony123&lt;NavLink to=\"/faq\" activeClassName=\"selected\"&gt; FAQs&lt;/NavLink&gt; activeStyle: object元素处于活动状态时应用于元素的样式。 harmony123456789&lt;NavLink to=\"/faq\" activeStyle=&#123;&#123; fontWeight: \"bold\", color: \"red\" &#125;&#125;&gt; FAQs&lt;/NavLink&gt; exact: bool如果为true，则仅在位置完全匹配时才应用活动的类/样式。 harmony123&lt;NavLink exact to=\"/profile\"&gt; Profile&lt;/NavLink&gt; strict: bool如果为true，则在确定位置是否与当前URL匹配时，将考虑位置路径名上的斜杠。有关更多信息，请参见&lt;Route strict&gt;文档。 harmony123&lt;NavLink strict to=\"/events/\"&gt; Events&lt;/NavLink&gt; isActive: func一种添加额外逻辑以确定链接是否处于活动状态的功能。如果您要做的事情不仅仅是验证链接的路径名是否与当前URL的路径名匹配，则应使用此选项。 harmony1234567891011121314&lt;NavLink to=\"/events/123\" isActive=&#123;(match, location) =&gt; &#123; if (!match) &#123; return false; &#125; // only consider an event active if its event id is an odd number const eventID = parseInt(match.params.eventID); return !isNaN(eventID) &amp;&amp; eventID % 2 === 1; &#125;&#125;&gt; Event 123&lt;/NavLink&gt; location: objectisActive比较当前历史记录位置（通常是当前浏览器URL）。要与其他位置进行比较，可以传递一个位置。 aria-current: string活动链接上使用的aria-current属性的值。可用值为： “page”: 用于指示一组分页链接中的链接。 “step”: 用于指示基于步骤的过程的步骤指示器中的链接 “location”: 用于指示视觉上突出显示的图像作为流程图的当前组成部分。 “date”: 用于指示日历中的当前日期。 “time”: 用于指示时间表中的当前时间。 “true”: 用于指示NavLink是否处于活动状态默认为“page”。 基于WAI-ARIA 1.1规范","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/Link","slug":"react_router/Api/Link","date":"2020-01-13T06:26:48.825Z","updated":"2020-01-13T06:58:45.280Z","comments":true,"path":"2020/01/13/react_router/Api/Link/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/Link/","excerpt":"","text":"提供围绕应用程序的声明式，可访问的导航。 harmony1&lt;Link to=\"/about\"&gt;About&lt;/Link&gt; to: string链接位置的字符串表示形式，是通过将位置的路径名，搜索和哈希属性连接起来而创建的。 harmony1&lt;Link to=\"/courses?sort=name\" /&gt; to: object可以具有以下任何属性的对象: pathname: 表示链接到的路径的字符串。 search: query 参数的字符串表示形式。 hash: 网址中的哈希值，例如＃a-hash。 state: state位置harmony12345678&lt;Link to=&#123;&#123; pathname: \"/courses\", search: \"?sort=name\", hash: \"#the-hash\", state: &#123; fromDashboard: true &#125; &#125;&#125;/&gt; to: function当前位置作为参数传递给该函数的函数，该函数应以字符串或对象的形式返回位置表示形式harmony1&lt;Link to=&#123;location =&gt; (&#123; ...location, pathname: \"/courses\" &#125;)&#125; /&gt; harmony1&lt;Link to=&#123;location =&gt; `$&#123;location.pathname&#125;?sort=name`&#125; /&gt; replace: bool如果为true，则单击链接将替换历史记录堆栈中的当前条目，而不是添加新条目。 harmony1&lt;Link to=\"/courses\" replace /&gt; innerRef: function从React Router 5.1开始，如果您使用的是React 16，则不需要此道具，因为我们会将ref转发到基础。请改用普通ref替换。 允许访问组件的基础引用。 harmony1234567&lt;Link to=\"/\" innerRef=&#123;node =&gt; &#123; // `node` refers 为了挂载 Dom元素 // or 卸载时为null &#125;&#125;/&gt; innerRef: RefObject从React Router 5.1开始，如果您使用的是React 16，则不需要此道具，因为我们会将ref转发到基础。请改用普通ref替换。 使用React.createRef获取组件的基础引用。 harmony123let anchorRef = React.createRef()&lt;Link to=\"/\" innerRef=&#123;anchorRef&#125; /&gt; others您还可以通过props想要在&lt;a&gt;上显示的例如标题，id，className等。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/Hooks","slug":"react_router/Api/Hooks","date":"2020-01-13T06:10:51.926Z","updated":"2020-01-13T06:26:53.189Z","comments":true,"path":"2020/01/13/react_router/Api/Hooks/","link":"","permalink":"http://yoursite.com/2020/01/13/react_router/Api/Hooks/","excerpt":"","text":"useHistoryuseHistory挂钩使您可以访问可用于导航的历史记录实例。 harmony1234567891011121314import &#123; useHistory &#125; from \"react-router-dom\";function HomeButton() &#123; let history = useHistory(); function handleClick() &#123; history.push(\"/home\") &#125; return ( &lt;button type=\"button\" onClick=&#123;handleClick&#125;&gt; Go home &lt;/button&gt;)&#125; useLocationuseLocation挂钩返回代表当前URL的位置对象。您可以像useState一样考虑它，只要URL更改，它就会返回一个新位置。 这可能非常有用，例如在您希望每次加载新页面时都使用Web分析工具触发新的“页面浏览”事件的情况下，如以下示例所示： harmony1234567891011121314151617181920212223242526import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Switch, useLocation&#125; from \"react-router-dom\";function usePageViews() &#123; let location = useLocation(); React.useEffect(() =&gt; &#123; ga.send([\"pageview\", location.pathname]); &#125;, [location]);&#125;function App() &#123; usePageViews(); return &lt;Switch&gt;...&lt;/Switch&gt;;&#125;ReactDOM.render( &lt;Router&gt; &lt;App /&gt; &lt;/Router&gt;, node); useParamsuseParams返回URL参数的键/值对的对象。使用它来访问当前的match.params。 harmony123456789101112131415161718192021222324252627import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Switch, Route, useParams&#125; from \"react-router-dom\";function BlogPost() &#123; let &#123; slug &#125; = useParams(); return &lt;div&gt;Now showing post &#123;slug&#125;&lt;/div&gt;;&#125;ReactDOM.render( &lt;Router&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;HomePage /&gt; &lt;/Route&gt; &lt;Route path=\"/blog/:slug\"&gt; &lt;BlogPost /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/Router&gt;, node); useRouteMatchuseRouteMatch挂钩尝试以与相同的方式匹配当前URL。在无需实际呈现&lt;Route&gt;的情况下访问匹配数据最有用。 现在，代替 harmony12345678910111213import &#123; Route &#125; from \"react-router-dom\";function BlogPost() &#123; return ( &lt;Route path=\"/blog/:slug\" render=&#123;(&#123; match &#125;) =&gt; &#123; // Do whatever you want with the match... return &lt;div /&gt;; &#125;&#125; /&gt; );&#125; 你也可以 harmony12345678import &#123; useRouteMatch &#125; from \"react-router-dom\";function BlogPost() &#123; let match = useRouteMatch(\"/blog/:slug\"); // Do whatever you want with the match... return &lt;div /&gt;;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/location","slug":"react_router/Api/location","date":"2020-01-10T09:13:26.126Z","updated":"2020-01-10T09:30:11.774Z","comments":true,"path":"2020/01/10/react_router/Api/location/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/Api/location/","excerpt":"","text":"locationlocation表示该应用程序现在的位置，您希望其运行的位置，甚至是以前的位置。看起来像这样： 123456789&#123; key: 'ac3df4', // not with HashHistory! pathname: '/somewhere', search: '?some=search-string', hash: '#howdy', state: &#123; [userDefined]: true &#125;&#125; 路由器提供位置对象： Route component as this.props.location Route render as ({ location }) =&gt; () Route children as ({ location }) =&gt; () withRouter as this.props.location也可以在history.location上找到它，但是您不应使用它，因为它是可变的。您可以在历史记录文档中阅读有关此内容的更多信息。位置对象永远不会发生变化，因此您可以在生命周期挂钩中使用它来确定什么时候进行导航，这对于数据获取和动画处理非常有用。12345componentWillReceiveProps(nextProps) &#123; if (nextProps.location !== this.props.location) &#123; // navigated! &#125;&#125; 您可以提供locations替换各个地方的导航： Web Link to Native Link to Redirect to history.push history.replace通常，您只使用字符串，但是如果您需要添加一些“location state”，只要应用返回到该特定位置，该状态就会可用，则可以使用位置对象代替。如果您要基于导航历史而不是仅基于路径（如模式）来分支UI，这将非常有用。 12345678910111213// usually all you need&lt;Link to=\"/somewhere\"/&gt;// but you can use a location insteadconst location = &#123; pathname: '/somewhere', state: &#123; fromDashboard: true &#125;&#125;&lt;Link to=&#123;location&#125;/&gt;&lt;Redirect to=&#123;location&#125;/&gt;history.push(location)history.replace(location) 最后，您可以将位置传递给以下组件： Route Switch 这样可以防止他们在路由器状态下使用实际位置。这对于动画和待处理的导航很有用，或者在您想要诱使组件在与真实位置不同的位置进行渲染时，这很有用。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/history","slug":"react_router/Api/history","date":"2020-01-10T08:37:10.940Z","updated":"2020-01-10T09:12:25.321Z","comments":true,"path":"2020/01/10/react_router/Api/history/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/Api/history/","excerpt":"","text":"history本文档中的术语“历史记录”和“历史记录对象”是指历史记录包，它是React Router仅有的两个主要依赖项之一（除了React本身），并提供了多种不同的实现来管理JavaScript中的会话历史记录。环境。使用的语法： “browser history”————Dom特殊的实现，在支持HTML5历史记录API的Web浏览器中很有用。 “hash history“————遗留Web浏览器的DOM特定实现。 “memory history”————内存历史记录实现，可用于测试和非DOM环境（例如React Native） 历史记录对象通常具有以下属性和方法： length ——(number) 历史记录堆栈中的条目数。 action ——(string)当前 action (PUSH, REPLACE, or POP) location ——(object) 当前位置，具有以下属性：pathname——（string）URL的路径 search——（string)URL查询字符串 hash———（string)URL哈希片段 state——（object)提供给例如当此位置被压入堆栈时，push（path，state）。仅在浏览器和内存历史记录中可用。 push(path, [state])——（function）将新条目推入历史记录堆栈 replace(path, [state]) ——(function)替换历史记录堆栈上的当前条目 go(n)——(function)将历史记录返回n个。 goBack()——(function)相当于go(-1) goForward()——(function)相当于go(1) block(prompt)——(function) 防止导航（请参阅历史记录文档）history is mutable历史对象是可变的。因此建议访问位置使用props&lt;Route&gt;的渲染，而不是history.location访问位置。这可以确保您对React的假设在生命周期挂钩中是正确的。例如： 12345678910111213class Comp extends React.Component &#123; componentDidUpdate(prevProps) &#123; // will be true const locationChanged = this.props.location !== prevProps.location; // INCORRECT, will *always* be false because history is mutable. const locationChanged = this.props.history.location !== prevProps.history.location; &#125;&#125;&lt;Route component=&#123;Comp&#125; /&gt;; 根据您所使用的实现方式，可能还会显示其他属性。请参阅历史记录文档以获取更多详细信息。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/Switch","slug":"react_router/Api/Switch","date":"2020-01-10T08:10:15.787Z","updated":"2020-01-10T08:36:09.619Z","comments":true,"path":"2020/01/10/react_router/Api/Switch/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/Api/Switch/","excerpt":"","text":"Switch渲染与位置匹配的第一个子元素&lt;Route&gt;或&lt;Redirect&gt;。 这与仅使用&lt;Route&gt;有什么不同？&lt;Switch&gt;的独特之处在于它专门呈现一条路由。相反，每个与该位置匹配的&lt;Route&gt;都将进行包含性渲染。考虑这些路线。 123456789101112131415import &#123; Route &#125; from \"react-router\";let routes = ( &lt;div&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/:user\"&gt; &lt;User /&gt; &lt;/Route&gt; &lt;Route&gt; &lt;NoMatch /&gt; &lt;/Route&gt; &lt;/div&gt;); 如果URL是/ about，则&lt;About&gt;，&lt;User&gt;和&lt;NoMatch&gt;将全部呈现，因为它们都与路径匹配。这是设计使然，允许我们以多种方式将 &lt;Route&gt;组合到我们的应用中，例如边栏和面包屑，引导程序标签等。 但是，有时我们只选择一个&lt;Route&gt;进行渲染。如果我们位于/ about，我们不想同时匹配/：user（或显示“ 404”页面）。使用Switch的方法如下： 123456789101112131415161718import &#123; Route, Switch &#125; from \"react-router\";let routes = ( &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/:user\"&gt; &lt;User /&gt; &lt;/Route&gt; &lt;Route&gt; &lt;NoMatch /&gt; &lt;/Route&gt; &lt;/Switch&gt;); 现在，如果我们位于/ about，&lt;Switch&gt;将开始寻找匹配的&lt;Route&gt;。&lt;Route path =“ / about” /&gt;将匹配，而&lt;Switch&gt;将停止寻找匹配并呈现&lt;About&gt;。同样，如果我们在/ michael位置，则会显示&lt;User&gt;。 这对于动画过渡也很有用，因为匹配的&lt;Route&gt;呈现在与上一个相同的位置。 1234567891011121314151617let routes = ( &lt;Fade&gt; &lt;Switch&gt; &#123;/* 这里只有一个child */&#125; &lt;Route /&gt; &lt;Route /&gt; &lt;/Switch&gt; &lt;/Fade&gt;);let routes = ( &lt;Fade&gt; &#123;/* 这里有两个，一个可能会变为null，但会进行过渡解决起来比较麻烦*/&#125; &lt;Route /&gt; &lt;Route /&gt; &lt;/Fade&gt;); location: object用于匹配子元素的位置对象，而不是当前历史记录位置（通常是当前浏览器URL）。 children: node&lt;Switch&gt;的所有子代应为&lt;Route&gt;或&lt;Redirect&gt;元素。仅第一个与当前位置匹配的child会被渲染。&lt;Route&gt;元素使用其路径属性进行匹配，而&lt;Redirect&gt;元素使用其from属性进行匹配。没有路径属性的&lt;Route&gt;或没有from属性的&lt;Redirect&gt;将始终与当前位置匹配。在&lt;Switch&gt;中包含&lt;Redirect&gt;时，它可以使用&lt;Route&gt;的任何位置匹配道具：path, exact, and strict。from只是路径属性的别名。如果为&lt;Switch&gt;提供了位置提示，它将覆盖匹配的子元素上的位置提示。 123456789101112131415161718import &#123; Redirect, Route, Switch &#125; from \"react-router\";let routes = ( &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/users\"&gt; &lt;Users /&gt; &lt;/Route&gt; &lt;Redirect from=\"/accounts\" to=\"/users\" /&gt; &lt;Route&gt; &lt;NoMatch /&gt; &lt;/Route&gt; &lt;/Switch&gt;);","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/Router","slug":"react_router/Api/Router","date":"2020-01-10T08:05:24.784Z","updated":"2020-01-11T08:56:31.951Z","comments":true,"path":"2020/01/10/react_router/Api/Router/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/Api/Router/","excerpt":"","text":"Router所有路由器组件的通用底层接口。通常，应用将使用高级路由器之一代替： &lt;BrowserRouter&gt; &lt;HashRouter&gt; &lt;MemoryRouter&gt; &lt;NativeRouter&gt; &lt;StaticRouter&gt; 使用底层&lt;Router&gt;的最常见用例是将自定义历史记录与状态管理库（如Redux或Mobx）进行同步。请注意，并不需要将状态管理库与React Router一起使用，它仅用于深度集成。 12345678910111213import React from \"react\";import ReactDOM from \"react-dom\";import &#123; Router &#125; from \"react-router\";import &#123; createBrowserHistory &#125; from \"source/_posts/react_router/Api/history\";const history = createBrowserHistory();ReactDOM.render( &lt;Router history=&#123;history&#125;&gt; &lt;App /&gt; &lt;/Router&gt;, node); history: object用于导航的历史对象。 1234567import React from \"react\";import ReactDOM from \"react-dom\";import &#123; createBrowserHistory &#125; from \"history\";const customHistory = createBrowserHistory();ReactDOM.render(&lt;Router history=&#123;customHistory&#125; /&gt;, node); children: node要渲染的子元素。 123 &lt;Router&gt; &lt;App /&gt;&lt;/Router&gt;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/Api/Route","slug":"react_router/Api/Route","date":"2020-01-10T07:11:34.794Z","updated":"2020-01-10T08:04:14.469Z","comments":true,"path":"2020/01/10/react_router/Api/Route/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/Api/Route/","excerpt":"","text":"Route render methods建议使用&lt;Route&gt;渲染某些内容的方法是使用子元素，如上所示。但是，还有一些其他方法可用于使用&lt;Route&gt;渲染内容。提供这些主要是为了支持在引入hook之前使用早期版本的路由器构建的应用程序。 &lt;Route component&gt; &lt;Route render&gt; &lt;Route children&gt; function您应该在给定的上仅使用这些道具之一。请参阅下面的说明以了解它们之间的区别。 Route props所有这三种渲染方法将通过相同的三个路由道具。 match location history component一个仅在位置匹配时才呈现的React组件。它将与路线道具一起渲染。 123456789101112131415import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Route &#125; from \"react-router-dom\";// All route props (match, location and history) are available to Userfunction User(props) &#123; return &lt;h1&gt;Hello &#123;props.match.params.username&#125;!&lt;/h1&gt;;&#125;ReactDOM.render( &lt;Router&gt; &lt;Route path=\"/user/:username\" component=&#123;User&#125; /&gt; &lt;/Router&gt;, node); 当您使用组件（而不是下面的渲染器或子组件）时，路由器会使用React.createElement从给定的组件中创建一个新的React元素。这意味着，如果您向组件prop提供内联函数，则将在每个渲染中创建一个新组件。这将导致现有组件的卸载和新组件的安装，而不仅仅是更新现有组件。使用内联函数进行内联渲染时，请使用render或children道具（如下）。 render: func这样可以方便地进行内联渲染和包装，而无需进行上述不必要的重新安装。无需使用组件prop为您创建新的React元素，而是可以传递位置匹配时要调用的函数。渲染道具功能可以访问与组件渲染道具相同的所有路线道具（匹配，位置和历史）。 123456789101112131415161718192021222324252627282930313233import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Route &#125; from \"react-router-dom\";// convenient inline renderingReactDOM.render( &lt;Router&gt; &lt;Route path=\"/home\" render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125; /&gt; &lt;/Router&gt;, node);// wrapping/composing// You can spread routeProps to make them available to your rendered Componentfunction FadingRoute(&#123; component: Component, ...rest &#125;) &#123; return ( &lt;Route &#123;...rest&#125; render=&#123;routeProps =&gt; ( &lt;FadeIn&gt; &lt;Component &#123;...routeProps&#125; /&gt; &lt;/FadeIn&gt; )&#125; /&gt; );&#125;ReactDOM.render( &lt;Router&gt; &lt;FadingRoute path=\"/cool\" component=&#123;Something&#125; /&gt; &lt;/Router&gt;, node); 警告：&lt;Route组件&gt;优先于&lt;Route渲染&gt;，因此请勿在同一&lt;Route&gt;中同时使用两者。 children: func有时您需要渲染路径是否与位置匹配。在这种情况下，您可以使用child道具功能。它与render完全一样，除了是否存在匹配项而被调用。 子级渲染道具将接收与组件和渲染方法相同的所有路由道具，除非当路线未能与URL匹配时，则match为null。这使您可以根据路由是否匹配来动态调整UI。如果路线匹配，我们在此处添加一个活动班级。 123456789101112131415161718192021222324252627282930import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Link, Route&#125; from \"react-router-dom\";function ListItemLink(&#123; to, ...rest &#125;) &#123; return ( &lt;Route path=&#123;to&#125; children=&#123;(&#123; match &#125;) =&gt; ( &lt;li className=&#123;match ? \"active\" : \"\"&#125;&gt; &lt;Link to=&#123;to&#125; &#123;...rest&#125; /&gt; &lt;/li&gt; )&#125; /&gt; );&#125;ReactDOM.render( &lt;Router&gt; &lt;ul&gt; &lt;ListItemLink to=\"/somewhere\" /&gt; &lt;ListItemLink to=\"/somewhere-else\" /&gt; &lt;/ul&gt; &lt;/Router&gt;, node); 这对于动画也可能有用： 123456789&lt;Route children=&#123;(&#123; match, ...rest &#125;) =&gt; ( &#123;/* Animate will always render, so you can use lifecycles to animate its child in and out */&#125; &lt;Animate&gt; &#123;match &amp;&amp; &lt;Something &#123;...rest&#125;/&gt;&#125; &lt;/Animate&gt; )&#125;/&gt; 警告：&lt;Route children&gt;优先于&lt;Route component&gt;和&lt;Route render&gt;，因此请不要在同一&lt;Route&gt;中使用多个 path: string | string[]path-to-regexp@^1.7.0可以理解的任何有效URL路径或路径数组。 123&lt;Route path=\"/users/:id\"&gt; &lt;User /&gt;&lt;/Route&gt; 123&lt;Route path=&#123;[\"/users/:id\", \"/profile/:id\"]&#125;&gt; &lt;User /&gt;&lt;/Route&gt; 没有路径的路线总是匹配的。 exact: boolexact:true时，只有在路径与location.pathname完全匹配时才匹配 path location.pathname exact matches ? /one /one/two true no /one /one/two false yes strict: bool设置为true时，带有斜杠的路径将只匹配带有斜杠的location.pathname。当location.pathname中有其他URL段时，这无效。 123 &lt;Route strict path=\"/one/\"&gt; &lt;About /&gt;&lt;/Route&gt;| path | location.pathname | matches? || :———— | :———— | :———— ||/one/ |/one/ | no || /one/ | /one/ | yes || /one/ | /one/two | yes | 警告：strict可以用于强制location.pathname不带斜杠，但是要做到这一点，strict和精确都必须为真。 123&lt;Route exact strict path=\"/one\"&gt; &lt;About /&gt;&lt;/Route&gt; path location.pathname matches? /one/ /one/ yes /one/ /one/ no /one/ /one/two no location: object&lt;Route&gt;元素尝试将其路径与当前历史记录位置（通常是当前浏览器URL）匹配。但是，也可以传递路径名不同的位置进行匹配。 如需要将&lt;Route&gt;匹配到当前历史记录位置以外的位置时，这很有用，如Animated Transitions示例所示。 如果&lt;Route&gt;元素包装在&lt;Switch&gt;中并且与传递给&lt;Switch&gt;的位置（或当前历史记录位置）相匹配，则传递给&lt;Route&gt;的位置prop将被（在此处给出）。 sensitive: bool为true时，如果路径区分大小写，则将匹配。 123&lt;Route sensitive path=\"/one\"&gt; &lt;About /&gt;&lt;/Route&gt; path location.pathname sensitive matches? /one /one/two true no /one /one/two false yes","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/custom_link","slug":"react_router/examples/custom_link","date":"2020-01-10T06:58:03.375Z","updated":"2020-01-13T10:42:32.359Z","comments":true,"path":"2020/01/10/react_router/examples/custom_link/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/examples/custom_link/","excerpt":"","text":"harmony1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useRouteMatch&#125; from \"react-router-dom\";// 这个实力显示的是如何自定义// &lt;Link&gt; 会在url中呈现特殊内容// 与&lt;Link&gt;指向的对象相同export default function CustomLinkExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;OldSchoolMenuLink activeOnlyWhenExact=&#123;true&#125; to=\"/\" label=\"Home\" /&gt; // &lt;OldSchoolMenuLink to=\"/about\" label=\"About\" /&gt; &lt;hr /&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function OldSchoolMenuLink(&#123; label, to, activeOnlyWhenExact &#125;) &#123; let match = useRouteMatch(&#123; path: to, exact: activeOnlyWhenExact &#125;); return ( &lt;div className=&#123;match ? \"active\" : \"\"&#125;&gt; &#123;match &amp;&amp; \"&gt; \"&#125; &lt;Link to=&#123;to&#125;&gt;&#123;label&#125;&lt;/Link&gt; &lt;/div&gt; );&#125;function Home() &#123; return ( &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/div&gt; );&#125;function About() &#123; return ( &lt;div&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/redirect","slug":"react_router/examples/redirect","date":"2020-01-09T16:09:15.461Z","updated":"2020-01-09T16:10:59.700Z","comments":true,"path":"2020/01/10/react_router/examples/redirect/","link":"","permalink":"http://yoursite.com/2020/01/10/react_router/examples/redirect/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, Redirect, useHistory, useLocation&#125; from \"react-router-dom\";// 这个例子有3个页面: 一个公共的, 一个受保护的// 页面, 和一个登陆屏幕. 为了看到受保护的页面, 你必须第一次使用. 相当标准的东西.// 首先, 访问 公共页面. 然后, 访问protected页面 .你没有登陆的话, 所以你被重定向到login页面.登录后, 你被重定向返回到受保护的页面.// 注意URL每次都会变.在此刻如果你点击返回按钮, 你是否希望回到登录页面? 不! 你已经登陆了. 试试看,// 您会看到您返回到您的访问页面仅在登陆之前的页面。export default function AuthExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;AuthButton /&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/public\"&gt;Public Page&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/protected\"&gt;Protected Page&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=\"/public\"&gt; &lt;PublicPage /&gt; &lt;/Route&gt; &lt;Route path=\"/login\"&gt; &lt;LoginPage /&gt; &lt;/Route&gt; &lt;PrivateRoute path=\"/protected\"&gt; &lt;ProtectedPage /&gt; &lt;/PrivateRoute&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;const fakeAuth = &#123; isAuthenticated: false, authenticate(cb) &#123; fakeAuth.isAuthenticated = true; setTimeout(cb, 100); // fake async &#125;, signout(cb) &#123; fakeAuth.isAuthenticated = false; setTimeout(cb, 100); &#125;&#125;;function AuthButton() &#123; let history = useHistory(); return fakeAuth.isAuthenticated ? ( &lt;p&gt; Welcome!&#123;\" \"&#125; &lt;button onClick=&#123;() =&gt; &#123; fakeAuth.signout(() =&gt; history.push(\"/\")); &#125;&#125; &gt; Sign out &lt;/button&gt; &lt;/p&gt; ) : ( &lt;p&gt;You are not logged in.&lt;/p&gt; );&#125;//&lt;Route&gt;的包装器，重定向到登录屏幕，如果您尚未通过身份验证。function PrivateRoute(&#123; children, ...rest &#125;) &#123; return ( &lt;Route &#123;...rest&#125; render=&#123;(&#123; location &#125;) =&gt; fakeAuth.isAuthenticated ? ( children ) : ( &lt;Redirect to=&#123;&#123; pathname: \"/login\", state: &#123; from: location &#125; &#125;&#125; /&gt; ) &#125; /&gt; );&#125;function PublicPage() &#123; return &lt;h3&gt;Public&lt;/h3&gt;;&#125;function ProtectedPage() &#123; return &lt;h3&gt;Protected&lt;/h3&gt;;&#125;function LoginPage() &#123; let history = useHistory(); let location = useLocation(); //useLocation挂钩返回代表当前URL的位置对象。 let &#123; from &#125; = location.state || &#123; from: &#123; pathname: \"/\" &#125; &#125;; let login = () =&gt; &#123; fakeAuth.authenticate(() =&gt; &#123; history.replace(from); &#125;); &#125;; return ( &lt;div&gt; &lt;p&gt;You must log in to view the page at &#123;from.pathname&#125;&lt;/p&gt; &lt;button onClick=&#123;login&#125;&gt;Log in&lt;/button&gt; &lt;/div&gt; );&#125; 这可能非常有用，例如在您希望每次加载新页面时都使用Web分析工具触发新的“页面浏览”事件的情况下，如以下示例所示：","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/嵌套","slug":"react_router/examples/嵌套","date":"2020-01-09T14:54:50.396Z","updated":"2020-01-09T15:12:17.179Z","comments":true,"path":"2020/01/09/react_router/examples/嵌套/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/examples/%E5%B5%8C%E5%A5%97/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useParams, useRouteMatch&#125; from \"react-router-dom\";// 路线是常规的React组件, 他们可以在程序中的任何位置呈现。包含element的子元素。// 当需要对代码分割时，会有所帮助。代码分割分成多个bundle,React router与代码拆分任何其他 React app 是相同.export default function NestingExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/topics\"&gt;Topics&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/topics\"&gt; &lt;Topics /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Home() &#123; return ( &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/div&gt; );&#125;function Topics() &#123; // The `path` 让我构建 &lt;Route&gt; 路径，那是相对于父Route,而url允许让我们建立相对links let &#123; path, url &#125; = useRouteMatch(); return ( &lt;div&gt; &lt;h2&gt;Topics&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;url&#125;/rendering`&#125;&gt;Rendering with React&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;url&#125;/components`&#125;&gt;Components&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;url&#125;/props-v-state`&#125;&gt;Props v. State&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route exact path=&#123;path&#125;&gt; &lt;h3&gt;Please select a topic.&lt;/h3&gt; &lt;/Route&gt; &lt;Route path=&#123;`$&#123;path&#125;/:topicId`&#125;&gt; &lt;Topic /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125;function Topic() &#123; /* The &lt;Route&gt; 呈现此组件&lt;Route&gt;具有 `/topics/:topicId`. The `:topicId` 部分的网址表示一个占位符，我们可以从 `useParams()`获取.*/ let &#123; topicId &#125; = useParams(); return ( &lt;div&gt; &lt;h3&gt;&#123;topicId&#125;&lt;/h3&gt; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/url_parameters","slug":"react_router/examples/url_parameters","date":"2020-01-09T14:18:16.942Z","updated":"2020-01-13T08:42:53.369Z","comments":true,"path":"2020/01/09/react_router/examples/url_parameters/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/examples/url_parameters/","excerpt":"","text":"harmony12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useParams&#125; from \"react-router-dom\";&#123;/*参数是URL开头的占位符 冒号，例如`：id`在这个实例中的路线。 相似的用于匹配其他动态细分流行的Web框架，例如 Rails and Express */&#125; export default function ParamsExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;h2&gt;Accounts&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/netflix\"&gt;Netflix&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/zillow-group/3331\"&gt;Zillow Group&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/yahoo\"&gt;Yahoo&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/modus-create\"&gt;Modus Create&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=\"/:id\" children=&#123;&lt;Child /&gt;&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Child() &#123; // 我们可以在这里使用`useParams`钩子来访问 // the URL的动态片段 let &#123; id &#125; = useParams(); return ( &lt;div&gt; &lt;h3&gt;ID: &#123;id&#125;&lt;/h3&gt; &lt;/div&gt; );&#125; 123456789101112import &#123; Route &#125; from \"react-router-dom\";function BlogPost() &#123; return ( &lt;Route path=\"/blog/:slug\" render=&#123;(&#123; match &#125;) =&gt; &#123; return &lt;div /&gt;; &#125;&#125; /&gt; );&#125; 你可以 1234567import &#123; useRouteMatch &#125; from \"react-router-dom\";function BlogPost() &#123; let match = useRouteMatch(\"/blog/:slug\"); return &lt;div /&gt;;&#125; useParams返回URL参数的键/值对的对象。使用它来访问当前&lt;Route&gt;的match.params。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/examples/Basic","slug":"react_router/examples/Basic","date":"2020-01-09T14:02:48.489Z","updated":"2020-01-09T14:36:09.022Z","comments":true,"path":"2020/01/09/react_router/examples/Basic/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/examples/Basic/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link&#125; from \"react-router-dom\";&#123;/*本网站共有3页，所有页面均已呈现 在浏览器中动态显示（不呈现服务器）。尽管页面永远不会刷新，但请注意 当您浏览时，React Router使URL保持最新 通过网站. 保留 the browser history, making sure 后退按钮和书签之类的东西*/&#125; export default function BasicExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &#123;/* &lt;Switch&gt;遍历其所有子节点&lt;Route&gt; elements and renders 第一个路径 matches the current URL. 随时使用 a &lt;Switch&gt; 你有很多的routes, but you want 一个一次渲染 */&#125; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/dashboard\"&gt; &lt;Dashboard /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;// 你可以将这些组件视为页面// in your app.function Home() &#123; return ( &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/div&gt; );&#125;function About() &#123; return ( &lt;div&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;/div&gt; );&#125;function Dashboard() &#123; return ( &lt;div&gt; &lt;h2&gt;Dashboard&lt;/h2&gt; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Static_Routes","slug":"react_router/指南/Static_Routes","date":"2020-01-09T08:43:22.856Z","updated":"2020-01-09T08:44:37.778Z","comments":true,"path":"2020/01/09/react_router/指南/Static_Routes/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Static_Routes/","excerpt":"","text":"Static Routes以前版本的React Router使用静态路由来配置应用程序的路由。这样可以在渲染之前检查和匹配路线。由于v4转移到动态组件而不是路由配置，因此一些以前的用例变得不那么明显和棘手。 我们正在开发一个可与静态路由配置和React Router配合使用的软件包，以继续满足这些用例。现在正在开发中，但我们希望您能尝试一下并提供帮助。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Redux整合","slug":"react_router/指南/Redux整合","date":"2020-01-09T08:35:56.819Z","updated":"2020-01-09T08:43:04.840Z","comments":true,"path":"2020/01/09/react_router/指南/Redux整合/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Redux%E6%95%B4%E5%90%88/","excerpt":"","text":"Redux整合Redux是React生态系统的重要组成部分。对于想要同时使用React Router和Redux的人，我们希望使其无缝集成。 阻止的更新通常，React Router和Redux可以很好地协同工作。不过，有时候，应用程序的组件可能会在位置更改时（子路线或活动的导航链接不更新）不更新。 在以下情况下会发生这种情况： 1.该组件通过connect（）（Comp）连接到redux。 2.该组件不是“路由组件”，这意味着它的呈现方式不是这样：&lt;Route component = {SomeConnectedThing} /&gt; 问题在于Redux实现了shouldComponentUpdate，如果没有从路由器接收道具，则没有任何迹象表明发生了任何变化。这很容易解决。查找连接组件的位置，然后将其与Router包装在一起。 123456// beforeexport default connect(mapStateToProps)(Something)// afterimport &#123; withRouter &#125; from 'react-router-dom'export default withRouter(connect(mapStateToProps)(Something)) 深度整合有些人想： 1.与商店同步并从商店访问路由数据。 2.能够通过调度动作进行导航。 3.在Redux devtools中支持对路径更改进行时间旅行调试。 所有这些都需要更深入的集成。 我们的建议是不要将路线完全保留在Redux商店中。推理: 1.路由数据已经成为大多数关心它的组件的支持。无论是来自商店还是路由器，您组件的代码都基本相同。 2.在大多数情况下，您可以使用链接，导航链接和重定向来执行导航操作。有时，在某些最初由操作启动的异步任务之后，您可能还需要以编程方式导航。例如，您可以在用户提交登录表单时调度操作。然后，您的重击，传奇或其他异步处理程序会对凭据进行身份验证，如果成功，则需要以某种方式导航到新页面。此处的解决方案只是将历史对象（提供给所有路由组件）包括在操作的有效负载中，并且异步处理程序可以在适当的时候使用此对象进行导航。 3.路线更改对于时间旅行调试不太重要。唯一明显的情况是调试路由器/商店同步中的问题，如果根本不同步它们，则该问题将消失。 但是，如果您强烈希望与商店同步路由，则可以尝试使用Connected React Router，这是React Router v4和Redux的第三方绑定。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Testing","slug":"react_router/指南/Testing","date":"2020-01-09T08:20:30.143Z","updated":"2020-01-09T08:35:00.942Z","comments":true,"path":"2020/01/09/react_router/指南/Testing/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Testing/","excerpt":"","text":"TestingReact Router依靠React上下文来工作。这会影响您如何测试使用我们的组件的组件。 Context如果您尝试对呈现&lt;Link&gt;或&lt;Route&gt;等的组件之一进行单元测试，则会收到一些有关上下文的错误和警告。虽然您可能会想自己尝试添加路由器上下文，但是我们建议您将单元测试包装在以下路由器组件之一中：具有历史记录属性的基本路由器，或&lt;StaticRouter&gt;，&lt;MemoryRouter&gt;或&lt;BrowserRouter&gt;（如果window.history在测试环境中可用作全局变量）。 建议使用MemoryRouter或自定义历史记录，以便能够在两次测试之间重置路由器。 1234567891011121314151617181920212223242526272829303132333435class Sidebar extends Component &#123; // ... render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.toggleExpand&#125;&gt;expand&lt;/button&gt; &lt;ul&gt; &#123;users.map(user =&gt; ( &lt;li&gt; &lt;Link to=&#123;user.path&#125;&gt;&#123;user.name&#125;&lt;/Link&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;// brokentest(\"it expands when the button is clicked\", () =&gt; &#123; render(&lt;Sidebar /&gt;); click(theButton); expect(theThingToBeOpen);&#125;);// fixedtest(\"it expands when the button is clicked\", () =&gt; &#123; render( &lt;MemoryRouter&gt; &lt;Sidebar /&gt; &lt;/MemoryRouter&gt; ); click(theButton); expect(theThingToBeOpen);&#125;); 从特定路线开始&lt;MemoryRouter&gt;支持initialEntries和initialIndex道具，因此您可以在特定位置启动应用程序（或应用程序的任何较小部分）。 12345678test(\"current user is active in sidebar\", () =&gt; &#123; render( &lt;MemoryRouter initialEntries=&#123;[\"/users/2\"]&#125;&gt; &lt;Sidebar /&gt; &lt;/MemoryRouter&gt; ); expectUserToBeActive(2);&#125;); Navigating我们进行了很多测试，以检查路线在位置更改时是否有效，因此您可能不需要测试这些东西。但是，如果您需要在应用程序中测试导航，则可以这样进行： 123456789101112131415161718192021222324252627282930// app.js (a component file)import React from \"react\";import &#123; Route, Link &#125; from \"react-router-dom\";// our 项目, the App, but you can test any 子项// 部分 of your app tooconst App = () =&gt; ( &lt;div&gt; &lt;Route exact path=\"/\" render=&#123;() =&gt; ( &lt;div&gt; &lt;h1&gt;Welcome&lt;/h1&gt; &lt;/div&gt; )&#125; /&gt; &lt;Route path=\"/dashboard\" render=&#123;() =&gt; ( &lt;div&gt; &lt;h1&gt;Dashboard&lt;/h1&gt; &lt;Link to=\"/\" id=\"click-me\"&gt; Home &lt;/Link&gt; &lt;/div&gt; )&#125; /&gt; &lt;/div&gt;); 12345678910111213141516171819202122232425262728293031// 您也可以使用 a renderer like \"@testing-library/react\" or \"enzyme/mount\" hereimport &#123; render, unmountComponentAtNode &#125; from \"react-dom\";import &#123; act &#125; from 'react-dom/test-utils';import &#123; MemoryRouter &#125; from \"react-router-dom\";// app.test.jsit(\"navigates home when you click the logo\", async =&gt; &#123; // in a real test a renderer like \"@testing-library/react\" // would 负责设置 the DOM elements const root = document.createElement('div'); document.body.appendChild(root); // Render app render( &lt;MemoryRouter initialEntries=&#123;['/my/initial/route']&#125;&gt; &lt;App /&gt; &lt;MemoryRouter&gt;, root ); // 页面互动 act(() =&gt; &#123; // 查找链接（可能使用文本内容） const goHomeLink = document.querySelector('#nav-logo-home'); // Click it goHomeLink.dispatchEvent(new MouseEvent(\"click\", &#123; bubbles: true &#125;)); &#125;); // 检查显示的页面内容是否正确 expect(document.body.textContent).toBe('Home');&#125;); 检查测试中的位置您不必在测试中经常访问位置或历史记录对象，但如果这样做（例如，验证是否在url栏中设置了新的查询参数），则可以添加一条路由来更新测试中的变量： 12345678910111213141516171819202122232425262728// app.test.jstest(\"clicking filter links updates product query params\", () =&gt; &#123; let history, location; render( &lt;MemoryRouter initialEntries=&#123;[\"/my/initial/route\"]&#125;&gt; &lt;App /&gt; &lt;Route path=\"*\" render=&#123;(&#123; history, location &#125;) =&gt; &#123; history = history; location = location; return null; &#125;&#125; /&gt; &lt;/MemoryRouter&gt;, node ); act(() =&gt; &#123; // example: click a &lt;Link&gt; to /products?id=1234 &#125;); // assert about url expect(location.pathname).toBe(\"/products\"); const searchParams = new URLSearchParams(location.search); expect(searchParams.has(\"id\")).toBe(true); expect(searchParams.get(\"id\")).toEqual(\"1234\");&#125;); 备选方案 如果您的测试环境具有浏览器全局变量window.location和window.history（这是通过JSDOM在Jest中的默认设置，但您无法重置测试之间的历史记录），则也可以使用BrowserRouter。 您可以将基本路由器与历史包中的历史道具一起使用，而不是将自定义路由传递给MemoryRouter 1234567891011121314// app.test.jsimport &#123; createMemoryHistory &#125; from \"history\";import &#123; Router &#125; from \"react-router\";test(\"redirects to login page\", () =&gt; &#123; const history = createMemoryHistory(); render( &lt;Router history=&#123;history&#125;&gt; &lt;App signedInUser=&#123;null&#125; /&gt; &lt;/Router&gt;, node ); expect(history.location.pathname).toBe(\"/login\");&#125;); React测试库","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Philosophy","slug":"react_router/指南/Philosophy","date":"2020-01-09T07:45:24.676Z","updated":"2020-01-09T08:10:48.855Z","comments":true,"path":"2020/01/09/react_router/指南/Philosophy/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Philosophy/","excerpt":"","text":"Philosophy本指南的目的是说明使用React Router时要具有的思维模型。我们称之为“动态路由”，它与您可能更熟悉的“静态路由”完全不同。 静态路由如果您使用过Rails，Express，Ember，Angular等，则使用了静态路由。在这些框架中，您需要在进行任何渲染之前将路由声明为应用初始化的一部分。React Router pre-v4也是静态的（大部分是静态的）。让我们看一下如何快速配置路由： 1234567// Express Style routing:app.get(\"/\", handleIndex);app.get(\"/invoices\", handleInvoices);app.get(\"/invoices/:id\", handleInvoice);app.get(\"/invoices/:id/edit\", handleInvoiceEdit);app.listen(); 请注意在应用监听之前如何声明路由。我们使用的客户端路由器相似。在Angular中，您先声明路线，然后在渲染之前将其导入顶级AppModule： 123456789101112131415161718192021222324252627282930// Angular Style routing:const appRoutes: Routes = [ &#123; path: \"crisis-center\", component: CrisisListComponent &#125;, &#123; path: \"hero/:id\", component: HeroDetailComponent &#125;, &#123; path: \"heroes\", component: HeroListComponent, data: &#123; title: \"Heroes List\" &#125; &#125;, &#123; path: \"\", redirectTo: \"/heroes\", pathMatch: \"full\" &#125;, &#123; path: \"**\", component: PageNotFoundComponent &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(appRoutes)]&#125;)export class AppModule &#123;&#125; Ember具有常规的route.js文件，该版本会为您读取并导入到应用程序中。同样，这是在您的应用渲染之前发生的。 12345678910// Ember Style Router:Router.map(function() &#123; this.route(\"about\"); this.route(\"contact\"); this.route(\"rentals\", function() &#123; this.route(\"show\", &#123; path: \"/:rental_id\" &#125;); &#125;);&#125;);export default Router; 尽管API不同，但它们都共享“静态路由”模型。React Router也跟进了直到v4。 为了成功使用React Router，您需要忘记所有这些！：O Backstory坦率地说，我们对v2采取React Router的方向感到非常沮丧。我们（Michael和Ryan）感到受API的限制，认识到我们正在重新实现React的各个部分（生命周期等），而这与React为构建UI提供的思维模型不符。 我们正要经过车间讨论要怎么做的研讨会前的酒店走廊。我们互相问：“如果使用我们在讲习班中教授的模式建造路由器，那会是什么样？” 仅仅几个小时的开发时间，我们就获得了概念证明，我们知道这是我们想要路由的未来。我们最终得到的API并不是React的“外部”，它是由React的其余部分组成或自然地融入其中的。我们认为您会喜欢的。 动态 Routing当说动态路由时，是指在您的应用渲染时发生的路由，而不是在运行的应用之外的配置或约定中进行。这意味着几乎所有内容都是React Router中的一个组件。这是对该API的60秒回顾，以了解其工作原理： 首先，为您要定位的环境获取一个Router组件，并将其呈现在应用程序的顶部。 123456789101112// react-nativeimport &#123; NativeRouter &#125; from \"react-router-native\";// react-dom (what we'll use here)import &#123; BrowserRouter &#125; from \"react-router-dom\";ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, el); 接下来，获取链接组件以链接到新位置： 1234567const App = () =&gt; ( &lt;div&gt; &lt;nav&gt; &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt; &lt;/nav&gt; &lt;/div&gt;); 最后，渲染一个Route以在用户访问/ dashboard时显示一些UI。 12345678910const App = () =&gt; ( &lt;div&gt; &lt;nav&gt; &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt; &lt;/nav&gt; &lt;div&gt; &lt;Route path=\"/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;/div&gt; &lt;/div&gt;); 路线将渲染&lt;Dashboard {… props} /&gt;，其中道具是路由器特定的东西，看起来像{匹配，位置，历史}。如果用户不在/ dashboard上，则Route将呈现null。差不多就够了。 嵌套路线许多路由器都具有“嵌套路由”的概念。如果您使用了v4之前的React Router版本，那么您也会知道它也是如此！当您从静态路由配置转移到动态渲染的路由时，如何“嵌套路由”？好吧，如何嵌套div？ 12345678910111213141516171819const App = () =&gt; ( &lt;BrowserRouter&gt; &#123;/* here's a div */&#125; &lt;div&gt; &#123;/* here's a Route */&#125; &lt;Route path=\"/tacos\" component=&#123;Tacos&#125; /&gt; &lt;/div&gt; &lt;/BrowserRouter&gt;);// 当网址与`/ tacos`相匹配时，此组件呈现const Tacos = (&#123; match &#125;) =&gt; ( // here's a nested div &lt;div&gt; &#123;/* here's a 嵌套 Route, match.url 帮助我们建立相对的路径 */&#125; &lt;Route path=&#123;match.url + \"/carnitas\"&#125; component=&#123;Carnitas&#125; /&gt; &lt;/div&gt;); 看看路由器如何没有“嵌套” API？就像div一样，Route只是一个组件。因此，要嵌套一个Route或一个div，您只需…做就可以了。 响应路线考虑用户导航到’ /invoices ‘。您的应用程序适应不同的屏幕尺寸，它们的视口狭窄，因此您只向他们显示发票清单和发票仪表板的链接。他们可以从那里更深入地导航。 123456789101112131415161718192021222324Small Screenurl: &#x2F;invoices+----------------------+| || Dashboard || |+----------------------+| || Invoice 01 || |+----------------------+| || Invoice 02 || |+----------------------+| || Invoice 03 || |+----------------------+| || Invoice 04 || |+----------------------+ 在较大的屏幕上，我们想显示一个主从视图，其中导航在左侧，仪表板或特定发票在右侧。 123456789101112131415161718192021222324Large Screenurl: &#x2F;invoices&#x2F;dashboard+----------------------+---------------------------+| | || Dashboard | || | Unpaid: 5 |+----------------------+ || | Balance: $53,543.00 || Invoice 01 | || | Past Due: 2 |+----------------------+ || | || Invoice 02 | || | +-------------------+ |+----------------------+ | | || | | + + + | || Invoice 03 | | | + | | | || | | | | | + | + | |+----------------------+ | | | | | | | | || | +--+-+--+--+--+--+--+ || Invoice 04 | || | |+----------------------+---------------------------+ 现在暂停一分钟，并考虑两种屏幕尺寸的 /invoices 网址。它甚至是大屏幕的有效路线吗？我们应该在右边放什么？ 1234567891011121314151617181920212223Large Screenurl: &#x2F;invoices+----------------------+---------------------------+| | || Dashboard | || | |+----------------------+ || | || Invoice 01 | || | |+----------------------+ || | || Invoice 02 | ??? || | |+----------------------+ || | || Invoice 03 | || | |+----------------------+ || | || Invoice 04 | || | |+----------------------+---------------------------+ 在大屏幕上，/invoices 不是有效的路径，但在小屏幕上则是！为了使事情变得更有趣，请考虑使用大型手机的人。他们可能会纵向查看/发票，然后将手机旋转至横向。突然，我们有足够的空间来显示主从界面，因此您应该立即进行重定向！ React Router以前版本的静态路由并没有真正解决这个问题的方法。但是，当路由是动态的时，您可以声明性地组合此功能。如果您开始考虑将路由选择为UI，而不是静态配置，那么您的直觉将引导您进入以下代码 123456789101112131415161718192021222324252627282930313233343536373839const App = () =&gt; ( &lt;AppLayout&gt; &lt;Route path=\"/invoices\" component=&#123;Invoices&#125; /&gt; &lt;/AppLayout&gt;);const Invoices = () =&gt; ( &lt;Layout&gt; &#123;/* 总是显示导航 */&#125; &lt;InvoicesNav /&gt; &lt;Media query=&#123;PRETTY_SMALL&#125;&gt; &#123;screenIsSmall =&gt; screenIsSmall ? ( // 小屏幕没有重定向 &lt;Switch&gt; &lt;Route exact path=\"/invoices/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"/invoices/:id\" component=&#123;Invoice&#125; /&gt; &lt;/Switch&gt; ) : ( // 大屏幕 &lt;Switch&gt; &lt;Route exact path=\"/invoices/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"/invoices/:id\" component=&#123;Invoice&#125; /&gt; &lt;Redirect from=\"/invoices\" to=\"/invoices/dashboard\" /&gt; &lt;/Switch&gt; ) &#125; &lt;/Media&gt; &lt;/Layout&gt;); 当用户将手机从纵向旋转到横向时，此代码将自动将其重定向到仪表板。有效路线集会根据用户手中移动设备的动态性质而变化。 这只是一个例子。我们可以讨论许多其他内容，但我们将总结以下建议：为了使您的直觉与React Router的直觉相符，请考虑组件而不是静态路由。考虑一下如何使用React的声明式可组合性解决问题，因为几乎每个“ React Router问题”都可能是“ React问题”。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Scroll_Restoration","slug":"react_router/指南/Scroll_Restoration","date":"2020-01-09T06:44:18.843Z","updated":"2020-01-09T07:45:01.256Z","comments":true,"path":"2020/01/09/react_router/指南/Scroll_Restoration/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Scroll_Restoration/","excerpt":"","text":"滚动还原在早期版本的React Router中，我们提供了对滚动恢复的开箱即用的支持，从那以后人们一直在要求它。希望本文档可以帮助您从滚动条和路由中获得所需的信息！ 浏览器开始以自己的history.pushState处理滚动还原，其处理方式与使用普通浏览器导航时的处理方式相同。它已经可以在Chrome浏览器中使用，而且非常棒。这是滚动恢复规范。 由于浏览器开始处理“默认情况”，并且应用具有不同的滚动需求（例如本网站！），因此我们不提供默认滚动管理功能。本指南应帮助您实现任何滚动需求。 滚动到顶部在大多数情况下，您所需要做的只是“滚动到顶部”，因为您有一个较长的内容页面，该页面在导航到该页面时始终保持向下滚动。使用组件可以轻松处理此问题，该组件将在每次导航时向上滚动窗口： 123456789101112import &#123; useEffect &#125; from \"react\";import &#123; useLocation &#125; from \"react-router-dom\";export default function ScrollToTop() &#123; const &#123; pathname &#125; = useLocation(); useEffect(() =&gt; &#123; window.scrollTo(0, 0); &#125;, [pathname]); return null;&#125; 如果您尚未运行React 16.8，则可以使用React.Component子类执行相同的操作： 123456789101112131415161718import React from \"react\";import &#123; withRouter &#125; from \"react-router-dom\";class ScrollToTop extends React.Component &#123; componentDidUpdate(prevProps) &#123; if ( this.props.location.pathname !== prevProps.location.pathname ) &#123; window.scrollTo(0, 0); &#125; &#125; render() &#123; return null; &#125;&#125;export default withRouter(ScrollToTop); 然后将其呈现在您应用的顶部，但在路由器下方 12345678function App() &#123; return ( &lt;Router&gt; &lt;ScrollToTop /&gt; &lt;App /&gt; &lt;/Router&gt; );&#125; 如果您将标签页接口连接到路由器，那么当他们切换标签页时，您可能不想滚动到顶部。相反，关于在您需要的特定位置&lt;ScrollToTopOnMount&gt;？ 12345678910111213141516171819202122import &#123; useEffect &#125; from \"react\";function ScrollToTopOnMount() &#123; useEffect(() =&gt; &#123; window.scrollTo(0, 0); &#125;, []); return null;&#125;// Render this somewhere using:// &lt;Route path=\"...\" children=&#123;&lt;LongContent /&gt;&#125; /&gt;function LongContent() &#123; return ( &lt;div&gt; &lt;ScrollToTopOnMount /&gt; &lt;h1&gt;Here is my long content page&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;/div&gt; );&#125; 再说一次，如果您还没有运行React 16.8，则可以对React.Component子类做同样的事情： 12345678910111213141516171819202122232425class ScrollToTopOnMount extends React.Component &#123; componentDidMount() &#123; window.scrollTo(0, 0); &#125; render() &#123; return null; &#125;&#125;// Render this somewhere using:// &lt;Route path=\"...\" children=&#123;&lt;LongContent /&gt;&#125; /&gt;class LongContent extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ScrollToTopOnMount /&gt; &lt;h1&gt;Here is my long content page&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 通用解决方案对于通用解决方案（以及哪些浏览器已开始在本机实现），我们谈论的是两件事： 向上滚动导航，这样就不会启动滚动到底部的 新屏幕恢复窗口的滚动位置和“后退”和“前进”单击上的溢出元素（但不单击“链接”单击！） 在某一时刻，我们希望提供一个通用的API。这就是我们要去的方向： 12345678910111213&lt;Router&gt; &lt;ScrollRestoration&gt; &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;RestoredScroll id=\"bunny\"&gt; &lt;div style=&#123;&#123; height: \"200px\", overflow: \"auto\" &#125;&#125;&gt; I will overflow &lt;/div&gt; &lt;/RestoredScroll&gt; &lt;/div&gt; &lt;/ScrollRestoration&gt;&lt;/Router&gt; 首先，ScrollRestoration将在导航时向上滚动窗口。 其次，它将使用location.key将窗口滚动位置和RestoredScroll组件的滚动位置保存到sessionStorage。 然后，在安装ScrollRestoration或RestoredScroll组件时，它们可以从sessionStorage查找其位置。 棘手的部分是为不希望管理窗口滚动的情况定义一个“退出” API。例如，如果您在页面内容内浮动了一些标签导航，则可能不想滚动到顶部（这些标签可能会滚出视线！）。 当我们得知Chrome现在可以为我们管理滚动位置，并意识到不同的应用程序将具有不同的滚动需求时，我们有点迷失了我们需要提供某些东西的信念，尤其是当人们只想滚动到顶部时（您可以直接将其直接添加到您的应用中）。 基于此，我们不再有足够的力气自己完成工作（就像您一样，我们的时间有限！）。但是，我们很乐意为有志于实施通用解决方案的任何人提供帮助。一个可靠的解决方案甚至可以存在于项目中。如果您开始使用它，请与我们联系:)","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Code_Splitting","slug":"react_router/指南/Code_Splitting","date":"2020-01-09T06:33:56.160Z","updated":"2020-01-09T06:43:00.133Z","comments":true,"path":"2020/01/09/react_router/指南/Code_Splitting/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Code_Splitting/","excerpt":"","text":"Code Splitting网络的一项重要功能是，我们无需让访问者下载整个应用程序即可使用。您可以将代码拆分视为增量下载应用程序。为了实现这中功能我们要使用 webpack, @babel/plugin-syntax-dynamic-import, and loadable-components. webpack内置了对动态导入的支持；但是，如果您使用的是Babel（例如，将JSX编译为JavaScript），则需要使用@ babel / plugin-syntax-dynamic-import插件。这是仅语法的插件，这意味着Babel不会进行任何其他转换。该插件仅允许Babel解析动态导入，因此webpack可以将它们捆绑为代码拆分。您的.babelrc应该如下所示： 1234&#123; &quot;presets&quot;: [&quot;@babel&#x2F;preset-react&quot;], &quot;plugins&quot;: [&quot;@babel&#x2F;plugin-syntax-dynamic-import&quot;]&#125; loadable-components是用于通过动态导入加载组件的库。它自动处理各种边缘情况，并使代码拆分变得简单！这是有关如何使用可加载组件的示例： 123456789101112import loadable from \"@loadable/component\";import Loading from \"./Loading.js\";const LoadableComponent = loadable(() =&gt; import(\"./Dashboard.js\"), &#123; fallback: &lt;Loading /&gt;&#125;);export default class LoadableDashboard extends React.Component &#123; render() &#123; return &lt;LoadableComponent /&gt;; &#125;&#125; 这里所有都是它的！只需使用LoadableDashboard（或任何您命名的组件），当您在应用程序中使用它时，它将自动加载并呈现。回退是一个占位符组件，用于在加载实际组件时显示。 Code Splitting and Server-Side Renderloadable-components包含服务器端渲染的指南。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Server_Rendering","slug":"react_router/指南/Server_Rendering","date":"2020-01-09T05:36:56.725Z","updated":"2020-01-09T06:28:54.359Z","comments":true,"path":"2020/01/09/react_router/指南/Server_Rendering/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Server_Rendering/","excerpt":"","text":"服务器渲染由于服务器都是无状态的，因此在服务器上的渲染有点不同。基本思想是将应用程序包装在无状态的&lt;StaticRouter&gt;中，而不是在&lt;BrowserRouter&gt;中。我们从服务器传入请求的url，以便路由可以匹配，然后我们将讨论上下文支持。 123456789101112// 客户端&lt;BrowserRouter&gt; &lt;App/&gt;&lt;/BrowserRouter&gt;// 服务器端 (not the complete story)&lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App/&gt;&lt;/StaticRouter&gt; 当您在客户端上呈现&lt;Redirect&gt;时，浏览器历史记录会更改状态，并且我们会获得新屏幕。在静态服务器环境中，我们无法更改应用程序状态。相反，我们使用上下文道具来找出渲染的结果。如果找到context.url，则表明该应用已重定向。这使我们能够从服务器发送适当的重定向。 12345678910111213const context = &#123;&#125;;const markup = ReactDOMServer.renderToString( &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt;);if (context.url) &#123; // 某处 `&lt;Redirect&gt;` 是被重定向的 redirect(301, context.url);&#125; else &#123; // 我们很好，发送响应回复&#125; 添加特定于应用程序的上下文信息路由器仅添加context.url。但是您可能希望将某些重定向重定向为301，将其他重定向重定向为302。或者，如果呈现了UI的某些特定分支，则可能要发送404响应，如果未授权，则要发送401。上下文道具是您的，因此您可以对其进行突变。这是区分301和302重定向的一种方法： 123456789101112131415161718192021222324252627282930313233343536373839404142function RedirectWithStatus(&#123; from, to, status &#125;) &#123; return ( &lt;Route render=&#123;(&#123; staticContext &#125;) =&gt; &#123; // 客户端上没有“ staticContext”，因此 // 我们需要在这里提防 if (staticContext) staticContext.status = status; return &lt;Redirect from=&#123;from&#125; to=&#123;to&#125; /&gt;; &#125;&#125; /&gt; );&#125;// 应用中的某处function App() &#123; return ( &lt;Switch&gt; &#123;/* 其他route */&#125; &lt;RedirectWithStatus status=&#123;301&#125; from=\"/users\" to=\"/profiles\" /&gt; &lt;RedirectWithStatus status=&#123;302&#125; from=\"/courses\" to=\"/dashboard\" /&gt; &lt;/Switch&gt; );&#125;// 在服务器上const context = &#123;&#125;;const markup = ReactDOMServer.renderToString( &lt;StaticRouter context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt;);if (context.url) &#123; // 可以使用 `context.status` 因 // 我们在 RedirectWithStatus 添加了属性 redirect(context.status, context.url);&#125; 404, 401, or any other status我们可以做与上述相同的事情。创建一个添加一些上下文的组件，并将其呈现在应用程序中的任何位置以获取不同的状态代码。 12345678910function Status(&#123; code, children &#125;) &#123; return ( &lt;Route render=&#123;(&#123; staticContext &#125;) =&gt; &#123; if (staticContext) staticContext.status = code; return children; &#125;&#125; /&gt; );&#125; 现在，您可以在要将代码添加到staticContext的应用程序中的任何位置呈现状态。 12345678910111213141516171819function NotFound() &#123; return ( &lt;Status code=&#123;404&#125;&gt; &lt;div&gt; &lt;h1&gt;Sorry, can’t find that.&lt;/h1&gt; &lt;/div&gt; &lt;/Status&gt; );&#125;function App() &#123; return ( &lt;Switch&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; );&#125; Putting it all together这不是一个真正的应用程序，但是它显示了将所有内容组合在一起所需的所有常规内容。 12345678910111213141516171819202122232425262728293031import http from \"http\";import React from \"react\";import ReactDOMServer from \"react-dom/server\";import &#123; StaticRouter &#125; from \"react-router-dom\";import App from \"./App.js\";http .createServer((req, res) =&gt; &#123; const context = &#123;&#125;; const html = ReactDOMServer.renderToString( &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt; ); if (context.url) &#123; res.writeHead(301, &#123; Location: context.url &#125;); res.end(); &#125; else &#123; res.write(` &lt;!doctype html&gt; &lt;div id=\"app\"&gt;$&#123;html&#125;&lt;/div&gt; `); res.end(); &#125; &#125;) .listen(3000); 客户端 1234567891011import ReactDOM from \"react-dom\";import &#123; BrowserRouter &#125; from \"react-router-dom\";import App from \"./App.js\";ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById(\"app\")); 资料载入有许多种不同的方法，而且还没有明确的最佳实践，因此我们力求与任何一种方法融为一体，而不是规定或倾向于任何一种方法。我们相信路由器可以放入您的应用程序约束之内。 主要限制是您要在渲染之前加载数据。React Router导出其内部使用的matchPath静态函数以将位置匹配到路由。您可以在服务器上使用此功能来帮助确定呈现之前的数据依赖关系。 这种方法的要旨是依赖于静态路由配置，该配置既可以呈现您的路由，也可以在呈现之前进行匹配以确定数据依赖性。 12345678const routes = [ &#123; path: \"/\", component: Root, loadData: () =&gt; getSomeData() &#125; // etc.]; 然后使用此配置在应用中呈现您的路线： 1234567891011import &#123; routes &#125; from \"./routes.js\";function App() &#123; return ( &lt;Switch&gt; &#123;routes.map(route =&gt; ( &lt;Route &#123;...route&#125; /&gt; ))&#125; &lt;/Switch&gt; );&#125; 然后，在服务器上您将看到以下内容： 1234567891011121314151617import &#123; matchPath &#125; from \"react-router-dom\";// inside a requestconst promises = [];// use `some` to imitate `&lt;Switch&gt;` behavior of selecting only// the first to matchroutes.some(route =&gt; &#123; // use `matchPath` here const match = matchPath(req.path, route); if (match) promises.push(route.loadData(match)); return match;&#125;);Promise.all(promises).then(data =&gt; &#123; // do something w/ the data so the client // can access it then render the app&#125;); 最后，客户将需要提取数据。同样，我们不为您的应用程序规定数据加载模式，但这是您需要实现的接触点。 您可能对我们的React Router Config软件包感兴趣，以通过静态路由配置协助数据加载和服务器渲染。","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Primary_Components","slug":"react_router/指南/Primary_Components","date":"2020-01-09T04:42:03.343Z","updated":"2020-01-09T05:36:06.684Z","comments":true,"path":"2020/01/09/react_router/指南/Primary_Components/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Primary_Components/","excerpt":"","text":"Primary ComponentsReact Router中的组件主要分为三类： routers,例如 and route匹配，例如 and 导航 例如 , , and 使用的web应运都应从react-router-dom导入。 import { BrowserRouter, Route, Link } from &quot;react-router-dom&quot;; RoutersRouters 每个React Router应用程序的核心应该是路由器组件。对于Web项目，react-router-dom提供 &lt;BrowserRouter&gt;和&lt;HashRouter&gt;路由器。两者之间的主要区别在于它们存储URL和与Web服务器通信的方式。 &lt;BrowserRouter&gt;使用常规URL路径。这些通常是外观最好的URL，但是它们要求正确配置服务器。具体来说，您的Web服务器需要在所有由React Router客户端管理的URL上提供相同的页面。Create React App在开发中即开即用地支持此功能，并附带有关如何配置生产服务器的说明。 &lt;HashRouter&gt;将当前位置存储在URL的哈希部分中，因此URL看起来类似于http://example.com/#/your/page。由于哈希从不发送到服务器，因此这意味着不需要特殊的服务器配置。 要使用路由器，只需确保将其呈现在元素层次结构的根目录下即可。通常，您会将顶级元素包装在路由器中，如下所示： 1234567891011121314import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter &#125; from \"react-router-dom\";function App() &#123; return &lt;h1&gt;Hello React Router&lt;/h1&gt;;&#125;ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById(\"root\")); Route Matchers有两个路由匹配组件：Switch and Route。呈现&lt;Switch&gt;时，它将搜索其子&lt;Route&gt;元素以查找其路径与当前URL匹配的元素。当找到一个时，它将呈现该&lt;Route&gt;并忽略所有其他路由。这意味着您应该将&lt;Route&gt;包含更多特定路径（通常较长）的路径放在不那么特定路径之前。 如果没有匹配，则不呈现任何内容（空） 12345678910111213141516171819202122232425262728293031323334353637383940414243import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Switch, Route&#125; from \"react-router-dom\";function App() &#123; return ( &lt;div&gt; &lt;Switch&gt; &#123;/* 如果当前URL是/ about，则呈现此路由 而其余的则被忽略 */&#125; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &#123;/* 请注意这两个路由的顺序。更具体path =\" / contact /：id\"在path =\" / contact\"之前，因此查看单个联系人时，路线将呈现 */&#125; &lt;Route path=\"/contact/:id\"&gt; &lt;Contact /&gt; &lt;/Route&gt; &lt;Route path=\"/contact\"&gt; &lt;AllContacts /&gt; &lt;/Route&gt; &#123;/* 如果先前的路线都不提供任何东西， 这条路线充当后备路线。 重要提示：路径=\" /\"的路线将*始终*匹配URL，因为所有URL均以/开头。所以那是为什么我们把这一切放在最后 */&#125; &lt;Route path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;Router&gt; &lt;App /&gt; &lt;/Router&gt;, document.getElementById(\"root\")); 需要注意的重要一件事是&lt;Route path&gt;匹配URL的开头，而不是整个开头。因此，&lt;Route path =“ /”&gt;将始终与URL匹配。因此，我们通常将此&lt;Route&gt;放在&lt;Switch&gt;的最后。另一种可能的解决方案是使用确实与整个URL匹配的&lt;Route exact path=&quot;/&quot;&gt;。 注意：尽管React Router确实支持在&lt;Switch&gt;之外渲染&lt;Route&gt;元素，但是从5.1版本开始，我们建议您改用useRouteMatch钩子。此外，我们不建议您渲染不带路径的&lt;Route&gt;，而是建议您使用钩子来访问所需的任何变量。 导航（或路线更改器）React Router提供了一个&lt;Link&gt;组件来在您的应用程序中创建链接。无论在何处呈现&lt;Link&gt;，锚点（&lt;a&gt;）都将呈现在HTML文档中。 12&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;// &lt;a href=\"/\"&gt;Home&lt;/a&gt; &lt;NavLink&gt;是&lt;Link&gt;的一种特殊类型，当其prop与当前位置匹配时，可以将其自身设置为“active”。 123456789&lt;NavLink to=\"/react\" activeClassName=\"hurray\"&gt; React&lt;/NavLink&gt;// 当 URL 是 /react, 呈现:// &lt;a href=\"/react\" className=\"hurray\"&gt;React&lt;/a&gt;// 没有设置成active，呈现：// &lt;a href=\"/react\"&gt;React&lt;/a&gt; 任何时候要强制导航，都可以给予&lt;Redirect&gt;。当&lt;Redirect&gt;呈现时，它将使用其prop进行导航。 1&lt;Redirect to=\"/login\" /&gt;","categories":[],"tags":[],"keywords":[]},{"title":"react_router/指南/Start","slug":"react_router/指南/Start","date":"2020-01-09T04:35:40.087Z","updated":"2020-01-09T04:37:45.995Z","comments":true,"path":"2020/01/09/react_router/指南/Start/","link":"","permalink":"http://yoursite.com/2020/01/09/react_router/%E6%8C%87%E5%8D%97/Start/","excerpt":"","text":"快速开始npm install -g create-react-app 全局安装create-react-app create-react-app可以很方便，快速的帮你搭建react app。 npx create-react-app my-app &amp;&amp; cd my-app // 2. 创建一个react应用项目 或 npm init react-app my-app 或 yarn create react-app my-app 您可以使用npm或yarn从公共npm注册表中安装React Router。由于我们正在构建网络应用程序，因此在本指南中将使用react-router-dom。 npm install react-router-dom 第一个示例： 基本路由。 在此示例中，路由器处理了3个“页面”：主页，“关于”页面和“用户”页面。当您单击不同的&lt;Link&gt;时，路由器将呈现匹配的&lt;Route&gt;。 注意：在幕后，&lt;Link&gt;会使用真实的href渲染&lt;a&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link&#125; from \"react-router-dom\";export default function App() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/users\"&gt;Users&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &#123;/* &lt;Switch&gt;通过子&lt;Route&gt; 查找 呈现与当前URL匹配的第一个。如果有两个相同的URL只渲染一次这个路径不会渲染第二次*/&#125; &lt;Switch&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/users\"&gt; &lt;Users /&gt; &lt;/Route&gt; &lt;Route path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Home() &#123; return &lt;h2&gt;Home&lt;/h2&gt;;&#125;function About() &#123; return &lt;h2&gt;About&lt;/h2&gt;;&#125;function Users() &#123; return &lt;h2&gt;Users&lt;/h2&gt;;&#125; 第二个示例： 这个例子现实的是嵌套路由的方式。路由 ‘/topic’ 加载Topics组件，该组件将在path: id值上有条件地呈现任何其他 Route 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useRouteMatch, useParams&#125; from \"react-router-dom\";export default function App() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/topics\"&gt;Topics&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/topics\"&gt; &lt;Topics /&gt; &lt;/Route&gt; &lt;Route path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Home() &#123; return &lt;h2&gt;Home&lt;/h2&gt;;&#125;function About() &#123; return &lt;h2&gt;About&lt;/h2&gt;;&#125;function Topics() &#123; let match = useRouteMatch();//相对于父路由建立&lt;Route&gt;,而url允许建立相对的links. return ( &lt;div&gt; &lt;h2&gt;Topics&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/components`&#125;&gt;Components&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/props-v-state`&#125;&gt; Props v. State &lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &#123;/*Topics页面有自己的&lt;Switch&gt;里面又包含很多的&lt;Route&gt;,Topics里的&lt;Switch&gt;里面的路径是建立在'/topics'路径上的文件。第二个&lt;Route&gt;作为所有主题的页面或者没有主题时选择的页面 */&#125; &lt;Switch&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:topicId`&#125;&gt; &lt;Topic /&gt; &lt;/Route&gt; &lt;Route path=&#123;match.path&#125;&gt; &lt;h3&gt;Please select a topic.&lt;/h3&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125;function Topic() &#123; let &#123; topicId &#125; = useParams(); return &lt;h3&gt;Requested topic ID: &#123;topicId&#125;&lt;/h3&gt;;&#125;","categories":[],"tags":[],"keywords":[]}]}