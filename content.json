{"meta":{"title":"Title","subtitle":"","description":"","author":"just coding","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"dependency injection","slug":"injection","date":"2020-01-08T12:14:30.000Z","updated":"2020-01-10T15:15:02.607Z","comments":true,"path":"2020/01/08/injection/","link":"","permalink":"http://yoursite.com/2020/01/08/injection/","excerpt":"","text":"golang 的 类型注入. wirehttps://github.com/google/wire 这个框架可以让我们们来实现 依赖注入 . 具体写个例子","categories":[],"tags":[],"keywords":[]},{"title":"db-index","slug":"db-index","date":"2020-01-06T15:22:35.000Z","updated":"2020-01-10T15:15:02.606Z","comments":true,"path":"2020/01/06/db-index/","link":"","permalink":"http://yoursite.com/2020/01/06/db-index/","excerpt":"","text":"一个事务引发的血案真的是理论永远是理论,只有实践了才知道, 最近在写用户注册的服务,由于用户注册的过程中需要在多张表里面插入数据, 因此我用了事务来做这个,ACID 还是知道的, 但是,坑人的是,这些表的主键都是从一个种子表中取得的, 因此,坑就出现了,在事务中,需要多次从种子表中去获取主键(select update 操作) 导致在多个事物中,会争夺对种子表的锁, 死锁就这样产生了, 最后的解决办法,就是提前申请好种子,将申请种子的这个过成放在食物的外面执行,不过我还是觉得用数据库的来做种子还是有问题了,这个可以直接做个服务, 像雪花算法,都是可以在并发情况下生种子的, 索引的问题最近写的接口还是有点慢的,感觉自己对索引这部分的知识还是掌握的不够透彻, 重新再做个总结 为什么我使用了索引，查询还是慢？今天看到篇文章不错,做个读后记录 索引的分类索引有 聚簇索引,联合索引, 主键索引 唯一索引 (在一个字段或者在多个字段上做索引, 这个字段是不会重复的) 主键索引 (这个也是属于唯一索引,primariykey) 聚集索引 / 非聚集索引(该索引的顺序决定了表中数据的物理存储顺序) 组合索引 查看执行计划sql 语句我们可用通过查看执行计划,来看查询的具体实现过程, 是使用了索引还是全表扫描 TODO","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"keywords":[]},{"title":"redis-skiplist","slug":"redis-skiplist","date":"2020-01-06T14:37:02.000Z","updated":"2020-01-10T15:15:02.608Z","comments":true,"path":"2020/01/06/redis-skiplist/","link":"","permalink":"http://yoursite.com/2020/01/06/redis-skiplist/","excerpt":"","text":"AVL 平衡树定义左右子树的高度差不超过1 特性左右子树的值有如下的特性, 因此 AVL 树在查询和排序方面有优越性,时间复杂度是 logn 12left &lt; head &lt;right 一些问题,由于AVL 为了保持, 上面的特性, 因此AVL 树在Insert , Delete 过程中涉及到了,节点的位置调整, 这个也就是左旋,右旋,(我没有弄懂这个,写不出来) skiplistredis 引入跳表是为了解决什么问题为了在大量的数据中位置数据的有序,同时要在数据的查询,删除,过程 取得一个平衡的位置,使得insert, delete 不会有很大的时间复杂度,而跳表具有这个特性, 并且从编码实现方面来说要比红黑书,AVL, B tree , B plus tree 简单的多. redis 在那些地方使用了跳表redis 的有序数据集的底层实现,都使用了跳表 sorted set(有序字典)大概的实现skiplist 就是一个链表其中从链表的一个Node 来看,他是一个高层楼房, 其中每一层 都串联到 同样海拔高度的 Node 的楼房, 那么查找一个数据的过程变变成了从最高的海拔 ,不停的往下找,同时, 选择前进或者后退 https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}],"keywords":[]},{"title":"golang-errors","slug":"golang-errors","date":"2020-01-06T13:22:07.000Z","updated":"2020-01-10T15:15:02.607Z","comments":true,"path":"2020/01/06/golang-errors/","link":"","permalink":"http://yoursite.com/2020/01/06/golang-errors/","excerpt":"","text":"error 只是一个接口的实现我们之前在定义一个错误的时候只需要 实现如下的一个函数签名, 就可以认为这个结构体是一个error 类型的 1234type error interface &#123; Error() string&#125; 如这里的T1 就是一个error 12345678type T1 struct &#123; Desc string&#125;func (t1 T1) Error() string &#123; return fmt.Sprintf(\"T1 error :%s\", t1.Desc)&#125; 1.3 之前的我们catch错误在以前我们经常用nil 去比较代码是否发生错误, 如下面的例子 123456789func main() &#123; var err error err =Throw() if err != nil &#123; panic(err) &#125; fmt.Println(\"right\")&#125; 判断错误的类型要判断错误的来源是那个我们可以使用下面的技术 123456var ErrNotFound = errors.New(\"not found\")if err == ErrNotFound &#123; // something wasn't found&#125; 同样我们也可以使用类型断言,来确定这个错误是由那个具体的对象抛出的 1234if e, ok := err.(*NotFoundError); ok &#123; // e.Name wasn't found&#125; 对于错误的处理一般情况下, 我们不仅仅要catch 错误,为了这些的可读性行更好, 更容易定位问题的出现位置, 我们都会添加一些附加信息, 如下 12345678func UserRegister(name string) error &#123; //..... if err :=register(name); err !=nil &#123; return errors.New(\"用户注册失败\"+err.Error()) &#125;&#125; 上面的只是一个简单的例子, 一些常见的例子,你可能还需要带上包的位置,这样对象这些错误,一旦看到,我们很容易定位到问题发生的具体位置, 对于这个需求有https://github.com/pkg/errors 这个包很有用.可以很方便的实现我们的需求,同样你也可以定义不同的结构体,在合适的位置抛出错误. 我们的需求通过开发的实践, 我们发现上面的2个情况是我们经常面对的, 所以在1.3 的版本对error 的处理,语言自己提供了更多的选择 1.3 之后的我们Unwrap这个方法可以 相当与就是 对error 脱衣服,可以看到衣服下面的具体错误类型,你可以一直让他脱衣服, 一直到他脱光光,通过下面的源码可以看到,这个函数是在递归调用. 12345678910func Unwrap(err error) error &#123; u, ok := err.(interface &#123; Unwrap() error &#125;) if !ok &#123; return nil &#125; return u.Unwrap()&#125; Is这个是为了类型的断言, 我们不需要再使用==去判断错误的具体类型, 只是需要小小的调用Is,传入2个参数,就可以完成,类型判断 12345678910111213141516171819202122232425// 原来errorA == errorB func Is(err, target error) bool &#123; if target == nil &#123; return err == target &#125; isComparable := reflectlite.TypeOf(target).Comparable() for &#123; if isComparable &amp;&amp; err == target &#123; return true &#125; if x, ok := err.(interface&#123; Is(error) bool &#125;); ok &amp;&amp; x.Is(target) &#123; return true &#125; // TODO: consider supporing target.Is(err). This would allow // user-definable predicates, but also may allow for coping with sloppy // APIs, thereby making it easier to get away with them. if err = Unwrap(err); err == nil &#123; return false &#125; &#125;&#125; 你看看这个源码还是使用了反射来判断底层的错误类型,举个使用的例子 12345678func main()&#123; if errors.Is(errorA, errorB)&#123; fmt.Println(\"这个错误是B\") &#125;&#125; As类型断言我们不要了, 我们写的代码更好看了 12345678910func As(err error, target interface&#123;&#125;) bool &#123; val := reflectlite.ValueOf(target) typ := val.Type() if typ.Kind() != reflectlite.Ptr || val.IsNil() &#123; panic(\"errors: target must be a non-nil pointer\") &#125; // ....&#125; 12345if errors.As(errorA,NotFoundError)&#123; fmt.Println(\"errorA 是NotFoundError 的一种类型\")&#125; Wrap 包装错误fmt 包 默认直接输入error 可以自动包装错误了,添加了一个特殊的打印符 12return nil, fmt.Errorf(\"%q: %w\", name, ErrNotFound)","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"http://yoursite.com/tags/Go/"}],"keywords":[]},{"title":"docker-operate","slug":"docker-operate","date":"2020-01-04T06:53:27.000Z","updated":"2020-01-10T15:15:02.607Z","comments":true,"path":"2020/01/04/docker-operate/","link":"","permalink":"http://yoursite.com/2020/01/04/docker-operate/","excerpt":"","text":"停止所有的container1docker stop $(docker ps -q) 清除 所有的docker container1docker rm $(docker ps -a -q) 清除 所有的磁盘挂载1docker volume prune","categories":[],"tags":[{"name":"kubernates","slug":"kubernates","permalink":"http://yoursite.com/tags/kubernates/"}],"keywords":[]},{"title":"rancher-k8s-deploy","slug":"rancher-k8s-deploy","date":"2020-01-03T15:01:27.000Z","updated":"2020-01-10T15:15:02.608Z","comments":true,"path":"2020/01/03/rancher-k8s-deploy/","link":"","permalink":"http://yoursite.com/2020/01/03/rancher-k8s-deploy/","excerpt":"","text":"Rancher install如果之前安装过,需要清理 /opt/rancher 文件夹 docker run -d -p 80:80 -p 443:443 \\ --restart=unless-stopped \\ -v /opt/rancher:/var/lib/rancher \\ rancher/rancher:latest 选择","categories":[],"tags":[{"name":"kubernates","slug":"kubernates","permalink":"http://yoursite.com/tags/kubernates/"}],"keywords":[]},{"title":"gitlab-deploy.md","slug":"gitlab-deploy-md","date":"2020-01-03T14:49:16.000Z","updated":"2020-01-10T15:15:02.607Z","comments":true,"path":"2020/01/03/gitlab-deploy-md/","link":"","permalink":"http://yoursite.com/2020/01/03/gitlab-deploy-md/","excerpt":"","text":"gitlab 部署123456789sudo docker run --detach \\ --hostname 47.110.136.181 \\ --publish 443:443 --publish 80:80 --publish 23:22 \\ --name gitlab \\ --restart always \\ --volume &#x2F;srv&#x2F;gitlab&#x2F;config:&#x2F;etc&#x2F;gitlab \\ --volume &#x2F;srv&#x2F;gitlab&#x2F;logs:&#x2F;var&#x2F;log&#x2F;gitlab \\ --volume &#x2F;srv&#x2F;gitlab&#x2F;data:&#x2F;var&#x2F;opt&#x2F;gitlab \\ gitlab&#x2F;gitlab-ce:latest 部署太慢可以先拉去镜像dockerhub.azk8s.cn/library/gitlab/gitlab-ce","categories":[],"tags":[{"name":"kubernates","slug":"kubernates","permalink":"http://yoursite.com/tags/kubernates/"}],"keywords":[]},{"title":"debug-k8s","slug":"debug-k8s","date":"2020-01-03T14:40:01.000Z","updated":"2020-01-10T15:15:02.607Z","comments":true,"path":"2020/01/03/debug-k8s/","link":"","permalink":"http://yoursite.com/2020/01/03/debug-k8s/","excerpt":"","text":"查看pod 状态12kubectl -n kube-ops describe pod runner-svzx4ujw-project-1-concurrent-0qd6hq 删除podkubectl -n kube-ops delete pods runner-svzx4ujw-project-1-concurrent-0qd6hq –grace-period=0 –force 查看pod 中的containerkubectl get pods –all-namespaces -o=jsonpath=’{range .items[]}{“\\n”}{.metadata.name}{“:\\t”}{range .spec.containers[]}{.image}{“, “}{end}{end}’ |sort 查看pod 中container 的日志kubectl logs -c","categories":[],"tags":[{"name":"kubernates","slug":"kubernates","permalink":"http://yoursite.com/tags/kubernates/"}],"keywords":[]},{"title":"hello-world","slug":"hello-world","date":"2020-01-03T03:19:08.000Z","updated":"2020-01-10T15:15:02.607Z","comments":true,"path":"2020/01/03/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/03/hello-world/","excerpt":"","text":"12345678910111213$ sudo npm install -g hexo-cli$ hexo -vhexo-cli: 0.1.9os: Darwin 14.3.0 darwin x64http_parser: 2.3node: 0.12.7v8: 3.28.71.19uv: 1.6.1zlib: 1.2.8modules: 14openssl: 1.0.1p","categories":[],"tags":[],"keywords":[]}]}