{"meta":{"title":"Title","subtitle":"","description":"","author":"just coding","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Api/location","slug":"Api/location","date":"2020-01-10T09:13:26.126Z","updated":"2020-01-10T09:30:11.774Z","comments":true,"path":"2020/01/10/Api/location/","link":"","permalink":"http://yoursite.com/2020/01/10/Api/location/","excerpt":"","text":"locationlocation表示该应用程序现在的位置，您希望其运行的位置，甚至是以前的位置。看起来像这样： 123456789&#123; key: 'ac3df4', // not with HashHistory! pathname: '/somewhere', search: '?some=search-string', hash: '#howdy', state: &#123; [userDefined]: true &#125;&#125; 路由器提供位置对象： Route component as this.props.location Route render as ({ location }) =&gt; () Route children as ({ location }) =&gt; () withRouter as this.props.location也可以在history.location上找到它，但是您不应使用它，因为它是可变的。您可以在历史记录文档中阅读有关此内容的更多信息。位置对象永远不会发生变化，因此您可以在生命周期挂钩中使用它来确定什么时候进行导航，这对于数据获取和动画处理非常有用。12345componentWillReceiveProps(nextProps) &#123; if (nextProps.location !== this.props.location) &#123; // navigated! &#125;&#125; 您可以提供locations替换各个地方的导航： Web Link to Native Link to Redirect to history.push history.replace通常，您只使用字符串，但是如果您需要添加一些“location state”，只要应用返回到该特定位置，该状态就会可用，则可以使用位置对象代替。如果您要基于导航历史而不是仅基于路径（如模式）来分支UI，这将非常有用。 12345678910111213// usually all you need&lt;Link to=\"/somewhere\"/&gt;// but you can use a location insteadconst location = &#123; pathname: '/somewhere', state: &#123; fromDashboard: true &#125;&#125;&lt;Link to=&#123;location&#125;/&gt;&lt;Redirect to=&#123;location&#125;/&gt;history.push(location)history.replace(location) 最后，您可以将位置传递给以下组件： Route Switch 这样可以防止他们在路由器状态下使用实际位置。这对于动画和待处理的导航很有用，或者在您想要诱使组件在与真实位置不同的位置进行渲染时，这很有用。","categories":[],"tags":[],"keywords":[]},{"title":"Api/history","slug":"Api/history","date":"2020-01-10T08:37:10.940Z","updated":"2020-01-10T09:12:25.321Z","comments":true,"path":"2020/01/10/Api/history/","link":"","permalink":"http://yoursite.com/2020/01/10/Api/history/","excerpt":"","text":"history本文档中的术语“历史记录”和“历史记录对象”是指历史记录包，它是React Router仅有的两个主要依赖项之一（除了React本身），并提供了多种不同的实现来管理JavaScript中的会话历史记录。环境。使用的语法： “browser history”————Dom特殊的实现，在支持HTML5历史记录API的Web浏览器中很有用。 “hash history“————遗留Web浏览器的DOM特定实现。 “memory history”————内存历史记录实现，可用于测试和非DOM环境（例如React Native） 历史记录对象通常具有以下属性和方法： length ——(number) 历史记录堆栈中的条目数。 action ——(string)当前 action (PUSH, REPLACE, or POP) location ——(object) 当前位置，具有以下属性：pathname——（string）URL的路径 search——（string)URL查询字符串 hash———（string)URL哈希片段 state——（object)提供给例如当此位置被压入堆栈时，push（path，state）。仅在浏览器和内存历史记录中可用。 push(path, [state])——（function）将新条目推入历史记录堆栈 replace(path, [state]) ——(function)替换历史记录堆栈上的当前条目 go(n)——(function)将历史记录返回n个。 goBack()——(function)相当于go(-1) goForward()——(function)相当于go(1) block(prompt)——(function) 防止导航（请参阅历史记录文档）history is mutable历史对象是可变的。因此建议访问位置使用props&lt;Route&gt;的渲染，而不是history.location访问位置。这可以确保您对React的假设在生命周期挂钩中是正确的。例如： 12345678910111213class Comp extends React.Component &#123; componentDidUpdate(prevProps) &#123; // will be true const locationChanged = this.props.location !== prevProps.location; // INCORRECT, will *always* be false because history is mutable. const locationChanged = this.props.history.location !== prevProps.history.location; &#125;&#125;&lt;Route component=&#123;Comp&#125; /&gt;; 根据您所使用的实现方式，可能还会显示其他属性。请参阅历史记录文档以获取更多详细信息。","categories":[],"tags":[],"keywords":[]},{"title":"Api/Switch","slug":"Api/Switch","date":"2020-01-10T08:10:15.787Z","updated":"2020-01-10T08:36:09.619Z","comments":true,"path":"2020/01/10/Api/Switch/","link":"","permalink":"http://yoursite.com/2020/01/10/Api/Switch/","excerpt":"","text":"Switch渲染与位置匹配的第一个子元素&lt;Route&gt;或&lt;Redirect&gt;。 这与仅使用&lt;Route&gt;有什么不同？&lt;Switch&gt;的独特之处在于它专门呈现一条路由。相反，每个与该位置匹配的&lt;Route&gt;都将进行包含性渲染。考虑这些路线。 123456789101112131415import &#123; Route &#125; from \"react-router\";let routes = ( &lt;div&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/:user\"&gt; &lt;User /&gt; &lt;/Route&gt; &lt;Route&gt; &lt;NoMatch /&gt; &lt;/Route&gt; &lt;/div&gt;); 如果URL是/ about，则&lt;About&gt;，&lt;User&gt;和&lt;NoMatch&gt;将全部呈现，因为它们都与路径匹配。这是设计使然，允许我们以多种方式将 &lt;Route&gt;组合到我们的应用中，例如边栏和面包屑，引导程序标签等。 但是，有时我们只选择一个&lt;Route&gt;进行渲染。如果我们位于/ about，我们不想同时匹配/：user（或显示“ 404”页面）。使用Switch的方法如下： 123456789101112131415161718import &#123; Route, Switch &#125; from \"react-router\";let routes = ( &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/:user\"&gt; &lt;User /&gt; &lt;/Route&gt; &lt;Route&gt; &lt;NoMatch /&gt; &lt;/Route&gt; &lt;/Switch&gt;); 现在，如果我们位于/ about，&lt;Switch&gt;将开始寻找匹配的&lt;Route&gt;。&lt;Route path =“ / about” /&gt;将匹配，而&lt;Switch&gt;将停止寻找匹配并呈现&lt;About&gt;。同样，如果我们在/ michael位置，则会显示&lt;User&gt;。 这对于动画过渡也很有用，因为匹配的&lt;Route&gt;呈现在与上一个相同的位置。 1234567891011121314151617let routes = ( &lt;Fade&gt; &lt;Switch&gt; &#123;/* 这里只有一个child */&#125; &lt;Route /&gt; &lt;Route /&gt; &lt;/Switch&gt; &lt;/Fade&gt;);let routes = ( &lt;Fade&gt; &#123;/* 这里有两个，一个可能会变为null，但会进行过渡解决起来比较麻烦*/&#125; &lt;Route /&gt; &lt;Route /&gt; &lt;/Fade&gt;); location: object用于匹配子元素的位置对象，而不是当前历史记录位置（通常是当前浏览器URL）。 children: node&lt;Switch&gt;的所有子代应为&lt;Route&gt;或&lt;Redirect&gt;元素。仅第一个与当前位置匹配的child会被渲染。&lt;Route&gt;元素使用其路径属性进行匹配，而&lt;Redirect&gt;元素使用其from属性进行匹配。没有路径属性的&lt;Route&gt;或没有from属性的&lt;Redirect&gt;将始终与当前位置匹配。在&lt;Switch&gt;中包含&lt;Redirect&gt;时，它可以使用&lt;Route&gt;的任何位置匹配道具：path, exact, and strict。from只是路径属性的别名。如果为&lt;Switch&gt;提供了位置提示，它将覆盖匹配的子元素上的位置提示。 123456789101112131415161718import &#123; Redirect, Route, Switch &#125; from \"react-router\";let routes = ( &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/users\"&gt; &lt;Users /&gt; &lt;/Route&gt; &lt;Redirect from=\"/accounts\" to=\"/users\" /&gt; &lt;Route&gt; &lt;NoMatch /&gt; &lt;/Route&gt; &lt;/Switch&gt;);","categories":[],"tags":[],"keywords":[]},{"title":"Api/Router","slug":"Api/Router","date":"2020-01-10T08:05:24.784Z","updated":"2020-01-11T08:51:22.528Z","comments":true,"path":"2020/01/10/Api/Router/","link":"","permalink":"http://yoursite.com/2020/01/10/Api/Router/","excerpt":"","text":"Router所有路由器组件的通用底层接口。通常，应用将使用高级路由器之一代替： &lt;BrowserRouter&gt; &lt;HashRouter&gt; &lt;MemoryRouter&gt; &lt;NativeRouter&gt; &lt;StaticRouter&gt; 使用底层&lt;Router&gt;的最常见用例是将自定义历史记录与状态管理库（如Redux或Mobx）进行同步。请注意，并不需要将状态管理库与React Router一起使用，它仅用于深度集成。 12345678910111213import React from \"react\";import ReactDOM from \"react-dom\";import &#123; Router &#125; from \"react-router\";import &#123; createBrowserHistory &#125; from \"source/_posts/Api/history\";const history = createBrowserHistory();ReactDOM.render( &lt;Router history=&#123;history&#125;&gt; &lt;App /&gt; &lt;/Router&gt;, node); history: object用于导航的历史对象。 1234567import React from \"react\";import ReactDOM from \"react-dom\";import &#123; createBrowserHistory &#125; from \"history\";const customHistory = createBrowserHistory();ReactDOM.render(&lt;Router history=&#123;customHistory&#125; /&gt;, node); children: node要渲染的子元素。 123 &lt;Router&gt; &lt;App /&gt;&lt;/Router&gt;","categories":[],"tags":[],"keywords":[]},{"title":"Api/Route","slug":"Api/Route","date":"2020-01-10T07:11:34.794Z","updated":"2020-01-10T08:04:14.469Z","comments":true,"path":"2020/01/10/Api/Route/","link":"","permalink":"http://yoursite.com/2020/01/10/Api/Route/","excerpt":"","text":"Route render methods建议使用&lt;Route&gt;渲染某些内容的方法是使用子元素，如上所示。但是，还有一些其他方法可用于使用&lt;Route&gt;渲染内容。提供这些主要是为了支持在引入hook之前使用早期版本的路由器构建的应用程序。 &lt;Route component&gt; &lt;Route render&gt; &lt;Route children&gt; function您应该在给定的上仅使用这些道具之一。请参阅下面的说明以了解它们之间的区别。 Route props所有这三种渲染方法将通过相同的三个路由道具。 match location history component一个仅在位置匹配时才呈现的React组件。它将与路线道具一起渲染。 123456789101112131415import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Route &#125; from \"react-router-dom\";// All route props (match, location and history) are available to Userfunction User(props) &#123; return &lt;h1&gt;Hello &#123;props.match.params.username&#125;!&lt;/h1&gt;;&#125;ReactDOM.render( &lt;Router&gt; &lt;Route path=\"/user/:username\" component=&#123;User&#125; /&gt; &lt;/Router&gt;, node); 当您使用组件（而不是下面的渲染器或子组件）时，路由器会使用React.createElement从给定的组件中创建一个新的React元素。这意味着，如果您向组件prop提供内联函数，则将在每个渲染中创建一个新组件。这将导致现有组件的卸载和新组件的安装，而不仅仅是更新现有组件。使用内联函数进行内联渲染时，请使用render或children道具（如下）。 render: func这样可以方便地进行内联渲染和包装，而无需进行上述不必要的重新安装。无需使用组件prop为您创建新的React元素，而是可以传递位置匹配时要调用的函数。渲染道具功能可以访问与组件渲染道具相同的所有路线道具（匹配，位置和历史）。 123456789101112131415161718192021222324252627282930313233import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Route &#125; from \"react-router-dom\";// convenient inline renderingReactDOM.render( &lt;Router&gt; &lt;Route path=\"/home\" render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125; /&gt; &lt;/Router&gt;, node);// wrapping/composing// You can spread routeProps to make them available to your rendered Componentfunction FadingRoute(&#123; component: Component, ...rest &#125;) &#123; return ( &lt;Route &#123;...rest&#125; render=&#123;routeProps =&gt; ( &lt;FadeIn&gt; &lt;Component &#123;...routeProps&#125; /&gt; &lt;/FadeIn&gt; )&#125; /&gt; );&#125;ReactDOM.render( &lt;Router&gt; &lt;FadingRoute path=\"/cool\" component=&#123;Something&#125; /&gt; &lt;/Router&gt;, node); 警告：&lt;Route组件&gt;优先于&lt;Route渲染&gt;，因此请勿在同一&lt;Route&gt;中同时使用两者。 children: func有时您需要渲染路径是否与位置匹配。在这种情况下，您可以使用child道具功能。它与render完全一样，除了是否存在匹配项而被调用。 子级渲染道具将接收与组件和渲染方法相同的所有路由道具，除非当路线未能与URL匹配时，则match为null。这使您可以根据路由是否匹配来动态调整UI。如果路线匹配，我们在此处添加一个活动班级。 123456789101112131415161718192021222324252627282930import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Link, Route&#125; from \"react-router-dom\";function ListItemLink(&#123; to, ...rest &#125;) &#123; return ( &lt;Route path=&#123;to&#125; children=&#123;(&#123; match &#125;) =&gt; ( &lt;li className=&#123;match ? \"active\" : \"\"&#125;&gt; &lt;Link to=&#123;to&#125; &#123;...rest&#125; /&gt; &lt;/li&gt; )&#125; /&gt; );&#125;ReactDOM.render( &lt;Router&gt; &lt;ul&gt; &lt;ListItemLink to=\"/somewhere\" /&gt; &lt;ListItemLink to=\"/somewhere-else\" /&gt; &lt;/ul&gt; &lt;/Router&gt;, node); 这对于动画也可能有用： 123456789&lt;Route children=&#123;(&#123; match, ...rest &#125;) =&gt; ( &#123;/* Animate will always render, so you can use lifecycles to animate its child in and out */&#125; &lt;Animate&gt; &#123;match &amp;&amp; &lt;Something &#123;...rest&#125;/&gt;&#125; &lt;/Animate&gt; )&#125;/&gt; 警告：&lt;Route children&gt;优先于&lt;Route component&gt;和&lt;Route render&gt;，因此请不要在同一&lt;Route&gt;中使用多个 path: string | string[]path-to-regexp@^1.7.0可以理解的任何有效URL路径或路径数组。 123&lt;Route path=\"/users/:id\"&gt; &lt;User /&gt;&lt;/Route&gt; 123&lt;Route path=&#123;[\"/users/:id\", \"/profile/:id\"]&#125;&gt; &lt;User /&gt;&lt;/Route&gt; 没有路径的路线总是匹配的。 exact: boolexact:true时，只有在路径与location.pathname完全匹配时才匹配 path location.pathname exact matches ? /one /one/two true no /one /one/two false yes strict: bool设置为true时，带有斜杠的路径将只匹配带有斜杠的location.pathname。当location.pathname中有其他URL段时，这无效。 123 &lt;Route strict path=\"/one/\"&gt; &lt;About /&gt;&lt;/Route&gt;| path | location.pathname | matches? || :———— | :———— | :———— ||/one/ |/one/ | no || /one/ | /one/ | yes || /one/ | /one/two | yes | 警告：strict可以用于强制location.pathname不带斜杠，但是要做到这一点，strict和精确都必须为真。 123&lt;Route exact strict path=\"/one\"&gt; &lt;About /&gt;&lt;/Route&gt; path location.pathname matches? /one/ /one/ yes /one/ /one/ no /one/ /one/two no location: object&lt;Route&gt;元素尝试将其路径与当前历史记录位置（通常是当前浏览器URL）匹配。但是，也可以传递路径名不同的位置进行匹配。 如需要将&lt;Route&gt;匹配到当前历史记录位置以外的位置时，这很有用，如Animated Transitions示例所示。 如果&lt;Route&gt;元素包装在&lt;Switch&gt;中并且与传递给&lt;Switch&gt;的位置（或当前历史记录位置）相匹配，则传递给&lt;Route&gt;的位置prop将被（在此处给出）。 sensitive: bool为true时，如果路径区分大小写，则将匹配。 123&lt;Route sensitive path=\"/one\"&gt; &lt;About /&gt;&lt;/Route&gt; path location.pathname sensitive matches? /one /one/two true no /one /one/two false yes","categories":[],"tags":[],"keywords":[]},{"title":"examples/custom_link","slug":"examples/custom_link","date":"2020-01-10T06:58:03.375Z","updated":"2020-01-10T07:00:38.312Z","comments":true,"path":"2020/01/10/examples/custom_link/","link":"","permalink":"http://yoursite.com/2020/01/10/examples/custom_link/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useRouteMatch&#125; from \"react-router-dom\";// 这个实力显示的是如何自定义// &lt;Link&gt; 会在url中呈现特殊内容// 与&lt;Link&gt;指向的对象相同export default function CustomLinkExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;OldSchoolMenuLink activeOnlyWhenExact=&#123;true&#125; to=\"/\" label=\"Home\" /&gt; // &lt;OldSchoolMenuLink to=\"/about\" label=\"About\" /&gt; &lt;hr /&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function OldSchoolMenuLink(&#123; label, to, activeOnlyWhenExact &#125;) &#123; let match = useRouteMatch(&#123; path: to, exact: activeOnlyWhenExact &#125;); return ( &lt;div className=&#123;match ? \"active\" : \"\"&#125;&gt; &#123;match &amp;&amp; \"&gt; \"&#125; &lt;Link to=&#123;to&#125;&gt;&#123;label&#125;&lt;/Link&gt; &lt;/div&gt; );&#125;function Home() &#123; return ( &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/div&gt; );&#125;function About() &#123; return ( &lt;div&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"examples/redirect","slug":"examples/redirect","date":"2020-01-09T16:09:15.461Z","updated":"2020-01-09T16:10:59.700Z","comments":true,"path":"2020/01/10/examples/redirect/","link":"","permalink":"http://yoursite.com/2020/01/10/examples/redirect/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, Redirect, useHistory, useLocation&#125; from \"react-router-dom\";// 这个例子有3个页面: 一个公共的, 一个受保护的// 页面, 和一个登陆屏幕. 为了看到受保护的页面, 你必须第一次使用. 相当标准的东西.// 首先, 访问 公共页面. 然后, 访问protected页面 .你没有登陆的话, 所以你被重定向到login页面.登录后, 你被重定向返回到受保护的页面.// 注意URL每次都会变.在此刻如果你点击返回按钮, 你是否希望回到登录页面? 不! 你已经登陆了. 试试看,// 您会看到您返回到您的访问页面仅在登陆之前的页面。export default function AuthExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;AuthButton /&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/public\"&gt;Public Page&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/protected\"&gt;Protected Page&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=\"/public\"&gt; &lt;PublicPage /&gt; &lt;/Route&gt; &lt;Route path=\"/login\"&gt; &lt;LoginPage /&gt; &lt;/Route&gt; &lt;PrivateRoute path=\"/protected\"&gt; &lt;ProtectedPage /&gt; &lt;/PrivateRoute&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;const fakeAuth = &#123; isAuthenticated: false, authenticate(cb) &#123; fakeAuth.isAuthenticated = true; setTimeout(cb, 100); // fake async &#125;, signout(cb) &#123; fakeAuth.isAuthenticated = false; setTimeout(cb, 100); &#125;&#125;;function AuthButton() &#123; let history = useHistory(); return fakeAuth.isAuthenticated ? ( &lt;p&gt; Welcome!&#123;\" \"&#125; &lt;button onClick=&#123;() =&gt; &#123; fakeAuth.signout(() =&gt; history.push(\"/\")); &#125;&#125; &gt; Sign out &lt;/button&gt; &lt;/p&gt; ) : ( &lt;p&gt;You are not logged in.&lt;/p&gt; );&#125;//&lt;Route&gt;的包装器，重定向到登录屏幕，如果您尚未通过身份验证。function PrivateRoute(&#123; children, ...rest &#125;) &#123; return ( &lt;Route &#123;...rest&#125; render=&#123;(&#123; location &#125;) =&gt; fakeAuth.isAuthenticated ? ( children ) : ( &lt;Redirect to=&#123;&#123; pathname: \"/login\", state: &#123; from: location &#125; &#125;&#125; /&gt; ) &#125; /&gt; );&#125;function PublicPage() &#123; return &lt;h3&gt;Public&lt;/h3&gt;;&#125;function ProtectedPage() &#123; return &lt;h3&gt;Protected&lt;/h3&gt;;&#125;function LoginPage() &#123; let history = useHistory(); let location = useLocation(); //useLocation挂钩返回代表当前URL的位置对象。 let &#123; from &#125; = location.state || &#123; from: &#123; pathname: \"/\" &#125; &#125;; let login = () =&gt; &#123; fakeAuth.authenticate(() =&gt; &#123; history.replace(from); &#125;); &#125;; return ( &lt;div&gt; &lt;p&gt;You must log in to view the page at &#123;from.pathname&#125;&lt;/p&gt; &lt;button onClick=&#123;login&#125;&gt;Log in&lt;/button&gt; &lt;/div&gt; );&#125; 这可能非常有用，例如在您希望每次加载新页面时都使用Web分析工具触发新的“页面浏览”事件的情况下，如以下示例所示：","categories":[],"tags":[],"keywords":[]},{"title":"examples/嵌套","slug":"examples/嵌套","date":"2020-01-09T14:54:50.396Z","updated":"2020-01-09T15:12:17.179Z","comments":true,"path":"2020/01/09/examples/嵌套/","link":"","permalink":"http://yoursite.com/2020/01/09/examples/%E5%B5%8C%E5%A5%97/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useParams, useRouteMatch&#125; from \"react-router-dom\";// 路线是常规的React组件, 他们可以在程序中的任何位置呈现。包含element的子元素。// 当需要对代码分割时，会有所帮助。代码分割分成多个bundle,React router与代码拆分任何其他 React app 是相同.export default function NestingExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/topics\"&gt;Topics&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/topics\"&gt; &lt;Topics /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Home() &#123; return ( &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/div&gt; );&#125;function Topics() &#123; // The `path` 让我构建 &lt;Route&gt; 路径，那是相对于父Route,而url允许让我们建立相对links let &#123; path, url &#125; = useRouteMatch(); return ( &lt;div&gt; &lt;h2&gt;Topics&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;url&#125;/rendering`&#125;&gt;Rendering with React&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;url&#125;/components`&#125;&gt;Components&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;url&#125;/props-v-state`&#125;&gt;Props v. State&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route exact path=&#123;path&#125;&gt; &lt;h3&gt;Please select a topic.&lt;/h3&gt; &lt;/Route&gt; &lt;Route path=&#123;`$&#123;path&#125;/:topicId`&#125;&gt; &lt;Topic /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125;function Topic() &#123; /* The &lt;Route&gt; 呈现此组件&lt;Route&gt;具有 `/topics/:topicId`. The `:topicId` 部分的网址表示一个占位符，我们可以从 `useParams()`获取.*/ let &#123; topicId &#125; = useParams(); return ( &lt;div&gt; &lt;h3&gt;&#123;topicId&#125;&lt;/h3&gt; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"examples/url_parameters","slug":"examples/url_parameters","date":"2020-01-09T14:18:16.942Z","updated":"2020-01-09T15:47:04.680Z","comments":true,"path":"2020/01/09/examples/url_parameters/","link":"","permalink":"http://yoursite.com/2020/01/09/examples/url_parameters/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useParams&#125; from \"react-router-dom\";&#123;/*参数是URL开头的占位符 冒号，例如`：id`在这个实例中的路线。 相似的用于匹配其他动态细分流行的Web框架，例如 Rails and Express*/&#125; export default function ParamsExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;h2&gt;Accounts&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/netflix\"&gt;Netflix&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/zillow-group/3331\"&gt;Zillow Group&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/yahoo\"&gt;Yahoo&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/modus-create\"&gt;Modus Create&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=\"/:id\" children=&#123;&lt;Child /&gt;&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Child() &#123; // 我们可以在这里使用`useParams`钩子来访问 // the URL的动态片段 let &#123; id &#125; = useParams(); return ( &lt;div&gt; &lt;h3&gt;ID: &#123;id&#125;&lt;/h3&gt; &lt;/div&gt; );&#125; 123456789101112import &#123; Route &#125; from \"react-router-dom\";function BlogPost() &#123; return ( &lt;Route path=\"/blog/:slug\" render=&#123;(&#123; match &#125;) =&gt; &#123; return &lt;div /&gt;; &#125;&#125; /&gt; );&#125; 你可以 1234567import &#123; useRouteMatch &#125; from \"react-router-dom\";function BlogPost() &#123; let match = useRouteMatch(\"/blog/:slug\"); return &lt;div /&gt;;&#125; useParams返回URL参数的键/值对的对象。使用它来访问当前&lt;Route&gt;的match.params。","categories":[],"tags":[],"keywords":[]},{"title":"examples/Basic","slug":"examples/Basic","date":"2020-01-09T14:02:48.489Z","updated":"2020-01-09T14:36:09.022Z","comments":true,"path":"2020/01/09/examples/Basic/","link":"","permalink":"http://yoursite.com/2020/01/09/examples/Basic/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link&#125; from \"react-router-dom\";&#123;/*本网站共有3页，所有页面均已呈现 在浏览器中动态显示（不呈现服务器）。尽管页面永远不会刷新，但请注意 当您浏览时，React Router使URL保持最新 通过网站. 保留 the browser history, making sure 后退按钮和书签之类的东西*/&#125; export default function BasicExample() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &#123;/* &lt;Switch&gt;遍历其所有子节点&lt;Route&gt; elements and renders 第一个路径 matches the current URL. 随时使用 a &lt;Switch&gt; 你有很多的routes, but you want 一个一次渲染 */&#125; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/dashboard\"&gt; &lt;Dashboard /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;// 你可以将这些组件视为页面// in your app.function Home() &#123; return ( &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/div&gt; );&#125;function About() &#123; return ( &lt;div&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;/div&gt; );&#125;function Dashboard() &#123; return ( &lt;div&gt; &lt;h2&gt;Dashboard&lt;/h2&gt; &lt;/div&gt; );&#125;","categories":[],"tags":[],"keywords":[]},{"title":"指南/Static_Routes","slug":"指南/Static_Routes","date":"2020-01-09T08:43:22.856Z","updated":"2020-01-09T08:44:37.778Z","comments":true,"path":"2020/01/09/指南/Static_Routes/","link":"","permalink":"http://yoursite.com/2020/01/09/%E6%8C%87%E5%8D%97/Static_Routes/","excerpt":"","text":"Static Routes以前版本的React Router使用静态路由来配置应用程序的路由。这样可以在渲染之前检查和匹配路线。由于v4转移到动态组件而不是路由配置，因此一些以前的用例变得不那么明显和棘手。 我们正在开发一个可与静态路由配置和React Router配合使用的软件包，以继续满足这些用例。现在正在开发中，但我们希望您能尝试一下并提供帮助。","categories":[],"tags":[],"keywords":[]},{"title":"指南/Redux整合","slug":"指南/Redux整合","date":"2020-01-09T08:35:56.819Z","updated":"2020-01-09T08:43:04.840Z","comments":true,"path":"2020/01/09/指南/Redux整合/","link":"","permalink":"http://yoursite.com/2020/01/09/%E6%8C%87%E5%8D%97/Redux%E6%95%B4%E5%90%88/","excerpt":"","text":"Redux整合Redux是React生态系统的重要组成部分。对于想要同时使用React Router和Redux的人，我们希望使其无缝集成。 阻止的更新通常，React Router和Redux可以很好地协同工作。不过，有时候，应用程序的组件可能会在位置更改时（子路线或活动的导航链接不更新）不更新。 在以下情况下会发生这种情况： 1.该组件通过connect（）（Comp）连接到redux。 2.该组件不是“路由组件”，这意味着它的呈现方式不是这样：&lt;Route component = {SomeConnectedThing} /&gt; 问题在于Redux实现了shouldComponentUpdate，如果没有从路由器接收道具，则没有任何迹象表明发生了任何变化。这很容易解决。查找连接组件的位置，然后将其与Router包装在一起。 123456// beforeexport default connect(mapStateToProps)(Something)// afterimport &#123; withRouter &#125; from 'react-router-dom'export default withRouter(connect(mapStateToProps)(Something)) 深度整合有些人想： 1.与商店同步并从商店访问路由数据。 2.能够通过调度动作进行导航。 3.在Redux devtools中支持对路径更改进行时间旅行调试。 所有这些都需要更深入的集成。 我们的建议是不要将路线完全保留在Redux商店中。推理: 1.路由数据已经成为大多数关心它的组件的支持。无论是来自商店还是路由器，您组件的代码都基本相同。 2.在大多数情况下，您可以使用链接，导航链接和重定向来执行导航操作。有时，在某些最初由操作启动的异步任务之后，您可能还需要以编程方式导航。例如，您可以在用户提交登录表单时调度操作。然后，您的重击，传奇或其他异步处理程序会对凭据进行身份验证，如果成功，则需要以某种方式导航到新页面。此处的解决方案只是将历史对象（提供给所有路由组件）包括在操作的有效负载中，并且异步处理程序可以在适当的时候使用此对象进行导航。 3.路线更改对于时间旅行调试不太重要。唯一明显的情况是调试路由器/商店同步中的问题，如果根本不同步它们，则该问题将消失。 但是，如果您强烈希望与商店同步路由，则可以尝试使用Connected React Router，这是React Router v4和Redux的第三方绑定。","categories":[],"tags":[],"keywords":[]},{"title":"指南/Testing","slug":"指南/Testing","date":"2020-01-09T08:20:30.143Z","updated":"2020-01-09T08:35:00.942Z","comments":true,"path":"2020/01/09/指南/Testing/","link":"","permalink":"http://yoursite.com/2020/01/09/%E6%8C%87%E5%8D%97/Testing/","excerpt":"","text":"TestingReact Router依靠React上下文来工作。这会影响您如何测试使用我们的组件的组件。 Context如果您尝试对呈现&lt;Link&gt;或&lt;Route&gt;等的组件之一进行单元测试，则会收到一些有关上下文的错误和警告。虽然您可能会想自己尝试添加路由器上下文，但是我们建议您将单元测试包装在以下路由器组件之一中：具有历史记录属性的基本路由器，或&lt;StaticRouter&gt;，&lt;MemoryRouter&gt;或&lt;BrowserRouter&gt;（如果window.history在测试环境中可用作全局变量）。 建议使用MemoryRouter或自定义历史记录，以便能够在两次测试之间重置路由器。 1234567891011121314151617181920212223242526272829303132333435class Sidebar extends Component &#123; // ... render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.toggleExpand&#125;&gt;expand&lt;/button&gt; &lt;ul&gt; &#123;users.map(user =&gt; ( &lt;li&gt; &lt;Link to=&#123;user.path&#125;&gt;&#123;user.name&#125;&lt;/Link&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;// brokentest(\"it expands when the button is clicked\", () =&gt; &#123; render(&lt;Sidebar /&gt;); click(theButton); expect(theThingToBeOpen);&#125;);// fixedtest(\"it expands when the button is clicked\", () =&gt; &#123; render( &lt;MemoryRouter&gt; &lt;Sidebar /&gt; &lt;/MemoryRouter&gt; ); click(theButton); expect(theThingToBeOpen);&#125;); 从特定路线开始&lt;MemoryRouter&gt;支持initialEntries和initialIndex道具，因此您可以在特定位置启动应用程序（或应用程序的任何较小部分）。 12345678test(\"current user is active in sidebar\", () =&gt; &#123; render( &lt;MemoryRouter initialEntries=&#123;[\"/users/2\"]&#125;&gt; &lt;Sidebar /&gt; &lt;/MemoryRouter&gt; ); expectUserToBeActive(2);&#125;); Navigating我们进行了很多测试，以检查路线在位置更改时是否有效，因此您可能不需要测试这些东西。但是，如果您需要在应用程序中测试导航，则可以这样进行： 123456789101112131415161718192021222324252627282930// app.js (a component file)import React from \"react\";import &#123; Route, Link &#125; from \"react-router-dom\";// our 项目, the App, but you can test any 子项// 部分 of your app tooconst App = () =&gt; ( &lt;div&gt; &lt;Route exact path=\"/\" render=&#123;() =&gt; ( &lt;div&gt; &lt;h1&gt;Welcome&lt;/h1&gt; &lt;/div&gt; )&#125; /&gt; &lt;Route path=\"/dashboard\" render=&#123;() =&gt; ( &lt;div&gt; &lt;h1&gt;Dashboard&lt;/h1&gt; &lt;Link to=\"/\" id=\"click-me\"&gt; Home &lt;/Link&gt; &lt;/div&gt; )&#125; /&gt; &lt;/div&gt;); 12345678910111213141516171819202122232425262728293031// 您也可以使用 a renderer like \"@testing-library/react\" or \"enzyme/mount\" hereimport &#123; render, unmountComponentAtNode &#125; from \"react-dom\";import &#123; act &#125; from 'react-dom/test-utils';import &#123; MemoryRouter &#125; from \"react-router-dom\";// app.test.jsit(\"navigates home when you click the logo\", async =&gt; &#123; // in a real test a renderer like \"@testing-library/react\" // would 负责设置 the DOM elements const root = document.createElement('div'); document.body.appendChild(root); // Render app render( &lt;MemoryRouter initialEntries=&#123;['/my/initial/route']&#125;&gt; &lt;App /&gt; &lt;MemoryRouter&gt;, root ); // 页面互动 act(() =&gt; &#123; // 查找链接（可能使用文本内容） const goHomeLink = document.querySelector('#nav-logo-home'); // Click it goHomeLink.dispatchEvent(new MouseEvent(\"click\", &#123; bubbles: true &#125;)); &#125;); // 检查显示的页面内容是否正确 expect(document.body.textContent).toBe('Home');&#125;); 检查测试中的位置您不必在测试中经常访问位置或历史记录对象，但如果这样做（例如，验证是否在url栏中设置了新的查询参数），则可以添加一条路由来更新测试中的变量： 12345678910111213141516171819202122232425262728// app.test.jstest(\"clicking filter links updates product query params\", () =&gt; &#123; let history, location; render( &lt;MemoryRouter initialEntries=&#123;[\"/my/initial/route\"]&#125;&gt; &lt;App /&gt; &lt;Route path=\"*\" render=&#123;(&#123; history, location &#125;) =&gt; &#123; history = history; location = location; return null; &#125;&#125; /&gt; &lt;/MemoryRouter&gt;, node ); act(() =&gt; &#123; // example: click a &lt;Link&gt; to /products?id=1234 &#125;); // assert about url expect(location.pathname).toBe(\"/products\"); const searchParams = new URLSearchParams(location.search); expect(searchParams.has(\"id\")).toBe(true); expect(searchParams.get(\"id\")).toEqual(\"1234\");&#125;); 备选方案 如果您的测试环境具有浏览器全局变量window.location和window.history（这是通过JSDOM在Jest中的默认设置，但您无法重置测试之间的历史记录），则也可以使用BrowserRouter。 您可以将基本路由器与历史包中的历史道具一起使用，而不是将自定义路由传递给MemoryRouter 1234567891011121314// app.test.jsimport &#123; createMemoryHistory &#125; from \"history\";import &#123; Router &#125; from \"react-router\";test(\"redirects to login page\", () =&gt; &#123; const history = createMemoryHistory(); render( &lt;Router history=&#123;history&#125;&gt; &lt;App signedInUser=&#123;null&#125; /&gt; &lt;/Router&gt;, node ); expect(history.location.pathname).toBe(\"/login\");&#125;); React测试库","categories":[],"tags":[],"keywords":[]},{"title":"指南/Philosophy","slug":"指南/Philosophy","date":"2020-01-09T07:45:24.676Z","updated":"2020-01-09T08:10:48.855Z","comments":true,"path":"2020/01/09/指南/Philosophy/","link":"","permalink":"http://yoursite.com/2020/01/09/%E6%8C%87%E5%8D%97/Philosophy/","excerpt":"","text":"Philosophy本指南的目的是说明使用React Router时要具有的思维模型。我们称之为“动态路由”，它与您可能更熟悉的“静态路由”完全不同。 静态路由如果您使用过Rails，Express，Ember，Angular等，则使用了静态路由。在这些框架中，您需要在进行任何渲染之前将路由声明为应用初始化的一部分。React Router pre-v4也是静态的（大部分是静态的）。让我们看一下如何快速配置路由： 1234567// Express Style routing:app.get(\"/\", handleIndex);app.get(\"/invoices\", handleInvoices);app.get(\"/invoices/:id\", handleInvoice);app.get(\"/invoices/:id/edit\", handleInvoiceEdit);app.listen(); 请注意在应用监听之前如何声明路由。我们使用的客户端路由器相似。在Angular中，您先声明路线，然后在渲染之前将其导入顶级AppModule： 123456789101112131415161718192021222324252627282930// Angular Style routing:const appRoutes: Routes = [ &#123; path: \"crisis-center\", component: CrisisListComponent &#125;, &#123; path: \"hero/:id\", component: HeroDetailComponent &#125;, &#123; path: \"heroes\", component: HeroListComponent, data: &#123; title: \"Heroes List\" &#125; &#125;, &#123; path: \"\", redirectTo: \"/heroes\", pathMatch: \"full\" &#125;, &#123; path: \"**\", component: PageNotFoundComponent &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(appRoutes)]&#125;)export class AppModule &#123;&#125; Ember具有常规的route.js文件，该版本会为您读取并导入到应用程序中。同样，这是在您的应用渲染之前发生的。 12345678910// Ember Style Router:Router.map(function() &#123; this.route(\"about\"); this.route(\"contact\"); this.route(\"rentals\", function() &#123; this.route(\"show\", &#123; path: \"/:rental_id\" &#125;); &#125;);&#125;);export default Router; 尽管API不同，但它们都共享“静态路由”模型。React Router也跟进了直到v4。 为了成功使用React Router，您需要忘记所有这些！：O Backstory坦率地说，我们对v2采取React Router的方向感到非常沮丧。我们（Michael和Ryan）感到受API的限制，认识到我们正在重新实现React的各个部分（生命周期等），而这与React为构建UI提供的思维模型不符。 我们正要经过车间讨论要怎么做的研讨会前的酒店走廊。我们互相问：“如果使用我们在讲习班中教授的模式建造路由器，那会是什么样？” 仅仅几个小时的开发时间，我们就获得了概念证明，我们知道这是我们想要路由的未来。我们最终得到的API并不是React的“外部”，它是由React的其余部分组成或自然地融入其中的。我们认为您会喜欢的。 动态 Routing当说动态路由时，是指在您的应用渲染时发生的路由，而不是在运行的应用之外的配置或约定中进行。这意味着几乎所有内容都是React Router中的一个组件。这是对该API的60秒回顾，以了解其工作原理： 首先，为您要定位的环境获取一个Router组件，并将其呈现在应用程序的顶部。 123456789101112// react-nativeimport &#123; NativeRouter &#125; from \"react-router-native\";// react-dom (what we'll use here)import &#123; BrowserRouter &#125; from \"react-router-dom\";ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, el); 接下来，获取链接组件以链接到新位置： 1234567const App = () =&gt; ( &lt;div&gt; &lt;nav&gt; &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt; &lt;/nav&gt; &lt;/div&gt;); 最后，渲染一个Route以在用户访问/ dashboard时显示一些UI。 12345678910const App = () =&gt; ( &lt;div&gt; &lt;nav&gt; &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt; &lt;/nav&gt; &lt;div&gt; &lt;Route path=\"/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;/div&gt; &lt;/div&gt;); 路线将渲染&lt;Dashboard {… props} /&gt;，其中道具是路由器特定的东西，看起来像{匹配，位置，历史}。如果用户不在/ dashboard上，则Route将呈现null。差不多就够了。 嵌套路线许多路由器都具有“嵌套路由”的概念。如果您使用了v4之前的React Router版本，那么您也会知道它也是如此！当您从静态路由配置转移到动态渲染的路由时，如何“嵌套路由”？好吧，如何嵌套div？ 12345678910111213141516171819const App = () =&gt; ( &lt;BrowserRouter&gt; &#123;/* here's a div */&#125; &lt;div&gt; &#123;/* here's a Route */&#125; &lt;Route path=\"/tacos\" component=&#123;Tacos&#125; /&gt; &lt;/div&gt; &lt;/BrowserRouter&gt;);// 当网址与`/ tacos`相匹配时，此组件呈现const Tacos = (&#123; match &#125;) =&gt; ( // here's a nested div &lt;div&gt; &#123;/* here's a 嵌套 Route, match.url 帮助我们建立相对的路径 */&#125; &lt;Route path=&#123;match.url + \"/carnitas\"&#125; component=&#123;Carnitas&#125; /&gt; &lt;/div&gt;); 看看路由器如何没有“嵌套” API？就像div一样，Route只是一个组件。因此，要嵌套一个Route或一个div，您只需…做就可以了。 响应路线考虑用户导航到’ /invoices ‘。您的应用程序适应不同的屏幕尺寸，它们的视口狭窄，因此您只向他们显示发票清单和发票仪表板的链接。他们可以从那里更深入地导航。 123456789101112131415161718192021222324Small Screenurl: &#x2F;invoices+----------------------+| || Dashboard || |+----------------------+| || Invoice 01 || |+----------------------+| || Invoice 02 || |+----------------------+| || Invoice 03 || |+----------------------+| || Invoice 04 || |+----------------------+ 在较大的屏幕上，我们想显示一个主从视图，其中导航在左侧，仪表板或特定发票在右侧。 123456789101112131415161718192021222324Large Screenurl: &#x2F;invoices&#x2F;dashboard+----------------------+---------------------------+| | || Dashboard | || | Unpaid: 5 |+----------------------+ || | Balance: $53,543.00 || Invoice 01 | || | Past Due: 2 |+----------------------+ || | || Invoice 02 | || | +-------------------+ |+----------------------+ | | || | | + + + | || Invoice 03 | | | + | | | || | | | | | + | + | |+----------------------+ | | | | | | | | || | +--+-+--+--+--+--+--+ || Invoice 04 | || | |+----------------------+---------------------------+ 现在暂停一分钟，并考虑两种屏幕尺寸的 /invoices 网址。它甚至是大屏幕的有效路线吗？我们应该在右边放什么？ 1234567891011121314151617181920212223Large Screenurl: &#x2F;invoices+----------------------+---------------------------+| | || Dashboard | || | |+----------------------+ || | || Invoice 01 | || | |+----------------------+ || | || Invoice 02 | ??? || | |+----------------------+ || | || Invoice 03 | || | |+----------------------+ || | || Invoice 04 | || | |+----------------------+---------------------------+ 在大屏幕上，/invoices 不是有效的路径，但在小屏幕上则是！为了使事情变得更有趣，请考虑使用大型手机的人。他们可能会纵向查看/发票，然后将手机旋转至横向。突然，我们有足够的空间来显示主从界面，因此您应该立即进行重定向！ React Router以前版本的静态路由并没有真正解决这个问题的方法。但是，当路由是动态的时，您可以声明性地组合此功能。如果您开始考虑将路由选择为UI，而不是静态配置，那么您的直觉将引导您进入以下代码 123456789101112131415161718192021222324252627282930313233343536373839const App = () =&gt; ( &lt;AppLayout&gt; &lt;Route path=\"/invoices\" component=&#123;Invoices&#125; /&gt; &lt;/AppLayout&gt;);const Invoices = () =&gt; ( &lt;Layout&gt; &#123;/* 总是显示导航 */&#125; &lt;InvoicesNav /&gt; &lt;Media query=&#123;PRETTY_SMALL&#125;&gt; &#123;screenIsSmall =&gt; screenIsSmall ? ( // 小屏幕没有重定向 &lt;Switch&gt; &lt;Route exact path=\"/invoices/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"/invoices/:id\" component=&#123;Invoice&#125; /&gt; &lt;/Switch&gt; ) : ( // 大屏幕 &lt;Switch&gt; &lt;Route exact path=\"/invoices/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"/invoices/:id\" component=&#123;Invoice&#125; /&gt; &lt;Redirect from=\"/invoices\" to=\"/invoices/dashboard\" /&gt; &lt;/Switch&gt; ) &#125; &lt;/Media&gt; &lt;/Layout&gt;); 当用户将手机从纵向旋转到横向时，此代码将自动将其重定向到仪表板。有效路线集会根据用户手中移动设备的动态性质而变化。 这只是一个例子。我们可以讨论许多其他内容，但我们将总结以下建议：为了使您的直觉与React Router的直觉相符，请考虑组件而不是静态路由。考虑一下如何使用React的声明式可组合性解决问题，因为几乎每个“ React Router问题”都可能是“ React问题”。","categories":[],"tags":[],"keywords":[]},{"title":"指南/Scroll_Restoration","slug":"指南/Scroll_Restoration","date":"2020-01-09T06:44:18.843Z","updated":"2020-01-09T07:45:01.256Z","comments":true,"path":"2020/01/09/指南/Scroll_Restoration/","link":"","permalink":"http://yoursite.com/2020/01/09/%E6%8C%87%E5%8D%97/Scroll_Restoration/","excerpt":"","text":"滚动还原在早期版本的React Router中，我们提供了对滚动恢复的开箱即用的支持，从那以后人们一直在要求它。希望本文档可以帮助您从滚动条和路由中获得所需的信息！ 浏览器开始以自己的history.pushState处理滚动还原，其处理方式与使用普通浏览器导航时的处理方式相同。它已经可以在Chrome浏览器中使用，而且非常棒。这是滚动恢复规范。 由于浏览器开始处理“默认情况”，并且应用具有不同的滚动需求（例如本网站！），因此我们不提供默认滚动管理功能。本指南应帮助您实现任何滚动需求。 滚动到顶部在大多数情况下，您所需要做的只是“滚动到顶部”，因为您有一个较长的内容页面，该页面在导航到该页面时始终保持向下滚动。使用组件可以轻松处理此问题，该组件将在每次导航时向上滚动窗口： 123456789101112import &#123; useEffect &#125; from \"react\";import &#123; useLocation &#125; from \"react-router-dom\";export default function ScrollToTop() &#123; const &#123; pathname &#125; = useLocation(); useEffect(() =&gt; &#123; window.scrollTo(0, 0); &#125;, [pathname]); return null;&#125; 如果您尚未运行React 16.8，则可以使用React.Component子类执行相同的操作： 123456789101112131415161718import React from \"react\";import &#123; withRouter &#125; from \"react-router-dom\";class ScrollToTop extends React.Component &#123; componentDidUpdate(prevProps) &#123; if ( this.props.location.pathname !== prevProps.location.pathname ) &#123; window.scrollTo(0, 0); &#125; &#125; render() &#123; return null; &#125;&#125;export default withRouter(ScrollToTop); 然后将其呈现在您应用的顶部，但在路由器下方 12345678function App() &#123; return ( &lt;Router&gt; &lt;ScrollToTop /&gt; &lt;App /&gt; &lt;/Router&gt; );&#125; 如果您将标签页接口连接到路由器，那么当他们切换标签页时，您可能不想滚动到顶部。相反，关于在您需要的特定位置&lt;ScrollToTopOnMount&gt;？ 12345678910111213141516171819202122import &#123; useEffect &#125; from \"react\";function ScrollToTopOnMount() &#123; useEffect(() =&gt; &#123; window.scrollTo(0, 0); &#125;, []); return null;&#125;// Render this somewhere using:// &lt;Route path=\"...\" children=&#123;&lt;LongContent /&gt;&#125; /&gt;function LongContent() &#123; return ( &lt;div&gt; &lt;ScrollToTopOnMount /&gt; &lt;h1&gt;Here is my long content page&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;/div&gt; );&#125; 再说一次，如果您还没有运行React 16.8，则可以对React.Component子类做同样的事情： 12345678910111213141516171819202122232425class ScrollToTopOnMount extends React.Component &#123; componentDidMount() &#123; window.scrollTo(0, 0); &#125; render() &#123; return null; &#125;&#125;// Render this somewhere using:// &lt;Route path=\"...\" children=&#123;&lt;LongContent /&gt;&#125; /&gt;class LongContent extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ScrollToTopOnMount /&gt; &lt;h1&gt;Here is my long content page&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 通用解决方案对于通用解决方案（以及哪些浏览器已开始在本机实现），我们谈论的是两件事： 向上滚动导航，这样就不会启动滚动到底部的 新屏幕恢复窗口的滚动位置和“后退”和“前进”单击上的溢出元素（但不单击“链接”单击！） 在某一时刻，我们希望提供一个通用的API。这就是我们要去的方向： 12345678910111213&lt;Router&gt; &lt;ScrollRestoration&gt; &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;RestoredScroll id=\"bunny\"&gt; &lt;div style=&#123;&#123; height: \"200px\", overflow: \"auto\" &#125;&#125;&gt; I will overflow &lt;/div&gt; &lt;/RestoredScroll&gt; &lt;/div&gt; &lt;/ScrollRestoration&gt;&lt;/Router&gt; 首先，ScrollRestoration将在导航时向上滚动窗口。 其次，它将使用location.key将窗口滚动位置和RestoredScroll组件的滚动位置保存到sessionStorage。 然后，在安装ScrollRestoration或RestoredScroll组件时，它们可以从sessionStorage查找其位置。 棘手的部分是为不希望管理窗口滚动的情况定义一个“退出” API。例如，如果您在页面内容内浮动了一些标签导航，则可能不想滚动到顶部（这些标签可能会滚出视线！）。 当我们得知Chrome现在可以为我们管理滚动位置，并意识到不同的应用程序将具有不同的滚动需求时，我们有点迷失了我们需要提供某些东西的信念，尤其是当人们只想滚动到顶部时（您可以直接将其直接添加到您的应用中）。 基于此，我们不再有足够的力气自己完成工作（就像您一样，我们的时间有限！）。但是，我们很乐意为有志于实施通用解决方案的任何人提供帮助。一个可靠的解决方案甚至可以存在于项目中。如果您开始使用它，请与我们联系:)","categories":[],"tags":[],"keywords":[]},{"title":"指南/Code_Splitting","slug":"指南/Code_Splitting","date":"2020-01-09T06:33:56.160Z","updated":"2020-01-09T06:43:00.133Z","comments":true,"path":"2020/01/09/指南/Code_Splitting/","link":"","permalink":"http://yoursite.com/2020/01/09/%E6%8C%87%E5%8D%97/Code_Splitting/","excerpt":"","text":"Code Splitting网络的一项重要功能是，我们无需让访问者下载整个应用程序即可使用。您可以将代码拆分视为增量下载应用程序。为了实现这中功能我们要使用 webpack, @babel/plugin-syntax-dynamic-import, and loadable-components. webpack内置了对动态导入的支持；但是，如果您使用的是Babel（例如，将JSX编译为JavaScript），则需要使用@ babel / plugin-syntax-dynamic-import插件。这是仅语法的插件，这意味着Babel不会进行任何其他转换。该插件仅允许Babel解析动态导入，因此webpack可以将它们捆绑为代码拆分。您的.babelrc应该如下所示： 1234&#123; &quot;presets&quot;: [&quot;@babel&#x2F;preset-react&quot;], &quot;plugins&quot;: [&quot;@babel&#x2F;plugin-syntax-dynamic-import&quot;]&#125; loadable-components是用于通过动态导入加载组件的库。它自动处理各种边缘情况，并使代码拆分变得简单！这是有关如何使用可加载组件的示例： 123456789101112import loadable from \"@loadable/component\";import Loading from \"./Loading.js\";const LoadableComponent = loadable(() =&gt; import(\"./Dashboard.js\"), &#123; fallback: &lt;Loading /&gt;&#125;);export default class LoadableDashboard extends React.Component &#123; render() &#123; return &lt;LoadableComponent /&gt;; &#125;&#125; 这里所有都是它的！只需使用LoadableDashboard（或任何您命名的组件），当您在应用程序中使用它时，它将自动加载并呈现。回退是一个占位符组件，用于在加载实际组件时显示。 Code Splitting and Server-Side Renderloadable-components包含服务器端渲染的指南。","categories":[],"tags":[],"keywords":[]},{"title":"指南/Server_Rendering","slug":"指南/Server_Rendering","date":"2020-01-09T05:36:56.725Z","updated":"2020-01-09T06:28:54.359Z","comments":true,"path":"2020/01/09/指南/Server_Rendering/","link":"","permalink":"http://yoursite.com/2020/01/09/%E6%8C%87%E5%8D%97/Server_Rendering/","excerpt":"","text":"服务器渲染由于服务器都是无状态的，因此在服务器上的渲染有点不同。基本思想是将应用程序包装在无状态的&lt;StaticRouter&gt;中，而不是在&lt;BrowserRouter&gt;中。我们从服务器传入请求的url，以便路由可以匹配，然后我们将讨论上下文支持。 123456789101112// 客户端&lt;BrowserRouter&gt; &lt;App/&gt;&lt;/BrowserRouter&gt;// 服务器端 (not the complete story)&lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App/&gt;&lt;/StaticRouter&gt; 当您在客户端上呈现&lt;Redirect&gt;时，浏览器历史记录会更改状态，并且我们会获得新屏幕。在静态服务器环境中，我们无法更改应用程序状态。相反，我们使用上下文道具来找出渲染的结果。如果找到context.url，则表明该应用已重定向。这使我们能够从服务器发送适当的重定向。 12345678910111213const context = &#123;&#125;;const markup = ReactDOMServer.renderToString( &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt;);if (context.url) &#123; // 某处 `&lt;Redirect&gt;` 是被重定向的 redirect(301, context.url);&#125; else &#123; // 我们很好，发送响应回复&#125; 添加特定于应用程序的上下文信息路由器仅添加context.url。但是您可能希望将某些重定向重定向为301，将其他重定向重定向为302。或者，如果呈现了UI的某些特定分支，则可能要发送404响应，如果未授权，则要发送401。上下文道具是您的，因此您可以对其进行突变。这是区分301和302重定向的一种方法： 123456789101112131415161718192021222324252627282930313233343536373839404142function RedirectWithStatus(&#123; from, to, status &#125;) &#123; return ( &lt;Route render=&#123;(&#123; staticContext &#125;) =&gt; &#123; // 客户端上没有“ staticContext”，因此 // 我们需要在这里提防 if (staticContext) staticContext.status = status; return &lt;Redirect from=&#123;from&#125; to=&#123;to&#125; /&gt;; &#125;&#125; /&gt; );&#125;// 应用中的某处function App() &#123; return ( &lt;Switch&gt; &#123;/* 其他route */&#125; &lt;RedirectWithStatus status=&#123;301&#125; from=\"/users\" to=\"/profiles\" /&gt; &lt;RedirectWithStatus status=&#123;302&#125; from=\"/courses\" to=\"/dashboard\" /&gt; &lt;/Switch&gt; );&#125;// 在服务器上const context = &#123;&#125;;const markup = ReactDOMServer.renderToString( &lt;StaticRouter context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt;);if (context.url) &#123; // 可以使用 `context.status` 因 // 我们在 RedirectWithStatus 添加了属性 redirect(context.status, context.url);&#125; 404, 401, or any other status我们可以做与上述相同的事情。创建一个添加一些上下文的组件，并将其呈现在应用程序中的任何位置以获取不同的状态代码。 12345678910function Status(&#123; code, children &#125;) &#123; return ( &lt;Route render=&#123;(&#123; staticContext &#125;) =&gt; &#123; if (staticContext) staticContext.status = code; return children; &#125;&#125; /&gt; );&#125; 现在，您可以在要将代码添加到staticContext的应用程序中的任何位置呈现状态。 12345678910111213141516171819function NotFound() &#123; return ( &lt;Status code=&#123;404&#125;&gt; &lt;div&gt; &lt;h1&gt;Sorry, can’t find that.&lt;/h1&gt; &lt;/div&gt; &lt;/Status&gt; );&#125;function App() &#123; return ( &lt;Switch&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; );&#125; Putting it all together这不是一个真正的应用程序，但是它显示了将所有内容组合在一起所需的所有常规内容。 12345678910111213141516171819202122232425262728293031import http from \"http\";import React from \"react\";import ReactDOMServer from \"react-dom/server\";import &#123; StaticRouter &#125; from \"react-router-dom\";import App from \"./App.js\";http .createServer((req, res) =&gt; &#123; const context = &#123;&#125;; const html = ReactDOMServer.renderToString( &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App /&gt; &lt;/StaticRouter&gt; ); if (context.url) &#123; res.writeHead(301, &#123; Location: context.url &#125;); res.end(); &#125; else &#123; res.write(` &lt;!doctype html&gt; &lt;div id=\"app\"&gt;$&#123;html&#125;&lt;/div&gt; `); res.end(); &#125; &#125;) .listen(3000); 客户端 1234567891011import ReactDOM from \"react-dom\";import &#123; BrowserRouter &#125; from \"react-router-dom\";import App from \"./App.js\";ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById(\"app\")); 资料载入有许多种不同的方法，而且还没有明确的最佳实践，因此我们力求与任何一种方法融为一体，而不是规定或倾向于任何一种方法。我们相信路由器可以放入您的应用程序约束之内。 主要限制是您要在渲染之前加载数据。React Router导出其内部使用的matchPath静态函数以将位置匹配到路由。您可以在服务器上使用此功能来帮助确定呈现之前的数据依赖关系。 这种方法的要旨是依赖于静态路由配置，该配置既可以呈现您的路由，也可以在呈现之前进行匹配以确定数据依赖性。 12345678const routes = [ &#123; path: \"/\", component: Root, loadData: () =&gt; getSomeData() &#125; // etc.]; 然后使用此配置在应用中呈现您的路线： 1234567891011import &#123; routes &#125; from \"./routes.js\";function App() &#123; return ( &lt;Switch&gt; &#123;routes.map(route =&gt; ( &lt;Route &#123;...route&#125; /&gt; ))&#125; &lt;/Switch&gt; );&#125; 然后，在服务器上您将看到以下内容： 1234567891011121314151617import &#123; matchPath &#125; from \"react-router-dom\";// inside a requestconst promises = [];// use `some` to imitate `&lt;Switch&gt;` behavior of selecting only// the first to matchroutes.some(route =&gt; &#123; // use `matchPath` here const match = matchPath(req.path, route); if (match) promises.push(route.loadData(match)); return match;&#125;);Promise.all(promises).then(data =&gt; &#123; // do something w/ the data so the client // can access it then render the app&#125;); 最后，客户将需要提取数据。同样，我们不为您的应用程序规定数据加载模式，但这是您需要实现的接触点。 您可能对我们的React Router Config软件包感兴趣，以通过静态路由配置协助数据加载和服务器渲染。","categories":[],"tags":[],"keywords":[]},{"title":"指南/Primary_Components","slug":"指南/Primary_Components","date":"2020-01-09T04:42:03.343Z","updated":"2020-01-09T05:36:06.684Z","comments":true,"path":"2020/01/09/指南/Primary_Components/","link":"","permalink":"http://yoursite.com/2020/01/09/%E6%8C%87%E5%8D%97/Primary_Components/","excerpt":"","text":"Primary ComponentsReact Router中的组件主要分为三类： routers,例如 and route匹配，例如 and 导航 例如 , , and 使用的web应运都应从react-router-dom导入。 import { BrowserRouter, Route, Link } from &quot;react-router-dom&quot;; RoutersRouters 每个React Router应用程序的核心应该是路由器组件。对于Web项目，react-router-dom提供 &lt;BrowserRouter&gt;和&lt;HashRouter&gt;路由器。两者之间的主要区别在于它们存储URL和与Web服务器通信的方式。 &lt;BrowserRouter&gt;使用常规URL路径。这些通常是外观最好的URL，但是它们要求正确配置服务器。具体来说，您的Web服务器需要在所有由React Router客户端管理的URL上提供相同的页面。Create React App在开发中即开即用地支持此功能，并附带有关如何配置生产服务器的说明。 &lt;HashRouter&gt;将当前位置存储在URL的哈希部分中，因此URL看起来类似于http://example.com/#/your/page。由于哈希从不发送到服务器，因此这意味着不需要特殊的服务器配置。 要使用路由器，只需确保将其呈现在元素层次结构的根目录下即可。通常，您会将顶级元素包装在路由器中，如下所示： 1234567891011121314import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter &#125; from \"react-router-dom\";function App() &#123; return &lt;h1&gt;Hello React Router&lt;/h1&gt;;&#125;ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById(\"root\")); Route Matchers有两个路由匹配组件：Switch and Route。呈现&lt;Switch&gt;时，它将搜索其子&lt;Route&gt;元素以查找其路径与当前URL匹配的元素。当找到一个时，它将呈现该&lt;Route&gt;并忽略所有其他路由。这意味着您应该将&lt;Route&gt;包含更多特定路径（通常较长）的路径放在不那么特定路径之前。 如果没有匹配，则不呈现任何内容（空） 12345678910111213141516171819202122232425262728293031323334353637383940414243import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Switch, Route&#125; from \"react-router-dom\";function App() &#123; return ( &lt;div&gt; &lt;Switch&gt; &#123;/* 如果当前URL是/ about，则呈现此路由 而其余的则被忽略 */&#125; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &#123;/* 请注意这两个路由的顺序。更具体path =\" / contact /：id\"在path =\" / contact\"之前，因此查看单个联系人时，路线将呈现 */&#125; &lt;Route path=\"/contact/:id\"&gt; &lt;Contact /&gt; &lt;/Route&gt; &lt;Route path=\"/contact\"&gt; &lt;AllContacts /&gt; &lt;/Route&gt; &#123;/* 如果先前的路线都不提供任何东西， 这条路线充当后备路线。 重要提示：路径=\" /\"的路线将*始终*匹配URL，因为所有URL均以/开头。所以那是为什么我们把这一切放在最后 */&#125; &lt;Route path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;Router&gt; &lt;App /&gt; &lt;/Router&gt;, document.getElementById(\"root\")); 需要注意的重要一件事是&lt;Route path&gt;匹配URL的开头，而不是整个开头。因此，&lt;Route path =“ /”&gt;将始终与URL匹配。因此，我们通常将此&lt;Route&gt;放在&lt;Switch&gt;的最后。另一种可能的解决方案是使用确实与整个URL匹配的&lt;Route exact path=&quot;/&quot;&gt;。 注意：尽管React Router确实支持在&lt;Switch&gt;之外渲染&lt;Route&gt;元素，但是从5.1版本开始，我们建议您改用useRouteMatch钩子。此外，我们不建议您渲染不带路径的&lt;Route&gt;，而是建议您使用钩子来访问所需的任何变量。 导航（或路线更改器）React Router提供了一个&lt;Link&gt;组件来在您的应用程序中创建链接。无论在何处呈现&lt;Link&gt;，锚点（&lt;a&gt;）都将呈现在HTML文档中。 12&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;// &lt;a href=\"/\"&gt;Home&lt;/a&gt; &lt;NavLink&gt;是&lt;Link&gt;的一种特殊类型，当其prop与当前位置匹配时，可以将其自身设置为“active”。 123456789&lt;NavLink to=\"/react\" activeClassName=\"hurray\"&gt; React&lt;/NavLink&gt;// 当 URL 是 /react, 呈现:// &lt;a href=\"/react\" className=\"hurray\"&gt;React&lt;/a&gt;// 没有设置成active，呈现：// &lt;a href=\"/react\"&gt;React&lt;/a&gt; 任何时候要强制导航，都可以给予&lt;Redirect&gt;。当&lt;Redirect&gt;呈现时，它将使用其prop进行导航。 1&lt;Redirect to=\"/login\" /&gt;","categories":[],"tags":[],"keywords":[]},{"title":"指南/Start","slug":"指南/Start","date":"2020-01-09T04:35:40.087Z","updated":"2020-01-09T04:37:45.995Z","comments":true,"path":"2020/01/09/指南/Start/","link":"","permalink":"http://yoursite.com/2020/01/09/%E6%8C%87%E5%8D%97/Start/","excerpt":"","text":"快速开始npm install -g create-react-app 全局安装create-react-app create-react-app可以很方便，快速的帮你搭建react app。 npx create-react-app my-app &amp;&amp; cd my-app // 2. 创建一个react应用项目 或 npm init react-app my-app 或 yarn create react-app my-app 您可以使用npm或yarn从公共npm注册表中安装React Router。由于我们正在构建网络应用程序，因此在本指南中将使用react-router-dom。 npm install react-router-dom 第一个示例： 基本路由。 在此示例中，路由器处理了3个“页面”：主页，“关于”页面和“用户”页面。当您单击不同的&lt;Link&gt;时，路由器将呈现匹配的&lt;Route&gt;。 注意：在幕后，&lt;Link&gt;会使用真实的href渲染&lt;a&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link&#125; from \"react-router-dom\";export default function App() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/users\"&gt;Users&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &#123;/* &lt;Switch&gt;通过子&lt;Route&gt; 查找 呈现与当前URL匹配的第一个。如果有两个相同的URL只渲染一次这个路径不会渲染第二次*/&#125; &lt;Switch&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/users\"&gt; &lt;Users /&gt; &lt;/Route&gt; &lt;Route path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Home() &#123; return &lt;h2&gt;Home&lt;/h2&gt;;&#125;function About() &#123; return &lt;h2&gt;About&lt;/h2&gt;;&#125;function Users() &#123; return &lt;h2&gt;Users&lt;/h2&gt;;&#125; 第二个示例： 这个例子现实的是嵌套路由的方式。路由 ‘/topic’ 加载Topics组件，该组件将在path: id值上有条件地呈现任何其他 Route 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import React from \"react\";import &#123; BrowserRouter as Router, Switch, Route, Link, useRouteMatch, useParams&#125; from \"react-router-dom\";export default function App() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/topics\"&gt;Topics&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/topics\"&gt; &lt;Topics /&gt; &lt;/Route&gt; &lt;Route path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Home() &#123; return &lt;h2&gt;Home&lt;/h2&gt;;&#125;function About() &#123; return &lt;h2&gt;About&lt;/h2&gt;;&#125;function Topics() &#123; let match = useRouteMatch();//相对于父路由建立&lt;Route&gt;,而url允许建立相对的links. return ( &lt;div&gt; &lt;h2&gt;Topics&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/components`&#125;&gt;Components&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/props-v-state`&#125;&gt; Props v. State &lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &#123;/*Topics页面有自己的&lt;Switch&gt;里面又包含很多的&lt;Route&gt;,Topics里的&lt;Switch&gt;里面的路径是建立在'/topics'路径上的文件。第二个&lt;Route&gt;作为所有主题的页面或者没有主题时选择的页面 */&#125; &lt;Switch&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:topicId`&#125;&gt; &lt;Topic /&gt; &lt;/Route&gt; &lt;Route path=&#123;match.path&#125;&gt; &lt;h3&gt;Please select a topic.&lt;/h3&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125;function Topic() &#123; let &#123; topicId &#125; = useParams(); return &lt;h3&gt;Requested topic ID: &#123;topicId&#125;&lt;/h3&gt;;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"dependency injection","slug":"injection","date":"2020-01-08T12:14:30.000Z","updated":"2020-01-10T15:15:02.607Z","comments":true,"path":"2020/01/08/injection/","link":"","permalink":"http://yoursite.com/2020/01/08/injection/","excerpt":"","text":"golang 的 类型注入. wirehttps://github.com/google/wire 这个框架可以让我们们来实现 依赖注入 . 具体写个例子","categories":[],"tags":[],"keywords":[]},{"title":"db-index","slug":"db-index","date":"2020-01-06T15:22:35.000Z","updated":"2020-01-10T15:15:02.606Z","comments":true,"path":"2020/01/06/db-index/","link":"","permalink":"http://yoursite.com/2020/01/06/db-index/","excerpt":"","text":"一个事务引发的血案真的是理论永远是理论,只有实践了才知道, 最近在写用户注册的服务,由于用户注册的过程中需要在多张表里面插入数据, 因此我用了事务来做这个,ACID 还是知道的, 但是,坑人的是,这些表的主键都是从一个种子表中取得的, 因此,坑就出现了,在事务中,需要多次从种子表中去获取主键(select update 操作) 导致在多个事物中,会争夺对种子表的锁, 死锁就这样产生了, 最后的解决办法,就是提前申请好种子,将申请种子的这个过成放在食物的外面执行,不过我还是觉得用数据库的来做种子还是有问题了,这个可以直接做个服务, 像雪花算法,都是可以在并发情况下生种子的, 索引的问题最近写的接口还是有点慢的,感觉自己对索引这部分的知识还是掌握的不够透彻, 重新再做个总结 为什么我使用了索引，查询还是慢？今天看到篇文章不错,做个读后记录 索引的分类索引有 聚簇索引,联合索引, 主键索引 唯一索引 (在一个字段或者在多个字段上做索引, 这个字段是不会重复的) 主键索引 (这个也是属于唯一索引,primariykey) 聚集索引 / 非聚集索引(该索引的顺序决定了表中数据的物理存储顺序) 组合索引 查看执行计划sql 语句我们可用通过查看执行计划,来看查询的具体实现过程, 是使用了索引还是全表扫描 TODO","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"keywords":[]},{"title":"redis-skiplist","slug":"redis-skiplist","date":"2020-01-06T14:37:02.000Z","updated":"2020-01-10T15:15:02.608Z","comments":true,"path":"2020/01/06/redis-skiplist/","link":"","permalink":"http://yoursite.com/2020/01/06/redis-skiplist/","excerpt":"","text":"AVL 平衡树定义左右子树的高度差不超过1 特性左右子树的值有如下的特性, 因此 AVL 树在查询和排序方面有优越性,时间复杂度是 logn 12left &lt; head &lt;right 一些问题,由于AVL 为了保持, 上面的特性, 因此AVL 树在Insert , Delete 过程中涉及到了,节点的位置调整, 这个也就是左旋,右旋,(我没有弄懂这个,写不出来) skiplistredis 引入跳表是为了解决什么问题为了在大量的数据中位置数据的有序,同时要在数据的查询,删除,过程 取得一个平衡的位置,使得insert, delete 不会有很大的时间复杂度,而跳表具有这个特性, 并且从编码实现方面来说要比红黑书,AVL, B tree , B plus tree 简单的多. redis 在那些地方使用了跳表redis 的有序数据集的底层实现,都使用了跳表 sorted set(有序字典)大概的实现skiplist 就是一个链表其中从链表的一个Node 来看,他是一个高层楼房, 其中每一层 都串联到 同样海拔高度的 Node 的楼房, 那么查找一个数据的过程变变成了从最高的海拔 ,不停的往下找,同时, 选择前进或者后退 https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}],"keywords":[]},{"title":"golang-errors","slug":"golang-errors","date":"2020-01-06T13:22:07.000Z","updated":"2020-01-10T15:15:02.607Z","comments":true,"path":"2020/01/06/golang-errors/","link":"","permalink":"http://yoursite.com/2020/01/06/golang-errors/","excerpt":"","text":"error 只是一个接口的实现我们之前在定义一个错误的时候只需要 实现如下的一个函数签名, 就可以认为这个结构体是一个error 类型的 1234type error interface &#123; Error() string&#125; 如这里的T1 就是一个error 12345678type T1 struct &#123; Desc string&#125;func (t1 T1) Error() string &#123; return fmt.Sprintf(\"T1 error :%s\", t1.Desc)&#125; 1.3 之前的我们catch错误在以前我们经常用nil 去比较代码是否发生错误, 如下面的例子 123456789func main() &#123; var err error err =Throw() if err != nil &#123; panic(err) &#125; fmt.Println(\"right\")&#125; 判断错误的类型要判断错误的来源是那个我们可以使用下面的技术 123456var ErrNotFound = errors.New(\"not found\")if err == ErrNotFound &#123; // something wasn't found&#125; 同样我们也可以使用类型断言,来确定这个错误是由那个具体的对象抛出的 1234if e, ok := err.(*NotFoundError); ok &#123; // e.Name wasn't found&#125; 对于错误的处理一般情况下, 我们不仅仅要catch 错误,为了这些的可读性行更好, 更容易定位问题的出现位置, 我们都会添加一些附加信息, 如下 12345678func UserRegister(name string) error &#123; //..... if err :=register(name); err !=nil &#123; return errors.New(\"用户注册失败\"+err.Error()) &#125;&#125; 上面的只是一个简单的例子, 一些常见的例子,你可能还需要带上包的位置,这样对象这些错误,一旦看到,我们很容易定位到问题发生的具体位置, 对于这个需求有https://github.com/pkg/errors 这个包很有用.可以很方便的实现我们的需求,同样你也可以定义不同的结构体,在合适的位置抛出错误. 我们的需求通过开发的实践, 我们发现上面的2个情况是我们经常面对的, 所以在1.3 的版本对error 的处理,语言自己提供了更多的选择 1.3 之后的我们Unwrap这个方法可以 相当与就是 对error 脱衣服,可以看到衣服下面的具体错误类型,你可以一直让他脱衣服, 一直到他脱光光,通过下面的源码可以看到,这个函数是在递归调用. 12345678910func Unwrap(err error) error &#123; u, ok := err.(interface &#123; Unwrap() error &#125;) if !ok &#123; return nil &#125; return u.Unwrap()&#125; Is这个是为了类型的断言, 我们不需要再使用==去判断错误的具体类型, 只是需要小小的调用Is,传入2个参数,就可以完成,类型判断 12345678910111213141516171819202122232425// 原来errorA == errorB func Is(err, target error) bool &#123; if target == nil &#123; return err == target &#125; isComparable := reflectlite.TypeOf(target).Comparable() for &#123; if isComparable &amp;&amp; err == target &#123; return true &#125; if x, ok := err.(interface&#123; Is(error) bool &#125;); ok &amp;&amp; x.Is(target) &#123; return true &#125; // TODO: consider supporing target.Is(err). This would allow // user-definable predicates, but also may allow for coping with sloppy // APIs, thereby making it easier to get away with them. if err = Unwrap(err); err == nil &#123; return false &#125; &#125;&#125; 你看看这个源码还是使用了反射来判断底层的错误类型,举个使用的例子 12345678func main()&#123; if errors.Is(errorA, errorB)&#123; fmt.Println(\"这个错误是B\") &#125;&#125; As类型断言我们不要了, 我们写的代码更好看了 12345678910func As(err error, target interface&#123;&#125;) bool &#123; val := reflectlite.ValueOf(target) typ := val.Type() if typ.Kind() != reflectlite.Ptr || val.IsNil() &#123; panic(\"errors: target must be a non-nil pointer\") &#125; // ....&#125; 12345if errors.As(errorA,NotFoundError)&#123; fmt.Println(\"errorA 是NotFoundError 的一种类型\")&#125; Wrap 包装错误fmt 包 默认直接输入error 可以自动包装错误了,添加了一个特殊的打印符 12return nil, fmt.Errorf(\"%q: %w\", name, ErrNotFound)","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"http://yoursite.com/tags/Go/"}],"keywords":[]},{"title":"docker-operate","slug":"docker-operate","date":"2020-01-04T06:53:27.000Z","updated":"2020-01-10T15:15:02.607Z","comments":true,"path":"2020/01/04/docker-operate/","link":"","permalink":"http://yoursite.com/2020/01/04/docker-operate/","excerpt":"","text":"停止所有的container1docker stop $(docker ps -q) 清除 所有的docker container1docker rm $(docker ps -a -q) 清除 所有的磁盘挂载1docker volume prune","categories":[],"tags":[{"name":"kubernates","slug":"kubernates","permalink":"http://yoursite.com/tags/kubernates/"}],"keywords":[]},{"title":"rancher-k8s-deploy","slug":"rancher-k8s-deploy","date":"2020-01-03T15:01:27.000Z","updated":"2020-01-10T15:15:02.608Z","comments":true,"path":"2020/01/03/rancher-k8s-deploy/","link":"","permalink":"http://yoursite.com/2020/01/03/rancher-k8s-deploy/","excerpt":"","text":"Rancher install如果之前安装过,需要清理 /opt/rancher 文件夹 docker run -d -p 80:80 -p 443:443 \\ --restart=unless-stopped \\ -v /opt/rancher:/var/lib/rancher \\ rancher/rancher:latest 选择","categories":[],"tags":[{"name":"kubernates","slug":"kubernates","permalink":"http://yoursite.com/tags/kubernates/"}],"keywords":[]},{"title":"gitlab-deploy.md","slug":"gitlab-deploy-md","date":"2020-01-03T14:49:16.000Z","updated":"2020-01-10T15:15:02.607Z","comments":true,"path":"2020/01/03/gitlab-deploy-md/","link":"","permalink":"http://yoursite.com/2020/01/03/gitlab-deploy-md/","excerpt":"","text":"gitlab 部署123456789sudo docker run --detach \\ --hostname 47.110.136.181 \\ --publish 443:443 --publish 80:80 --publish 23:22 \\ --name gitlab \\ --restart always \\ --volume &#x2F;srv&#x2F;gitlab&#x2F;config:&#x2F;etc&#x2F;gitlab \\ --volume &#x2F;srv&#x2F;gitlab&#x2F;logs:&#x2F;var&#x2F;log&#x2F;gitlab \\ --volume &#x2F;srv&#x2F;gitlab&#x2F;data:&#x2F;var&#x2F;opt&#x2F;gitlab \\ gitlab&#x2F;gitlab-ce:latest 部署太慢可以先拉去镜像dockerhub.azk8s.cn/library/gitlab/gitlab-ce","categories":[],"tags":[{"name":"kubernates","slug":"kubernates","permalink":"http://yoursite.com/tags/kubernates/"}],"keywords":[]},{"title":"debug-k8s","slug":"debug-k8s","date":"2020-01-03T14:40:01.000Z","updated":"2020-01-10T15:15:02.607Z","comments":true,"path":"2020/01/03/debug-k8s/","link":"","permalink":"http://yoursite.com/2020/01/03/debug-k8s/","excerpt":"","text":"查看pod 状态12kubectl -n kube-ops describe pod runner-svzx4ujw-project-1-concurrent-0qd6hq 删除podkubectl -n kube-ops delete pods runner-svzx4ujw-project-1-concurrent-0qd6hq –grace-period=0 –force 查看pod 中的containerkubectl get pods –all-namespaces -o=jsonpath=’{range .items[]}{“\\n”}{.metadata.name}{“:\\t”}{range .spec.containers[]}{.image}{“, “}{end}{end}’ |sort 查看pod 中container 的日志kubectl logs -c","categories":[],"tags":[{"name":"kubernates","slug":"kubernates","permalink":"http://yoursite.com/tags/kubernates/"}],"keywords":[]},{"title":"hello-world","slug":"hello-world","date":"2020-01-03T03:19:08.000Z","updated":"2020-01-10T15:15:02.607Z","comments":true,"path":"2020/01/03/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/03/hello-world/","excerpt":"","text":"12345678910111213$ sudo npm install -g hexo-cli$ hexo -vhexo-cli: 0.1.9os: Darwin 14.3.0 darwin x64http_parser: 2.3node: 0.12.7v8: 3.28.71.19uv: 1.6.1zlib: 1.2.8modules: 14openssl: 1.0.1p","categories":[],"tags":[],"keywords":[]}]}